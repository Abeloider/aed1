***
***		Full Maude specification version 1.0.5
***  	               April 11, 2000
***          Copyright 1998, 1999, 2000 SRI International
***

*** - atts memo and ctor handled (3-6-00)
*** - bug in the handling of parameterized sorts in subsort 
***   relations fixed (3-7-00)
*** - bug meta-pretty-printing fths fixed (3-9-00)
*** - processViewAux, prepareVarDeclSet, and prepareViewMapSet have been
***   modified trying to fix a problem with theories importing instantiated
***   modules, but it didn't work. The modifications shouldn't affect the
***   normal behavior of the module algebra (3-9-00)
*** - changed rew`[_`]. to rew-`[_`]., rewrite`[_`]. to rewrite-`[_`]., 
***   rew-in`[_`]. to rew-in-`[_`]., and rewrite-in`[_`]. to rewrite-in-`[_`].
***   in order to avoid the ambiguities produced with these commands (3-9-00)
*** - downMachineInt modified to use convert (3-10-00)
*** - bug in prepareESortList fixed (3-10-00)
*** - multiple message declarations in the same line are allowed (3-10-00)
*** - errorSort -> Error (3-13-00)
*** - Result -> result (3-13-00)
*** - "loop init ." added to the end of the file (3-15-00)
*** - banner to be emitted on start up added (3-15-00)
*** - "trace exclude EXT-FULL-MAUDE ." added to the end of the file (3-15-00)
*** - "set show loop stats on ." added to the end of the file (3-15-00)
*** - "set show loop timing on ." added to the end of the file (3-15-00)
*** - Some error handling has been added, for example, now it checks
***   that the attributes used in objects are ok. It recovers from some 
***   error terms and error modules in more cases. I have defined ops
***   my-meta-pretty-print and my-leastSort to be able to recover in case
***   the attributes are not of the right sorts, calling the respective
***   built-in functions only if the arguments are of the right sorts.
***   If it works fine and there is no other way of making it I'll 
***   do the same with other built-in functions for which similar problems
***   may happen (3-21-00).
*** - Bug transforming the signature of oo modules fixed. Only the 
***   classes and subclass relations of the top module were being 
***   considered. I have modified prepareClasses and prepareClasses2 
***   in order to consider the sorts and subsort relations coming 
***   from the included modules (3-21-00).
*** - Bug in the handling of modules importing the module META-LEVEL
***   instantiated by some module fixed. The back pointers were not
***   being established properly (4-11-00).
*** - Deprecated synonyms obj (fmod), endo and jbo (endfm), and
***   cq (ceq) are now handled (4-11-00).

*** The comments are part of a draft of the technical report "The Maude
*** Specification of Full Maude" documenting the specification, which is
*** available at the Maude web page. 

***(%
\label{implementation}

\section{Full Maude in Maude}
\label{implementation-introduction}

The efforts required for building adequate tools for formal specification
languages are considerable.  Such efforts can be particularly intense when
such languages are \emph{executable}, since a good execution engine must also
be developed to have a complete execution environment.  The methods we propose
to implement tools for formal specification languages in Maude (see
also~\cite{ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada98,ClavelDuranEkerMeseguer99})
can be used in practice to develop tools and environments for formal
specification languages, including executable ones, and to endow such
languages with a powerful module algebra of specification-combining
operations.

We have applied these methods to the design and implementation of Maude
itself. The most basic parts of the language---supporting module hierarchies
of functional and system modules and some predefined modules---are implemented
in C++, giving rise to a sublanguage called Core Maude.  This is extended by
special syntax for object-oriented specifications, and by a rich \emph{module
algebra} of parameterized modules and module composition in the Clear/OBJ
style~\cite{BurstallGoguen80,OBJ92}, as described in Chapter~\ref{design},
giving rise to the Full Maude language.

All of Full Maude has been formally specified in Core
Maude~\cite{DuranMeseguer98,DuranMeseguer99}.  This executable formal
specification---a Maude specification of about 7,000 lines---is in
fact its implementation in the Maude 1.00 system.  Our experience in
this regard is very encouraging in several respects.  Firstly, because
of how quickly we were able to develop Full Maude.  Secondly, because
of how easy it will be to maintain it, modify it, and extend it with
new features and new module operations (see Section~\ref{extension}
and Chapter~\ref{crc}).  Thirdly, because of the competitive
performance with which we can carry out very complex module
composition and module transformation operations, that makes the user
interaction with Full Maude quite reasonable.

But the reflective methods described here, that underly our development of
Full Maude, are much more general.  They can equally be used to develop
high-performance executable environments for other formal specification
languages with much less effort and much greater flexibility, maintainability,
and extensibility than what would be required in conventional implementations.
For example, an executable environment for Action Semantics~\cite{Mosses92} is
currently being considered, and it would be quite interesting to explore Maude
implementations, for example, for a next-generation
CafeOBJ~\cite{DiaconescuFutatsugi98} and for CASL~\cite{casl}.  Therefore,
before discussing in detail the executable specification of Full Maude in
Maude, we explain the more general methodology for building formal tools for
different logics in Maude, of which the Full Maude specification in this
chapter and the Church-Rosser checker in Chapter~\ref{crc} are particular
applications.

\subsection{Building Formal Tools in Maude}

Suppose that we want to build a theorem prover for a logic, or an executable
formal specification language.  We can do so by representing the logic
$\mathcal{L}$ of the theorem prover or specification language in question in
rewriting logic by means of a representation map
$$ \Psi: \mathcal{L} \longrightarrow \mathit{RWLogic}.$$ 
Such representations are typically very simple and natural.  Using reflection
we can, as already explained in
Section~\ref{metalanguage-uses},
\emph{internalize} such a map as an executable equationally defined function
$\overline{\Psi}$.  In Maude this is accomplished using the module
\texttt{META-LEVEL} and its sort \texttt{Module}.  Specifically, we can reify
the above representation map $\Psi$ by defining an abstract data type
$\texttt{Module}_\mathcal{L}$ representing theories in the logic
$\mathcal{L}$.  We can then internalize the representation map $\Phi$ as an
equationally defined function
$$\overline{\Phi}: 
   \texttt{Module}_\mathcal{L} \longrightarrow \texttt{Module}$$
in a module extending \texttt{META-LEVEL}.  Then, we can use the functions
\texttt{meta-reduce}, \texttt{meta-apply}, and \texttt{meta-rewrite}, or more
complex strategies that use such functions, to execute in Maude the
metarepresentation $\overline{\Psi}(\overline{T})$ of a theory $T$ in
$\mathcal{L}$.  In other words, we can in this way \emph{execute}
$\mathcal{L}$ in Maude.

But we need more.  To build a usable formal tool we need to build an
\emph{environment} for it, including not only the execution aspect just
described, but parsing, pretty printing, and input/output. If we had instead
considered formal translator generator uses of Maude---that is, translations
of the form $\Phi\!:\mathcal{L}\rightarrow\mathcal{L'}$ between two logics,
that can be reified in Maude as functions
$\bar{\Phi}\!:\texttt{Module}_\mathcal{L}\rightarrow\texttt{Module}_\mathcal{L'}$---we would have observed entirely similar needs, since we need to get the
specifications in different logics---originating from, or going to, different
tools---in and out of Maude by appropriate parsing, pretty printing, and
input-output functions.  In Maude, these additional metalanguage features are
supported as follows:

\begin{itemize}
\item 
The \emph{syntax definition} for $\mathcal{L}$ is accomplished by defining the
data type $\texttt{Grammar}_\mathcal{L}$.  In Maude this can be done with very
flexible user-definable \emph{mixfix} syntax, that can mirror the concrete
syntax of an existing tool supporting $\mathcal{L}$.

\item 
Particularities at the \emph{lexical} level of $\mathcal{L}$ can be
accommodated by user-definable \emph{bubble sorts}, that tailor the adequate
notions of token and identifier to the language in question (see
Section~\ref{bubbles}).  This is very useful when the theories in
$\mathcal{L}$ have user-definable syntax, since then we can use such bubble
sorts to represent strings of symbols corresponding to expressions that can
only be analyzed after the user-defined syntax has been analyzed.

\item 
Parsing and pretty printing for $\mathcal{L}$ is accomplished by the
\texttt{meta-parse} and \texttt{meta-pretty-print} functions in
\texttt{META-LEVEL}, in conjunction with the bubble sorts defined for
$\mathcal{L}$ (see Section~\ref{parsing-sorts}).

\item 
Input/output of theory definitions, and of commands for execution in
$\mathcal{L}$ is accomplished by the predefined module \texttt{LOOP-MODE},
that provides a generic read-eval-print loop (see Section~\ref{loop}).
\end{itemize}


\label{execution-environment}

As we saw in Section~\ref{loop}, given any input enclosed in parentheses, the
read-eval-print loop gives us access to a list of quoted identifiers
$\mathcal{I}$ obtained automatically by putting a quote in front of each of
the identifiers in the input. Similarly, any list of quoted identifiers placed
in the ``output channel'' of the loop will be printed in the terminal after
removing the quotes. Calling the function \texttt{meta-parse} with the input
$\mathcal{I}$ and the metarepresentation of the signature
$\texttt{Grammar}_\mathcal{L}$ in which we want to parse it, if there is a
parse, we get the corresponding \emph{parse tree} as a term
$\mathcal{T}_\mathcal{I}$ of sort \texttt{Term}.  The reverse process is
accomplished by the \texttt{meta-pretty-print} function, which takes a term of
sort \texttt{Term}, and returns its representation as a list of quoted
identifiers.

The term $\mathcal{T}_\mathcal{I}$ can be seen as the representation of the
input $\mathcal{I}$ as a term of sort \texttt{Term}.  We could manipulate this
term directly, applying any transformation to it and obtaining some other term
representing the desired result, or we could apply some function to it to
perform some kind of analysis or computation. Our experience, however, is that
it is simpler and more flexible to transform this term into another term in
some data type more appropriate for representing the input.

Suppose, for example, that we want to specify the transformation from modules
in some language or logic $\mathcal{L}$ into modules in some language or logic
$\mathcal{L'}$. First, we define abstract data types
$\texttt{Module}_\mathcal{L}$ and $\texttt{Module}_{\mathcal{L}'}$.  Then, we
equationally define a function
$$
\Lambda\!:\texttt{Term}\longrightarrow\texttt{Module}_\mathcal{L}
$$
returning a term of sort $\texttt{Module}_\mathcal{L}$ for each term
$\mathcal{T}_\mathcal{I}$ of sort \texttt{Term} corresponding to an input
$\mathcal{I}$.  Then, we can compose this function with the also
equationally defined function
$$\overline{\Phi}\!:\texttt{Module}_\mathcal{L}
        \longrightarrow\texttt{Module}_{\mathcal{L}'}$$
reifying a map of logics of the form 
$$\Phi\!:\mathcal{L}\longrightarrow{\mathcal{L}'}.$$

The whole picture can be completed with a user-defined
\texttt{meta-pretty-print} function extending the predefined one.
$$\texttt{QidList}
  \mathop{\mbox{\rightarrowfill}}_{\mathtt{Grammar}_\mathcal{L}}^{\mathtt{\ meta-parse\ }}
  \texttt{Term}
  \mathop{\longrightarrow}^\Lambda
  \texttt{Module}_\mathcal{L}
  \mathop{\longrightarrow}^{\overline{\Phi}}
  \texttt{Module}_{\mathcal{L}'}
  \mathop{\mbox{\rightarrowfill}}_{\mathtt{Grammar}_\mathcal{L}}^{\mathtt{\ meta-pretty-print\ }}
  \texttt{QidList}$$

In the case of an \emph{executable} environment, this picture may have to be
extended to meet additional requirements.  In the case of Full Maude, for
example, we not only want to apply some transformation on some particular
input, or to just give some command or module expression with some particular
set of arguments and get some result. We also want to be able to interact with
the system, entering modules, theories, views, and commands of different
types.

In addition, such modules can be highly structured and parameterized.  That
is, there can be a rich collection of module composition operations endowing
${\cal L}$ with a {\em module algebra}.  In such cases we typically have two
data types of modules, a data type $\texttt{Module}_{\cal L}$ of {\em flat} or
unstructured modules, and a more general data type 
$\texttt{StrModule}_{\cal L}$ of structured modules.

All the module algebra operations for
${\cal L}$ can be defined within Maude as an extension of the module
\texttt{META-LEVEL}.  In this way, the environment that we can build for
${\cal L}$ using Maude can also support all the module composition operations
of ${\cal L}$.  Among those module operations a common and important one is
{\em flattening}, that is, the process of passing from a structured module to
its unstructured flat form.  This can be understood as a function
%
\[\texttt{StrModule}_{\cal L} \stackrel{(\_)^{\flat}}{\longrightarrow}
\texttt{Module}_{\cal L} .
\]
%

Since modularity constructs can change from language to language, it may be
simpler to represent ${\cal L}$ in rewriting logic by representing only its
flat modules, that is, by a function 
$\overline{\Phi}: \texttt{Module}_{\cal L} \longrightarrow \texttt{Module}$
which makes the language ${\cal L}$ executable on top of Maude.  But using the
function $(\_)^{\flat}$ we can also make structured modules in ${\cal L}$
executable by means of the function composition
\[
\texttt{StrModule}_{\cal L} \stackrel{(\_)^{\flat}}{\longrightarrow}
\texttt{Module}_{\cal L}
\stackrel{\overline{\Phi}}{\longrightarrow}
\texttt{Module}.
\]

We may also want to be able to \emph{refer by name} to modules, theories, and
views in any other module, theory, view, or command. In Full Maude, for
example, modules can be parameterized by theories, and both of them can import
other modules or theories, or combinations of them given by \emph{module
expressions}. A module importing some module expressions can be seen as
denoting a structured module with more or less complex relationships among its
component submodules. We want to be able to store modules, theories, and views
in a \emph{database}, so that they can be referred later in order to
evaluate module expressions, evaluate commands, and so on. Given a data type
\texttt{Database} for the database of modules, theories, and views, the
processing of a term obtained from a call to \texttt{meta-parse} with an input
corresponding, for example, to a module can be seen as a function
$$\texttt{Term}\times\texttt{Database}
  \mathop{\mbox{\rightarrowfill}}^{\mathtt{\ processModule\ }}
  \texttt{Database}.$$

In the case of commands, we can see their processing as the following function.
$$\texttt{Term}\times\texttt{Database}
  \mathop{\mbox{\rightarrowfill}}^{\mathtt{\ processCommand\ }}
  \texttt{Database}\times\texttt{QidList}.$$
Note that some module, theory, or view in the database can be referred to in a
command. There might be commands changing the database itself, for example, a
command to remove a module from the database. The execution of a
command may also generate some output, which will have to be conveniently
meta-pretty-printed, so that it can be passed to the loop.

\subsection{The Full Maude Execution Environment}

In the case of Full Maude, there are several data types and several
transformations taking place in the system.  The main data types are:
\texttt{Unit}, for the different types of theories and modules; \texttt{View}
for views; and \texttt{Database} for the database of module, theory, and view
definitions. We also have subsorts of \texttt{Unit} for the different types of
theories and modules. For example, we have sorts \texttt{StrOModule} and
\texttt{StrSModule} for structured object-oriented modules and structured
system modules, respectively, and the transformation from object-oriented
modules to system modules, described in Section~\ref{omod2mod}, is reified as a
function
$$
\texttt{objectOrientedToSystemModule\ :\ StrOModule\ Database\ ->\ StrSModule}
$$

We discuss the details about the data types \texttt{Unit}, \texttt{View}, and
\texttt{Database} in Sections~\ref{sec:unitADT}, \ref{sec:viewADT}, and
\ref{sec:databaseADT}, respectively, and the details about the function
\texttt{objectOrientedToSystemModule} in Section~\ref{omod2modfunction}.

To be able to \emph{execute} some command using functions such as
\texttt{meta-rewrite} or \texttt{meta-reduce}, or to be able to use any of the
other predefined functions in the \texttt{META-LEVEL} module on the modules
entered to Full Maude, we need to map terms of sort \texttt{Unit} into terms
of sort \texttt{Module}, which will then be compiled into the rewrite engine.
Note, however, that terms of sort \texttt{Unit} are structured modules, where
the structure is given by module expressions that refer by
name to other modules, or combinations of modules, which are stored in the
database. This function in fact takes a unit and a database and returns the
database after including the resulting module in it.
$$\texttt{evalUnit\ :\ Unit\ Database\ ->\ Database}$$

Terms of sort \texttt{Module} can only contain importation declarations of
predefined modules, or of modules entered at the object level of Core
Maude. Therefore, structured modules have to be ``partially flattened,''
leaving only importations of built-ins\footnote{Although still partially
structured, we shall refer to this ``partially flattened'' module as a module
in \emph{unstructured form} or in \emph{flattened form}.}. In our approach,
transforming a module from its possibly complex structured version to its
unstructured form is a two-step process. First, the evaluation of the module
expressions results in an intermediate form, in which only simple inclusion
relationships appear among the modules; this first step can be seen as the
reduction of a structured specification to its \emph{structured normal
form}. The normalization of the structure is carried out by the
\texttt{normalization} function. It takes place on the database, and gives as
result a possibly modified version of the database state.  Then, in a second
step, this structured normal form is flattened into an unstructured
specification. Note that, instead of flattening the modules before evaluating
the expressions, as it is done in many systems, we prefer to define operations
on structured modules that return new structured modules. Besides simplicity
and extensibility, the main advantage of dealing with structured modules is
that the sharing of sub-structures is made explicit, avoiding the introduction
of duplicated modules, or the cost of checking for it. We explain this process
in detail in Section~\ref{evaluation-units}.

Since units can contain bubbles, which have to be parsed using the signature
of the unit itself, the function $\Lambda$ mentioned in
Section~\ref{execution-environment} can be split in three stages. As we saw in
Section~\ref{bubbles}, to be able to parse the bubbles in a module, we first
need, in a first stage, to extract the signature. Then, in a second stage, a
function $\Lambda_1$ replaces each bubble by its parsed term using the
extracted signature. Then, in a third stage, we map the resulting term of sort
\texttt{Term} without bubbles to a term of sort $\texttt{Module}_\mathcal{L}$
using a function $\Lambda_2$.
$$\texttt{Term} 
  \mathop{
   \mbox{
    \rightarrowfill}}^{\ (1_{\mathtt{Term}}\ \times\ \mathtt{getSignature})\ }
  \texttt{Term} \times \texttt{Sign}_\mathcal{L}
  \mathop{\longrightarrow}^{\ \Lambda_1\ }
  \texttt{Term} 
  \mathop{\mbox{\rightarrowfill}}^{\ \Lambda_2\ }
  \texttt{Module}_\mathcal{L}$$
However, this process is computationally quite expensive. Note that building
the signature can be almost as expensive as building the whole module. We shall
see in detail in Section~\ref{evaluation} how this process is efficiently
accomplished. The idea is to build at the same time a term of sort
$\texttt{Module}_\mathcal{L}$ with bubbles, which we call a \emph{premodule},
and the signature, using finally the signature to parse the bubbles in the
premodule and returning the module without bubbles in it. We can see the
process as the functional composition
$$\texttt{Term} 
  \longrightarrow
  \texttt{Sign}_\mathcal{L} \times \texttt{PreModule}_\mathcal{L}
  \longrightarrow
  \texttt{Module}_\mathcal{L}.$$
Notice that in the case of Full Maude we are dealing with structured modules,
which are used to construct the signature and to evaluate a module expression
in the database.  In Full Maude, this process is accomplished by the
\texttt{evalPreUnit} function. We will discuss it in Section~\ref{evaluation}
as well. In fact, we shall see that the functions \texttt{evalUnit} and
\texttt{evalPreUnit} are quite similar.

The rest of the chapter is organized as follows. Section~\ref{sec:signature}
presents the way in which the signature of Full Maude, presented in
Chapter~\ref{design} and in Appendix~\ref{signature-full-maude}, is related to
the rest of the specification. Sections~\ref{unitADT}, \ref{viewADT},
and~\ref{databaseADT} explain, respectively, the data types \texttt{Unit},
\texttt{View}, and \texttt{Database}. The evaluation of units and views is
described, respectively, in Sections~\ref{evaluation-units}
and~\ref{evaluation-views}. In Section~\ref{input-output-processing}
we discuss the processing of the input/output of the system, and in
Section~\ref{database-handling} we describe the top-level handling of
the persistent database and its interaction with the read-eval-print
loop presented in Section~\ref{loop}. Finally, in
Section~\ref{extension} we illustrate the flexibility and
extensibility of the Full Maude system by introducing some new module
expressions. Another extension of Full Maude to a theorem-proving tool
for checking the Church-Rosser property will be discussed in detail in
Chapter~\ref{crc}.

We do not intend to present here all the details of the executable
specification of Full Maude.  See~\cite{DuranMeseguer99} for this
discussion. Here, we present an overview of the whole system, focusing on its
most important aspects and its main functionality.
We present the different modules with their main declarations so that a
general idea of the whole system can be gained. Declarations of operators not
relevant for the general discussion, as well as equations describing the
semantics of some functions and some rules, are omitted. We sometimes add dots
``\texttt{...}'' to indicate the missing equations and declarations.

All the declarations of the variables used are presented. However, some
explanation of the conventions followed may ease the readability of the
specification. We have followed very simple conventions for naming variables,
sorts, and operators. As for the predefined modules, sort names are given
starting with a capital letter. When the sort name is the concatenation of
different words, or parts of words, each of the parts starts with a capital
letter. Thus, we have, for example, sorts \texttt{UnitList} and
\texttt{SubclassDecl} for lists of units and for declarations of subclass
relations, respectively. Variables are named using the capital letters of
the names of the sorts in which they are defined. For example, we have
variables \texttt{B} of sort \texttt{Bool} or \texttt{VDS} of sort
\texttt{VarDeclSet}. However, we have made some exceptions to this rule when
there was a possibility of confusion, or seemed more natural. For example,
\texttt{QI}, \texttt{F}, \texttt{V}, and \texttt{L} are used as names of
variables of sort \texttt{Qid} when they are used as any quoted identifier, as
an operator name, as a variable name, or as a label, respectively, and there
are variables \texttt{Eq}, \texttt{Rl}, and \texttt{AtS} for elements of sorts
\texttt{Equation}, \texttt{Rule}, and \texttt{AttrSet}, respectively.

\section{The Signature of Full Maude}
\label{sec:signature}

The signature of Full Maude is given in its entirety in
Appendix~\ref{signature-full-maude}, and has already been discussed in
detail in Chapter~\ref{design} and
in~\cite{ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada99}. We focus
here on the way in which the signature is used in the specification,
and in the way in which it can be extended in future extensions of
Full Maude.

\begin{comment}
\small
\begin{verbatim}
%)


fmod SIGNS&VIEW-EXPRS is
  sorts Token NeTokenList Bubble
        SortToken Sort SortList SortDecl 
        ViewToken ViewExp 
        SubsortRel SubsortDecl 
        OpDecl Attr AttrList Hook HookList .
  subsorts SortToken < Sort < SortList .
  subsort ViewToken < ViewExp .
  subsort Attr < AttrList .
  subsort Hook < HookList .

  op ((_)) : Token -> Token .

  *** extended sorts
  op _[_] : Sort ViewExp -> Sort [prec 40] .
  op __ : SortList SortList -> SortList [assoc] .
  op _,_ : ViewExp ViewExp -> ViewExp [assoc] .

  *** sort declaration
  op sorts_. : SortList -> SortDecl .
  op sort_. : SortList -> SortDecl .

  *** subsort declaration
  op subsort_. : SubsortRel -> SubsortDecl .
  op subsorts_. : SubsortRel -> SubsortDecl .
  op _<_ : SortList SortList -> SubsortRel .
  op _<_ : SortList SubsortRel -> SubsortRel .

  *** operator attributes
  op __ : AttrList AttrList -> AttrList [assoc] .
  op assoc : -> Attr .
  op associative : -> Attr .
  op comm : -> Attr .
  op commutative : -> Attr .
  op ctor : -> Attr .
  op constructor : -> Attr .
  op memo : -> Attr .
  op memoization : -> Attr .
  op id:_ : Bubble -> Attr .
  op identity:_ : Bubble -> Attr .
  op left id:_ : Bubble -> Attr .
  op left identity:_ : Bubble -> Attr .
  op right id:_ : Bubble -> Attr .
  op right identity:_ : Bubble -> Attr .
  op strat(_) : NeTokenList -> AttrList .
  op strategy(_) : NeTokenList -> AttrList .
  op prec_ : Token -> Attr .
  op precedence_ : Token -> Attr .
  op gather(_) : NeTokenList -> Attr .
  op gathering(_) : NeTokenList -> Attr .
  op idem : -> Attr .
  op idempotent : -> Attr .

  op special(_) : HookList -> Attr .
  op __ : HookList HookList -> HookList [assoc] .
  op id-hook_ : Token -> Hook .
  op id-hook_(_) : Token NeTokenList -> Hook .
  op op-hook_(_:_->_) : Token Token NeTokenList Token -> Hook .
  op op-hook_(_: ->_) : Token Token Token -> Hook .
  op term-hook_(_) : Token Bubble -> Hook .

  *** operator declaration
  op op_: ->_. : Token Sort -> OpDecl .
  op op_: ->_[_]. : Token Sort AttrList -> OpDecl .
  op op_:_->_. : Token SortList Sort -> OpDecl .
  op op_:_->_[_]. : Token SortList Sort AttrList -> OpDecl .
  op ops_: ->_. : NeTokenList Sort -> OpDecl .
  op ops_: ->_[_]. : NeTokenList Sort AttrList -> OpDecl .
  op ops_:_->_. : NeTokenList SortList Sort -> OpDecl .
  op ops_:_->_[_]. : NeTokenList SortList Sort AttrList -> OpDecl .

endfm

***(%
\end{verbatim}
\normalsize

\small
\begin{verbatim}
%)

fmod F&S-MODS&THS is
  including SIGNS&VIEW-EXPRS .

  sorts FDeclList SDeclList PreModule 
        ImportDecl ModExp Parameter ParameterList 
        ModuleName EquationDecl RuleDecl MembAxDecl  
        VarDecl VarDeclList .
  subsort Parameter < ParameterList .
  subsorts Token < ModExp ModuleName .
  subsort VarDecl < VarDeclList .
  subsorts VarDecl ImportDecl SortDecl SubsortDecl 
           OpDecl MembAxDecl EquationDecl VarDeclList < FDeclList .
  subsorts RuleDecl FDeclList < SDeclList .

  *** variable declaration
  op vars_:_. : NeTokenList Sort -> VarDecl .
  op var_:_. : NeTokenList Sort -> VarDecl .

  *** membership axiom declaration
  op mb_:_. : Bubble Sort -> MembAxDecl .
  op cmb_:_if_. : Bubble Sort Bubble -> MembAxDecl .

  *** equation declaration
  op eq_=_. : Bubble Bubble -> EquationDecl .
  op ceq_=_if_. : Bubble Bubble Bubble -> EquationDecl .
  op cq_=_if_. : Bubble Bubble Bubble -> EquationDecl .

  *** rule declaration
  op rl[_]:_=>_. : Token Bubble Bubble -> RuleDecl .
  op crl[_]:_=>_if_. : Token Bubble Bubble Bubble -> RuleDecl .

  *** importation declaration
  op including_. : ModExp -> ImportDecl .
  op inc_. : ModExp -> ImportDecl .
  op protecting_. : ModExp -> ImportDecl .
  op pr_. : ModExp -> ImportDecl .

  *** parameterized module interface
  op _::_ : Token ModExp -> Parameter [prec 40 gather (e &)] .
  op _,_ : ParameterList ParameterList -> ParameterList [assoc] .

  op _[_] : Token ParameterList -> ModuleName .

  *** declaration list
  op __ : VarDeclList VarDeclList -> VarDeclList [assoc] .
  op __ : SDeclList SDeclList -> SDeclList [assoc] .
  op __ : FDeclList FDeclList -> FDeclList [assoc] .

  *** functional and system module and theory
  op fmod_is_endfm : ModuleName FDeclList -> PreModule .
  op obj_is_jbo : ModuleName FDeclList -> PreModule .
  op obj_is_endo : ModuleName FDeclList -> PreModule .
  op mod_is_endm : ModuleName SDeclList -> PreModule .
  op fth_is_endfth : ModuleName FDeclList -> PreModule .
  op th_is_endth : ModuleName SDeclList -> PreModule .
endfm

***(%
\end{verbatim}
\normalsize

\small
\begin{verbatim}
%)

fmod O-MODS&THS is
  including F&S-MODS&THS .

  sorts ClassDecl AttrDecl AttrDeclList 
        SubclassDecl MsgDecl ODeclList .
  subsorts SDeclList MsgDecl SubclassDecl ClassDecl < ODeclList .
  subsort AttrDecl < AttrDeclList .

  op __ : ODeclList ODeclList -> ODeclList [assoc] .

  *** object-oriented module and theory
  op omod_is_endom : ModuleName ODeclList -> PreModule .
  op oth_is_endoth : ModuleName ODeclList -> PreModule .

  *** class declaration
  op class_|_. : Sort AttrDeclList -> ClassDecl .
  op class_. : Sort -> ClassDecl .
  op _,_ : AttrDeclList AttrDeclList -> AttrDeclList [assoc] .
  op _:_ : Token Sort -> AttrDecl [prec 40] .

  *** subclass declaration
  op subclass_. : SubsortRel -> SubclassDecl .
  op subclasses_. : SubsortRel -> SubclassDecl .

  *** message declaration
  op msg_:_->_. : Token SortList Sort -> MsgDecl .
  op msgs_:_->_. : NeTokenList SortList Sort -> MsgDecl .
  op msg_:`->_. : Token Sort -> MsgDecl .
  op msgs_:`->_. : NeTokenList Sort -> MsgDecl .
endfm

***(%
\end{verbatim}
\normalsize

\small
\begin{verbatim}
%)

fmod MOD-EXPRS is
  including O-MODS&THS .

  sorts Map MapList .
  subsort Map < MapList .

  *** module expression
  op _*(_) : ModExp MapList -> ModExp .
  op _[_] : ModExp ViewExp -> ModExp .

  *** renaming maps
  op op_to_ : Token Token -> Map .
  op op_:_->_to_ : Token SortList Sort Token -> Map .
  op op_: ->_to_ : Token Sort Token -> Map .
  op op_to_[_] : Token Token AttrList -> Map .
  op op_:_->_to_[_] : Token SortList Sort Token AttrList -> Map .
  op op_: ->_to_[_] : Token Sort Token AttrList -> Map .
  op sort_to_ : Sort Sort -> Map .
  op label_to_ : Token Token -> Map .
  op class_to_ : Sort Sort -> Map .
  op attr_._to_ : Token Sort Token -> Map .
  op msg_to_ : Token Token -> Map .
  op msg_:_->_to_ : Token SortList Sort Token -> Map .
  op msg_: ->_to_ : Token Sort Token -> Map .

  op _,_ : MapList MapList -> MapList [assoc prec 42] .
endfm

***(%
\end{verbatim}
\normalsize

\small
\begin{verbatim}
%)

fmod VIEWS is
  including O-MODS&THS .

  sorts ViewDecl ViewDeclList PreView .
  subsorts VarDecl < ViewDecl < ViewDeclList .
  subsort VarDeclList < ViewDeclList .

  *** view maps
  op op_to term_. : Bubble Bubble -> ViewDecl .
  op op_to_. : Token Token -> ViewDecl .
  op op_:_->_to_. : Token SortList Sort Token -> ViewDecl .
  op op_: ->_to_. : Token Sort Token -> ViewDecl .
  op sort_to_. : Sort Sort -> ViewDecl .
  op class_to_. : Sort Sort -> ViewDecl .
  op attr_._to_. : Token Sort Token -> ViewDecl .
  op msg_to_. : Token Token -> ViewDecl .
  op msg_:_->_to_. : Token SortList Sort Token -> ViewDecl .
  op msg_:`->_to_. : Token Sort Token -> ViewDecl .

  *** view
  op view_from_to_is_endv : 
        ViewToken ModExp ModExp ViewDeclList -> PreView .
  op __ : ViewDeclList ViewDeclList -> ViewDeclList [assoc] .
endfm

***(%
\end{verbatim}
\normalsize

\small
\begin{verbatim}
%)

fmod COMMANDS is
  including MOD-EXPRS .

  sorts PreCommand .

  *** down function
  op down_:_ : ModExp PreCommand -> PreCommand .

  *** reduce command
  op red_. : Bubble -> PreCommand .
  op red-in_:_. : ModExp Bubble -> PreCommand .
  op reduce_. : Bubble -> PreCommand .
  op reduce-in_:_. : ModExp Bubble -> PreCommand .

  *** rewrite command
  op rew_. : Bubble -> PreCommand .
  op rew-[_]_. : Token Bubble -> PreCommand .
  op rew-in_:_. : ModExp Bubble -> PreCommand .
  op rew-in-[_]_:_. : Token ModExp Bubble -> PreCommand .
  op rewrite_. : Bubble -> PreCommand .
  op rewrite-[_]_. : Token Bubble -> PreCommand .
  op rewrite-in_:_. : ModExp Bubble -> PreCommand .
  op rewrite-in-[_]_:_. : Token ModExp Bubble -> PreCommand .

  *** select command
  op select_. : ModExp -> PreCommand .

  *** show commands
  op show module . : -> PreCommand .
  op show module_. : ModExp -> PreCommand .
  op show all . : -> PreCommand .
  op show all_. : ModExp -> PreCommand .
  op show sorts . : -> PreCommand .
  op show sorts_. : ModExp -> PreCommand .
  op show ops . : -> PreCommand .
  op show ops_. : ModExp -> PreCommand .
  op show vars . : -> PreCommand .
  op show vars_. : ModExp -> PreCommand .
  op show mbs . : -> PreCommand .
  op show mbs_. : ModExp -> PreCommand .
  op show eqns . : -> PreCommand .
  op show eqns_. : ModExp -> PreCommand .
  op show rls . : -> PreCommand .
  op show rls_. : ModExp -> PreCommand .
  op show view_. : ViewExp -> PreCommand .
  op show modules . : -> PreCommand .
  op show views . : -> PreCommand .
endfm

***(%
\end{verbatim}
\normalsize

\small
\begin{verbatim}
%)

fmod PRE-FULL-MAUDE-SIGN is
  including VIEWS .
  including COMMANDS .
endfm


***(%
\end{verbatim}
\normalsize
\end{comment}

As explained in Section~\ref{bubbles}, to parse some input using the built-in
function \texttt{meta-parse}, we need to give the metarepresentation of the
signature in which the input is going to be parsed.  
\begin{comment}
In Full Maude, and also
in the beta version of Core Maude~\cite{ClavelDuranEkerLincolnMeseguer98}, it
is possible to have importation declarations of the form
$$\texttt{protecting META-LEVEL[}Id_1,\ldots, Id_n\texttt{] .}$$ 
where $Id_1\ldots Id_n$ are names of user-defined modules. Such a declaration
like this one gives access to the metarepresentations of the modules
$Id_1\ldots Id_n$ in the module containing the declaration (see
Section~\ref{structured-specifications}). Although in the current version of
Core Maude this facility is not supported, there is a new figure that allows
us to overcome this lack: 
\end{comment}
But we do not need to give the complete metarepresentation of such a
module. As we saw in Section~\ref{bubbles}, in modules including
\texttt{META-LEVEL} it is possible to define terms of sort \texttt{Module}
that import built-in modules or any module introduced at the ``object level''
of Core Maude. In this way, it is possible to get the equivalent effect of
having the explicit metarepresentation of a module by declaring a
constant and adding an equation identifying such a constant with the
metarepresentation of an extended module that imports the original module at
the object level.

\begin{comment}
\footnote{Note that since Full Maude is implemented in Core Maude, their
object levels are different. It would be desirable to further integrate Core
Maude and Full Maude so that we could consider them as facets of the same
system. In Maude 1.00 Core Maude and Full Maude maintain separate
databases. Full Maude only knows about the predefined modules, and this is why
it can leave their importations unevaluated. As further discussed in
Section~\ref{databaseADT}, we plan to move towards a closer integration of
Core Maude and Full Maude in future releases.}
\end{comment}

As also mentioned in Section~\ref{bubbles}, the declaration of constructors
for bubble sorts at the object level is not supported in the current version
of Core Maude. The \texttt{special} attributes linking the constructors for
the bubble sorts to the built-in ones are only supported at the metalevel,
that is, the declarations of the constructor operators for bubble sorts have
to be given in the metarepresentation of a module.

To allow the greatest generality and flexibility in future extensions of Full
Maude, we have declared its signature as a module
\texttt{PRE-FULL-MAUDE-SIGN}\ (see Appendix~\ref{signature-full-maude}). Then, in
the following module \texttt{META-PRE-FULL-MAUDE-SIGN} we declare a constant
\texttt{GRAMMAR} of sort \texttt{FModule}, and using the technique described
in Section~\ref{bubbles} to import the metarepresentation of a module by name,
we give an equation identifying such constant with the metarepresentation of a
module \texttt{GRAMMAR} in which there is a declaration importing
\texttt{PRE-FULL-MAUDE-SIGN}. Declarations for the constructors of the bubble
sorts are also included in this module. Note that the bubble sorts
\texttt{Token}, \texttt{Bubble}, \texttt{ViewToken}, \texttt{SortToken}, and
\texttt{NeTokenList} are declared in the module \texttt{SIGN\&VIEW-EXPR},
which is imported by \texttt{PRE-FULL-MAUDE-SIGN}. These sorts are used in the
declarations describing the syntax of the system.  

\small
\begin{verbatim}
%)

fmod META-PRE-FULL-MAUDE-SIGN is
  including META-LEVEL .

  op GRAMMAR : -> FModule .

  eq GRAMMAR 
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        including 'PRE-FULL-MAUDE-SIGN .
        sorts none .
        none
        op 'token : 'Qid -> 'Token 
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidBaseSymbol, '<Qids>, nil, 'Qid)))] .
        op 'viewToken : 'Qid -> 'ViewToken 
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidBaseSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'assoc 'associative 'comm 
                                  'commutative 'idem 'idempotent
                                  'memo 'memoization 'ctor 'constructor)))] .
        op 'sortToken : 'Qid -> 'SortToken 
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidBaseSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '`[ '`] '< 'to ': '`, '. '`( '`))))] .
        op 'neTokenList : 'QidList -> 'NeTokenList 
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidBaseSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '.)))] .
        op 'bubble : 'QidList -> 'Bubble 
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidBaseSymbol, '<Qids>, nil, 'Qid)))] .
        none
        none
        none
     endfm) .
endfm

***(%
\end{verbatim}
\normalsize

The \texttt{GRAMMAR} module will be used in calls to the \texttt{meta-parse}
function in order to get the input parsed in this signature. Note that this
module is not the data type in which we shall represent the inputs. From the
call to \texttt{meta-parse} we shall get a term representing the parse tree of
the input. This term will then be transformed into terms of other appropriate
data types if necessary.

Future extensions to Full Maude will require extending the signature as
well. The addition of new commands, new module expressions, or additions of
any other kind will require adding new declarations to the present Full Maude
signature and defining the corresponding extensions to the data types and
functions to deal with the new cases introduced by the extensions. We shall
see in Section~\ref{extension} how the system can be easily extended to handle
some new module expressions in addition to the renaming and instantiation
module expressions presented in Section~\ref{module-expressions} and further
discussed in Sections~\ref{renaming} and~\ref{instantiation}. In
Chapter~\ref{crc} we shall explain how to combine a proving tool like a
Church-Rosser
checker~\cite{ClavelDuranEkerMeseguer98a,ClavelDuranEkerMeseguer98} with Full
Maude. 

\section{The Abstract Data Type \texttt{Unit}}
\label{sec:unitADT}

In this section we present the abstract data type \texttt{Unit}, which can be
seen as an extension of the predefined sort \texttt{Module} in several
ways. There are constructors for functional, system, and object-oriented
modules and theories, which can be parameterized and can import module
expressions. There can also be parameterized sorts in Full Maude modules, and
therefore, the constructors for the different declarations that can appear in
a module have to be appropriately extended.

The section is structured as follows. After introducing some modules defining
some functions on the predefined sorts \texttt{Bool} and \texttt{QidList} in
Section~\ref{BOOL-QID-LIST}, we present in Sections~\ref{EXT-SORT}
and~\ref{EXT-DECL} the data types for extended sorts and extended
declarations. In Section~\ref{mod-exp-mod-id} we introduce module expressions
and module names, and in Section~\ref{unitADT} the abstract data type
\texttt{Unit} itself.

\subsection{Extensions to \texttt{BOOL} and \texttt{QID-LIST}}
\label{BOOL-QID-LIST}

The module \texttt{EXT-BOOL} extends the predefined \texttt{BOOL} module with
operations \verb~_and-then_~ and \verb~_or-else_~. The semantics of
\verb~_and-then_~ and \verb~_or-else_~ are, respectively, as the semantics of
the boolean operators \verb~_and_~ and \verb~_or_~, but they are not declared
to be associative, and their second arguments are evaluated lazily thanks to
the evaluation strategy \verb~(1 0 2 0)~
(see~\cite{OBJ92,Eker98,ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada99}
for more on evaluation strategies).

\small
\begin{verbatim}
%)

fmod EXT-BOOL is
  pr BOOL .

  op _and-then_ : Bool Bool -> Bool [strat (1 0 2 0) prec 55] .
  op _or-else_ : Bool Bool -> Bool [strat (1 0 2 0) prec 59] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var B : Bool .

  eq true and-then B = B .
  eq false and-then B = false .
  eq true or-else B = true .
  eq false or-else B = B .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

The conversion of lists of quoted identifiers into single quoted identifiers
by concatenating them is heavily used in the coming modules. This is the task
of the \texttt{qidListToQid} function, which is introduced in the following
module \texttt{EXT-QID-LIST} extending the predefined module
\texttt{QID-LIST}.

\small
\begin{verbatim}
%)

fmod EXT-QID-LIST is
  pr QID-LIST .

  op qidListToQid : QidList -> Qid .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var QI : Qid .
  var QIL : QidList .

  eq qidListToQid((QI QIL)) = conc(QI, qidListToQid(QIL)) .
  eq qidListToQid(nil) = ' .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

\subsection{View Expressions and Extended Sorts}
\label{extended-sorts}

To allow the use of parameterized sorts, or sorts qualified by the view
expression with which the parameterized module in which the given sorts appear
is instantiated (see Section~\ref{parameterized-modules}), we add the sort
\texttt{ESort} of ``extended sorts'' as a supersort of the predefined sort
\texttt{Sort}.  View expressions and extended sorts are introduced in the
following modules.

\subsubsection{View Expressions}
\label{VIEW-EXPR}

A view expression is given by a single quoted identifier, by a sequence of
view expressions (at the user level, separated by commas), or by the
composition of view expressions. In the current version, the composition of
view expressions is only used internally; we plan to make it available to the
user with syntax \verb~_;_~ in the future. View expressions are used in the
instantiation of parameterized modules and in parameterized sorts.  We plan to
support parameterized views in the future as well. We use operators \verb~_|_~
and \verb~_;;_~ to represent, respectively, sequences and composition of view
expressions.

\begin{comment}
\footnote{We use operators \texttt{\_\,|\_\,} and
\texttt{\_\,;;\_\,} to satisfy the preregularity condition. Note that
operators \texttt{\_\,,\_\,} and \texttt{\_\,;\_\,} have been declared in the
predefined module \texttt{META-LEVEL} as constructors for sorts
\texttt{TermList} and \texttt{QidSet}, respectively.}.
\end{comment}

The \texttt{VIEW-EXPR} module below also includes declarations for sets of
view expressions, which will be used in the database
structure to hold the list of the names of the views in it.  The elements of
sort \texttt{ViewExpSet}, for sets of view expressions, are given using the
constructor \verb~_#_~, which is declared to be associative, commutative, and
with identity element \texttt{noneViewExpSet}. 

The function \verb~_inViewExpSet_~ checks whether the view expression given as
first argument is in the set of view expressions given as second argument or
not.

\small
\begin{verbatim}
%)

fmod VIEW-EXPR is
  pr EXT-BOOL .
  pr QID .

  sort ViewExp .
  subsort Qid < ViewExp .
  op nullViewExp : -> ViewExp .
  op _|_ : ViewExp ViewExp -> ViewExp [assoc id: nullViewExp] .
  op _;;_ : ViewExp ViewExp -> ViewExp [assoc] .

  sort ViewExpSet .
  subsort ViewExp < ViewExpSet .
  op noneViewExpSet : -> ViewExpSet .
  op _#_ : ViewExpSet ViewExpSet -> ViewExpSet 
        [assoc comm id: noneViewExpSet] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  vars VE VE' : ViewExp .
  vars VES : ViewExpSet .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op _inViewExpSet_ : ViewExp ViewExpSet -> Bool .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq VE inViewExpSet (VE' # VES)
    = (VE == VE') or-else (VE inViewExpSet VES) .
  eq VE inViewExpSet noneViewExpSet = false .

***(%
\end{verbatim}
\normalsize

\end{comment}

  \texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

Since the Core Maude engine does not know about view expressions, or, as we
shall see, about extended sorts, extended module expressions, extended
modules, and other declarations that we introduce, to be able to use them with
built-in functions such as \texttt{sameComponent}, \texttt{leastSort},
\texttt{meta-reduce}, etc., we shall have to convert them into terms which
only use the built-in constructors.  Thus, for example, view expressions in
sort \texttt{ViewExp} will be converted into quoted identifiers of sort
\texttt{Qid} by means of function \texttt{viewExpToQid}, or, similarly,
elements of sorts \texttt{ESort}, \texttt{ESortList}, and \texttt{ESortSet}
are transformed into elements of sorts \texttt{Qid}, \texttt{QidList}, and
\texttt{QidSet}, respectively, with functions \texttt{eSortToQid} defined on
the appropriate sorts.

\small
\begin{verbatim}
%)

fmod VIEW-EXPR-TO-QID is
  pr VIEW-EXPR .
  pr EXT-QID-LIST .

  op viewExpToQid : ViewExp -> Qid .
  op viewExpToQidList : ViewExp -> QidList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var QI : Qid .
  vars VE VE' : ViewExp .

  eq viewExpToQidList(QI) = QI .
  eq viewExpToQidList(_;;_(VE, VE'))
    = (viewExpToQidList(VE) '; viewExpToQidList(VE')) .
  ceq viewExpToQidList(_|_(VE, VE'))
    = (viewExpToQidList(VE) '`, viewExpToQidList(VE'))
      if (VE =/= nullViewExp) and (VE' =/= nullViewExp) .

  eq viewExpToQid(VE) = qidListToQid(viewExpToQidList(VE)) .

***(%
\end{verbatim}
\normalsize

\end{comment}

  \texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsubsection{Parameterized Sorts}
\label{EXT-SORT}

In addition to the \texttt{ESort} sort, in the following module
\texttt{EXT-SORT} we also define sorts \texttt{ESortList} and
\texttt{ESortSet}.
\begin{comment}
plus some auxiliary functions on them. 
\end{comment}

The operator \texttt{eSort} is declared to be a constructor for extended
sorts.

\begin{comment}
\footnote{Since the operator \texttt{\_\,[\_\,]} is declared as a
constructor for sort \texttt{Term} in module \texttt{META-LEVEL}, we use the
operator name \texttt{eSort} for extended sorts to satisfy the preregularity
condition.}.
\end{comment}

As for lists and sets of quoted identifiers,
we declare \verb~__~ and \verb~_;_~ as constructors for sorts
\texttt{SortList} and \texttt{ESortList}, and \texttt{ESortSet},
respectively.

\small
\begin{verbatim}
%)

fmod EXT-SORT is
  pr META-LEVEL .
  pr VIEW-EXPR-TO-QID .

  sort ESort .
  subsort Sort < ESort .
  op eSort : ESort ViewExp -> ESort .

  sort SortList .
  subsort SortList ESort < ESortList .
  op __ : SortList SortList -> SortList [assoc id: nil] .

  sort ESortList .
  subsort QidList Sort < SortList .
  op __ : ESortList ESortList -> ESortList [assoc id: nil] .

  sort ESortSet .
  subsort QidSet ESort < ESortSet .
  op _;_ : ESortSet ESortSet -> ESortSet [assoc comm id: none] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

We declare operations extending the built-in functions \texttt{sameComponent}
and \texttt{leastSort} to lists of extended sorts (\texttt{eSameComponent})
and to lists of terms (\texttt{termListLeastSort}), respectively. The function
\texttt{eSameComponent} takes a module and two lists of extended sorts as
arguments, and returns \texttt{true} if the $i$-th elements of both lists are
in the same connected component of sorts. This function will be used, for
example, to check whether two operators are in the same family of subsort
overloaded operators. \texttt{leastSort} returns a list of sorts where the
$i$-th element of the list is the least sort, computed by the homonymous
built-in function, of the $i$-th term in the list of terms given as
argument. Moreover, we define a function \verb~_inSortSet_~ to check whether
an extended sort is in a given set of extended sorts.  Note that before
calling the built-in function \texttt{sameComponent}, extended sorts of sort
\texttt{ESort} have to be `desugared' into sorts of sort \texttt{Sort} as
defined in the predefined \texttt{META-LEVEL} module. This conversion is done
by the \texttt{eSortToSort} function. Basically, user-defined sorts are
converted into quoted identifiers by concatenating the list of identifiers
composing the name of the sort. For example, sorts \texttt{'Nat} and
\texttt{'List['Nat]} are converted, respectively, into \texttt{'Nat} and
\texttt{'List`[Nat`]}. Error
sorts~\cite{ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada99} are left as
such.

\small
\begin{verbatim}
%)

  var QI : Qid .
  var SS : QidSet .
  vars ES ES' : ESort .
  vars ESS ESS' : ESortSet .
  vars ESL ESL' : ESortList .
  var VE : ViewExp .
  var M : Module .
  var T : Term .
  var TL : TermList .

  op eSortToSort : ESort -> Sort .

  eq eSortToSort(QI) = QI .
  eq eSortToSort(errorSort(SS)) = errorSort(SS) .
  eq eSortToSort(eSort(ES, VE))
    = conc(eSortToSort(ES), conc('`[, conc(viewExpToQid(VE), '`]))) .

  op eSameComponent : Module ESortList ESortList -> Bool .

  eq eSameComponent(M, (ES ESL), (ES' ESL'))
    = sameComponent(M, eSortToSort(ES), eSortToSort(ES')) 
      and-then eSameComponent(M, ESL, ESL')  .
  eq eSameComponent(M, (ES ESL), nil) = false .
  eq eSameComponent(M, nil, (ES ESL)) = false .
  eq eSameComponent(M, nil, nil) = true .

  op termListLeastSort : Module TermList -> SortList .

  eq termListLeastSort(M, (T, TL))
    = (leastSort(M, T) termListLeastSort(M, TL)) .
  eq termListLeastSort(M, T) = leastSort(M, T) .

  op _inSortSet_ : ESort ESortSet -> Bool .

  eq ES inSortSet (ES ; ESS) = true .
  eq ES inSortSet (ES' ; ESS)
    = (ES == ES') or-else (ES inSortSet ESS) .
  eq ES inSortSet none = false .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

\subsubsection{Transforming Extended Sorts into Quoted Identifiers}

Since eventually all units will have to be given as arguments in some
of the calls to the built-in functions, and since the engine does not
know about parameterized sorts, we need to transform all parameterized
sorts appearing in any of the declarations that can appear in a unit
into quoted identifiers. This is the task of the \texttt{eSortToQid}
function, which is defined in the module
\texttt{EXT-SORT-TO-QID}. These functions will be used with terms not
containing error sorts\footnote{The Core Maude system automatically
adds error supersorts above each of the connected components of the
poset of sorts declared by the user, using the set of maximal sorts in
each connected component to qualify the corresponding error sort. Such
error sorts are called {\em kinds} in the theory of membership
algebras~\cite{Meseguer98,BouhoulaJouannaudMeseguer97a}.}. Although
the user cannot use error sorts, calls to built-in functions may
generate such error sorts, and some built-in functions can handle
them. The function \texttt{eSortToSort} presented in the previous
module will be used in the calls to the built-in functions that may
use such error sorts.

\small
\begin{verbatim}
%)

fmod EXT-SORT-TO-QID is
  pr EXT-SORT .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op eSortToQidList : ESort -> QidList .
  op eSortToQidList : ESortList -> QidList .
  op eSortToQidList : ESortSet -> QidList .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op eSortToQid : ESort -> Qid .
  op eSortToQid : ESortSet -> QidSet .
  op eSortToQid : ESortList -> QidList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var QI : Qid .
  var SS : QidSet .
  var VE : ViewExp .
  var ES : ESort .
  var ESL : ESortList .
  var ESS : ESortSet .

  eq eSortToQidList(QI) = QI .
  eq eSortToQidList(errorSort(SS))
    = ('Error '`( eSortToQidList(SS) '`)) .
  eq eSortToQidList(eSort(ES, VE))
    = (eSortToQidList(ES) '`[ viewExpToQidList(VE) '`]) .

  ceq eSortToQidList((ES ESL))
    = (eSortToQidList(ES) eSortToQidList(ESL)) 
      if ESL =/= nil .
  eq eSortToQidList(nil) = nil .

  ceq eSortToQidList((ES ; ESS))
    = (eSortToQidList(ES) '; eSortToQidList(ESS)) 
      if ESS =/= none .
  eq eSortToQidList((none).ESortSet) = nil .

  eq eSortToQid(ES) = qidListToQid(eSortToQidList(ES)) .

  ceq eSortToQid((ES ESL))
    = (eSortToQid(ES) eSortToQid(ESL)) 
      if ESL =/= nil .
  eq eSortToQid(nil) = nil .

  ceq eSortToQid((ES ; ESS))
    = (eSortToQid(ES) ; eSortToQid(ESS)) 
      if ESS =/= none .
  eq eSortToQid((none).ESortSet) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Extended Declarations}
\label{EXT-DECL}

In this section we discuss modules \texttt{EXT-DECL} and \texttt{O-O-DECL}
which introduce, respectively, the declarations extending the sorts and
constructors for declarations of the predefined data type \texttt{Module} in
the \texttt{META-LEVEL} module to allow the use of extended sorts in them, and
the declarations appearing in object-oriented units, namely class
declarations, subclass relation declarations, and message declarations.

\subsubsection{Declarations of Functional and System Units}

In the following module \texttt{EXT-DECL}, we introduce the declarations
extending those in \texttt{META-LEVEL} to allow the use of extended sorts in
declarations of sorts, subsort relations, operators, variables, and membership
axioms.
\begin{comment}
\footnote{In the future, the declarations for operators, membership
axioms, equations, and rules will be extended to allow the use of extended
sorts in sort tests, that is, terms of the form \mbox{\verb~T : ES~} and
\mbox{\verb~T :: ES~}.}
\end{comment}
The extension is accomplished by adding new
supersorts for each of the sorts in \texttt{META-LEVEL} involved, and by
adding new constructors for these new sorts.

We start introducing the declarations for the supersorts and their
corresponding constructors. The \texttt{EXT-DECL} module also contains the
declarations for sets of such declarations.

\small
\begin{verbatim}
%)

fmod EXT-DECL is
  pr EXT-SORT .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var ES ES' : ESort .
  var ESS  : ESortSet .
  var EOD' : EOpDecl .
  var EVDS' : EVarDeclSet .
  var VE : ViewExp .
  vars S F V V' : Qid .
  var TL : TermList .
  var T : Term .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  sort ESortDecl .
  subsort SortDecl < ESortDecl .
  op sorts_. : ESortSet -> ESortDecl .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq (sorts ES ; ES ; ESS .) = (sorts ES ; ESS .) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  sorts ESubsortDecl ESubsortDeclSet .
  subsort SubsortDecl < ESubsortDecl .
  subsorts SubsortDeclSet ESubsortDecl < ESubsortDeclSet .
  op subsort_<_. : ESort ESort -> ESubsortDecl .
  op __ : ESubsortDeclSet ESubsortDeclSet -> ESubsortDeclSet
        [comm assoc id: none] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var ESSD : ESubsortDecl .
  var ESSDS : ESubsortDeclSet .
  eq ESSD ESSD ESSDS = ESSD ESSDS .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  sorts EOpDecl EOpDeclSet .
  subsort OpDecl < EOpDecl .
  subsorts OpDeclSet EOpDecl < EOpDeclSet .
  op op_:_->_[_]. : Qid ESortList ESort AttrSet -> EOpDecl .
  op __ : EOpDeclSet EOpDeclSet -> EOpDeclSet 
        [assoc comm id: none] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var EOD : EOpDecl .
  var EODS : EOpDeclSet .
  eq EOD EOD EODS = EOD EODS .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  sorts EVarDecl EVarDeclSet .
  subsort VarDecl < EVarDecl .
  subsorts VarDeclSet EVarDecl < EVarDeclSet .
  op var_:_. : Qid ESort -> EVarDecl .
  op __ : EVarDeclSet EVarDeclSet -> EVarDeclSet 
        [assoc comm id: none] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var EVD : EVarDecl .
  var EVDS : EVarDeclSet .
  eq EVD EVD EVDS = EVD EVDS .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  sorts EMembAx EMembAxSet .
  subsort MembAx < EMembAx .
  subsorts EMembAx MembAxSet < EMembAxSet .
  op mb_:_. : Term ESort -> EMembAx .
  op cmb_:_if_=_. : Term ESort Term Term -> EMembAx .
  op __ : EMembAxSet EMembAxSet -> EMembAxSet
        [assoc comm id: none] .

***(%
\end{verbatim}
\normalsize

The \texttt{sortSet} function returns the set of sorts from a declaration of
sorts.

\small
\begin{verbatim}
%)

  op sortSet : ESortDecl -> ESortSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq sortSet(sorts ESS .) = ESS .

***(%
\end{verbatim}
\normalsize

The function \verb~_in_~ checks whether a given operator declaration is in
a set of operator declarations.

\small
\begin{verbatim}
%)

  op _in_ : EOpDecl EOpDeclSet -> Bool .

  eq EOD in (EOD EODS) = true .
  eq EOD in (EOD' EODS) = (EOD == EOD') or-else (EOD in EODS) .
  eq EOD in none = false .

***(%
\end{verbatim}
\normalsize

\end{comment}

There are also some other functions to deal with variables.
The function \texttt{varDeclSetInTerm} returns the set of the variable
declarations in the given module for those variables that appear in the
term given as second argument.
The function \texttt{varDeclSetDiff} computes the set-theoretic difference
between the two sets of variables given as arguments. Note that the difference
is not between the declarations themselves, but just between the names of the
variables in the declarations; the sorts with which they are declared are not
taken into consideration.

\begin{comment}

The predicate \texttt{varInVarDeclSet} checks whether there is a variable
with the name given as first argument in the set of variable declarations
given as second argument.

\small
\begin{verbatim}
%)

  op varInVarDeclSet : Qid EVarDeclSet -> Bool .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq varInVarDeclSet(V, ((var V : ES .) EVDS)) = true .
  eq varInVarDeclSet(V, ((var V' : ES .) EVDS)) 
    = (V == V') or-else varInVarDeclSet(V, EVDS) .
  eq varInVarDeclSet(V, none) = false .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op varDeclSetInTerm : EVarDeclSet Term -> EVarDeclSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op varDeclSetInTerm : EVarDeclSet TermList -> EVarDeclSet .

  eq varDeclSetInTerm(EVDS, error*) = none .
  eq varDeclSetInTerm(EVDS, {F}S) = none .
  eq varDeclSetInTerm(((var V : ES .) EVDS), V) = (var V : ES .) .
  eq varDeclSetInTerm(EVDS, F[TL]) = varDeclSetInTerm(EVDS, TL) .
  eq varDeclSetInTerm(EVDS, T : ES) = varDeclSetInTerm(EVDS, T) .
  eq varDeclSetInTerm(EVDS, T :: ES) = varDeclSetInTerm(EVDS, T) .
  eq varDeclSetInTerm(EVDS, (T, TL))
    = (varDeclSetInTerm(EVDS, T) varDeclSetInTerm(EVDS, TL)) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op varDeclSetDiff : EVarDeclSet EVarDeclSet -> EVarDeclSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  ceq varDeclSetDiff(((var V : ES .) EVDS), EVDS')
    = varDeclSetDiff(EVDS, EVDS')
      if varInVarDeclSet(V, EVDS') .
  ceq varDeclSetDiff(((var V : ES .) EVDS), EVDS')
    = ((var V : ES .) varDeclSetDiff(EVDS, EVDS'))
      if not varInVarDeclSet(V, EVDS') .
  eq varDeclSetDiff(none, EVDS) = none .
  eq varDeclSetDiff(EVDS, none) = EVDS .

***(%
\end{verbatim}
\normalsize

The function \texttt{isThereVbleOfSort} checks whether there is a variable in
the set of variables given as first argument declared of the sort given as
second argument. Note that it returns just a Boolean value.

\small
\begin{verbatim}
%)

  op isThereVbleOfSort : EVarDeclSet ESort -> Bool .

  eq isThereVbleOfSort(((var V : ES .) EVDS), ES')
    = (ES == ES') or-else isThereVbleOfSort(EVDS, ES') .
  eq isThereVbleOfSort(none, ES) = false .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

\subsubsection{Declarations for Object-Oriented Units}

In the \texttt{O-O-DECL} module we introduce the sorts and constructors for
declarations of classes, subclass relations, and messages in object-oriented
units.

Note that we follow the same naming conventions for classes as for extended
sorts (see Section~\ref{parameterized-modules}), and therefore we use the sort
\texttt{ESort} for class identifiers, and \texttt{ESortList} and
\texttt{ESortSet} for lists and sets of class identifiers, respectively.  We
use the operator \verb~attr_:_~ as a constructor for declarations of
attributes.
\begin{comment}
\footnote{Since the operator name \texttt{\_\,:\_\,} is used for
sort tests in the \texttt{META-LEVEL} module, we use \texttt{attr\_\,:\_\,} as
constructor for declarations of attributes to satisfy the preregularity
condition.}.
\end{comment}

\small
\begin{verbatim}
%)

fmod O-O-DECL is
  pr EXT-SORT .

  sorts AttrDecl AttrDeclSet . 
  subsort AttrDecl < AttrDeclSet .
  op attr_:_ : Qid ESort -> AttrDecl .
  op none : -> AttrDeclSet .
  op _,_ : AttrDeclSet AttrDeclSet -> AttrDeclSet 
        [assoc comm id: none] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var AD : AttrDecl .
  var ADS : AttrDeclSet .
  eq AD, AD, ADS = AD, ADS .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  sorts ClassDecl ClassDeclSet . 
  subsort ClassDecl < ClassDeclSet .
  op class_|_. : ESort AttrDeclSet -> ClassDecl .
  op none : -> ClassDeclSet .
  op __ : ClassDeclSet ClassDeclSet -> ClassDeclSet 
        [assoc comm id: none] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var CD : ClassDecl .
  var CDS : ClassDeclSet .
  eq CD CD CDS = CD CDS .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  sorts SubclassDecl SubclassDeclSet . 
  subsort SubclassDecl < SubclassDeclSet .
  op subclass_<_. : ESort ESort -> SubclassDecl .
  op none : -> SubclassDeclSet .
  op __ : SubclassDeclSet SubclassDeclSet -> SubclassDeclSet 
         [assoc comm id: none] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq SCD SCD SCDS = SCD SCDS .
  var SCD : SubclassDecl .
  var SCDS : SubclassDecl .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  sorts MsgDecl MsgDeclSet . 
  subsort MsgDecl < MsgDeclSet .
  op msg_:_->_. : Qid ESortList ESort -> MsgDecl .
  op none : -> MsgDeclSet .
  op __ : MsgDeclSet MsgDeclSet -> MsgDeclSet 
        [assoc comm id: none] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var MD : MsgDecl .
  var MDS : MsgDeclSet .
  eq MD MD MDS = MD MDS .

  var ES : ESort .

***(%
\end{verbatim}
\normalsize

The function \texttt{classSet} returns the set of class identifiers in the set
of class declarations given as argument.

\small
\begin{verbatim}
%)

  op classSet : ClassDeclSet -> ESortSet .

  eq classSet((class ES | ADS .) CDS) = (ES ; classSet(CDS)) .
  eq classSet(none) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsubsection{`Desugaring' of Extended Sorts in Declarations}

In the following module we define the \texttt{eSortToQid} function on the
sorts for the different declarations introduced in the previous modules.

\small
\begin{verbatim}
%)

fmod DECL-EXT-SORT-TO-QID is
  pr EXT-SORT-TO-QID .
  pr EXT-DECL .
  pr O-O-DECL .

  op eSortToQid : ESubsortDeclSet -> SubsortDeclSet .
  op eSortToQid : EOpDeclSet -> OpDeclSet .
  op eSortToQid : EVarDeclSet -> VarDeclSet .
  op eSortToQid : EMembAxSet -> MembAxSet .
  op eSortToQid : ClassDeclSet -> ClassDeclSet .
  op eSortToQid : SubclassDeclSet -> SubclassDeclSet .
  op eSortToQid : MsgDeclSet -> MsgDeclSet .
  op eSortToQid : AttrDeclSet -> AttrDeclSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  vars QI F V : Qid .
  var SS : QidSet .
  vars VE VE' : ViewExp .
  vars ES ES' : ESort .
  var ESL : ESortList .
  var ESS : ESortSet .
  vars T T' T'' T''' : Term .
  var ESSDS : ESubsortDeclSet .
  var EODS : EOpDeclSet .
  var AtS : AttrSet .
  var EVDS : EVarDeclSet .
  var EMAS : EMembAxSet .
  var CDS : ClassDeclSet .
  var ADS : AttrDeclSet .
  var MDS : MsgDeclSet .
  var SCDS : SubclassDeclSet .

  eq eSortToQid(((subsort ES < ES' .) ESSDS))
    = ((subsort eSortToQid(ES) < eSortToQid(ES') .)
       eSortToQid(ESSDS)) .
  eq eSortToQid((none).ESubsortDeclSet) = none .

  eq eSortToQid(((op F : ESL -> ES [AtS] .) EODS))
    = ((op F : eSortToQid(ESL) -> eSortToQid(ES) [AtS] .)
       eSortToQid(EODS)) .
  eq eSortToQid((none).EOpDeclSet) = none .

  eq eSortToQid(((var V : ES .) EVDS))
    = ((var V : eSortToQid(ES) .) eSortToQid(EVDS)) .
  eq eSortToQid((none).EVarDeclSet) = none .

  eq eSortToQid(((mb T : ES .) EMAS))
    = ((mb T : eSortToQid(ES) .) eSortToQid(EMAS)) .
  eq eSortToQid(((cmb T : ES if T' = T'' .) EMAS))
    = ((cmb T : eSortToQid(ES) if T' = T'' .) eSortToQid(EMAS)) .
  eq eSortToQid((none).EMembAxSet) = none .

  eq eSortToQid(((class ES | ADS .) CDS))
    = ((class eSortToQid(ES) | eSortToQid(ADS) .) eSortToQid(CDS)) .
  eq eSortToQid((none).ClassDeclSet) = none .

  eq eSortToQid(((attr F : ES), ADS))
    = ((attr F : eSortToQid(ES)), eSortToQid(ADS)) .
  eq eSortToQid((none).AttrDeclSet) = none .

  eq eSortToQid(((subclass ES < ES' .) SCDS))
    = ((subclass eSortToQid(ES) < eSortToQid(ES') .) eSortToQid(SCDS)) .
  eq eSortToQid((none).SubclassDeclSet) = none .

  eq eSortToQid(((msg F : ESL -> ES .) MDS))
    = ((msg F : eSortToQid(ESL) -> eSortToQid(ES) .) eSortToQid(MDS)) .
  eq eSortToQid((none).MsgDeclSet) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Module Expressions and Module Names}
\label{mod-exp-mod-id}

The abstract syntax for writing specifications in Maude can be seen as given
by module expressions, where the notion of module expression is understood as
an expression that defines a new module out of previously defined modules by
combining and/or modifying them according to a specific set of operations.
All module expressions will be evaluated generating modules with such module
expressions as names. In the case of parameterized modules, each of the
parameters in an interface will be used as the name of a new module created
as a renamed copy of the parameter theory.

\subsubsection{Module Expressions}

In the following \texttt{MOD-EXPR} module the sort \texttt{ModExp} is
introduced as a supersort of \texttt{Qid}. Module expressions for
module renaming and for module instantiation will be introduced,
respectively, in the modules \texttt{RENAMING-EXPR} and \texttt{INST-EXPR},
in Sections~\ref{renaming} and~\ref{instantiation}, which will be
defined as extensions of \texttt{MOD-EXPR}. We shall see in
Section~\ref{extension} how new module combining and/or transforming
operators can be easily added, showing the flexibility and
extensibility of the module algebra being defined.

%\marginnote{What is going to happen with the predefined ModuleExpression
%sort?}

\small
\begin{verbatim}
%)

fmod MOD-EXPR is
  pr QID .

  sort ModExp .
  subsort Qid < ModExp .

endfm

***(%
\end{verbatim}
\normalsize

\subsubsection{Module Names}
\label{module-names}

As we shall see in the coming sections, the evaluation of module expressions
may produce the creation of new modules, whose \emph{names} are given by the
module expressions themselves. If there is already a module in the database
with the module expression being evaluated as name, the evaluation of such
module expression does not produce any change in the database. However,
the evaluation of a module expression may involve the evaluation of some
other module expressions contained in the modules involved, which in turn may
generate new modules.

Given a parameterized module 
$\texttt{N[L}_1\texttt{\ ::\ T}_1\texttt{,\ }
           \ldots\texttt{,\ L}_n\texttt{\ ::\ T}_n\texttt{]}$, with 
$\texttt{L}_1\ldots\texttt{L}_n$ labels and $\texttt{T}_1\ldots\texttt{T}_n$
theory identifiers, we say that \texttt{N} is the name of the module and that
$\texttt{[L}_1\texttt{\ ::\ T}_1\texttt{,\ }
           \ldots\texttt{,\ L}_n\texttt{\ ::\ T}_n\texttt{]}$
is its \emph{interface}. As we shall see in Sections~\ref{instantiation}
and~\ref{unit-processing}, for each parameter $\texttt{L}_i\texttt{\ ::\ T}_i$
in the interface of a module, a new module is generated with such a parameter
expression as its name, and a declaration importing it in the parameterized
module is added.  We regard the relationship between the body of a
parameterized module and the parameters in its interface, not as an inclusion,
but as mediated by a module constructor that generates renamed copies of the
parameters, which are then included. Therefore, the sort \texttt{Parameter} is
declared as a subsort of \texttt{ModName}, that is, terms of sort
\texttt{Parameter} are considered to be module names. The constructor operator
for the sort \texttt{Parameter} is \verb~par_::_~.
\begin{comment}
\footnote{Since the operator name
\texttt{\_\,::\_\,} is used for lazy sort tests in the \texttt{META-LEVEL}
module, we use \texttt{par\_\,::\_\,} for the declaration of parameters to
satisfy the preregularity condition.}.
\end{comment}

The \texttt{MOD-NAME} module also includes a sort \texttt{ModNameSet}, for sets
of module names. The constructors of sort \texttt{ModNameSet} are
\texttt{noneModNameSet} and \verb~_&_~.
The function \verb~_inModNameSet_~ checks whether the module name given as
first argument is in the set of module names given as second argument.


\small
\begin{verbatim}
%)

fmod MOD-NAME is
  pr MOD-EXPR .
  pr EXT-BOOL .

  sort Parameter .
  op par_::_ : Qid ModExp -> Parameter .    

  sorts ModName ModNameSet .
  subsorts Parameter ModExp < ModName < ModNameSet .
  op noneModNameSet : -> ModNameSet .
  op _&_ : ModNameSet ModNameSet -> ModNameSet 
        [assoc comm id: noneModNameSet] .
  op nullModName : -> ModName .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  vars MN MN' : ModName .
  var MNS : ModNameSet .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op _inModNameSet_ : ModName ModNameSet -> Bool .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq MN inModNameSet (MN' & MNS)
    = (MN == MN') or-else (MN inModNameSet MNS) .
  eq MN inModNameSet noneModNameSet = false .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

Since the Core Maude engine assumes that module names are identifiers and does
not know about term-structured module names (such as parameterized module
interfaces or module expressions), for evaluation purposes we need to
transform them into quoted identifiers. The functions \texttt{modNameToQid}
and \texttt{modNameToQidList} in the module \texttt{MOD-NAME-TO-QID} below
accomplish this transformation. In any language extensions, new equations for
the function \texttt{modNameToQidList} should be added for each new module
expression constructor introduced. In Sections~\ref{renaming}
and~\ref{instantiation} we shall see how the corresponding equalities are
added for renaming and instantiation expressions, and in
Section~\ref{extension} for other new module expressions in extensions of Full
Maude.

\small
\begin{verbatim}
%)

fmod MOD-NAME-TO-QID is
  pr MOD-NAME .
  pr EXT-QID-LIST .

  op modNameToQid : ModName -> Qid .
  op modNameToQidList : ModName -> QidList .

  vars QI X : Qid .
  var ME : ModExp .
  var MN : ModName .

  eq modNameToQidList(QI) = QI .
  eq modNameToQidList(par X :: ME) 
    = (X ':: modNameToQidList(ME)) .
  eq modNameToQidList(nullModName) = ' .

  eq modNameToQid(MN) 
    = qidListToQid(modNameToQidList(MN)) .

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Units}
\label{unitADT}

We handle six different types of units: functional, system, and
object-oriented modules, and functional, system, and object-oriented theories.
Modules and theories of any kind are considered to be elements in specific
subsorts of the sort \texttt{Unit}. A constructor \texttt{unitError} is also
included to represent incorrect units. \texttt{unitError} has a list of quoted
identifiers as argument, which is used to report the error. Besides
considering functional and system theories and object-oriented theories and
modules, the declarations presented in the following module extend the
declarations for sort \texttt{Module} in the \texttt{META-LEVEL} module in
three different ways:
\begin{itemize}
\item
the name of a module can be any term of sort \texttt{ModName},
\item
parameterized modules are handled, for which a list of parameters is added
to the constructors of modules,
\item
the importation declaration is extended to module names, and
\item
parameterized sorts are supported.
\end{itemize}

\small
\begin{verbatim}
%)

fmod UNIT is
  pr EXT-DECL .
  pr O-O-DECL .
  pr MOD-NAME-TO-QID .
  inc META-LEVEL .

***(%
\end{verbatim}
\normalsize

We start by introducing declarations for sorts \texttt{EImport} and
\texttt{EImportList}, which are declared as supersorts of \texttt{Import} and
\texttt{ImportList}, respectively. We declare the constructor
\verb~including_.~ for importation declarations on module names. We shall see
in Section~\ref{parsing-unit-declarations} that importations in both
\texttt{protecting} and \texttt{including} modes are represented using this
constructor. The sort for lists of parameters is \texttt{ParameterList}, which
is defined with constructors \texttt{parameterList} and
\texttt{nilParameterList}.

\small
\begin{verbatim}
%)

  sorts EImport EImportList .
  subsort Import < EImport  .
  subsorts ImportList EImport < EImportList .
  op including_. : ModName -> EImport .
  op __ : EImportList EImportList -> EImportList 
        [assoc id: nil] .

  sort ParameterList .
  subsort Parameter < ParameterList .
  op nilParameterList : -> ParameterList .
  op parameterList : ParameterList ParameterList -> ParameterList 
        [assoc id: nilParameterList] .

***(%
\end{verbatim}
\normalsize

Next, we introduce the different sorts for the different types of modules and
theories, with the subsort relation among them, and their constructors. The
structure of the hierarchy of sorts can be seen in
Figure~\ref{unit-sort-hierarchy}.
\begin{figure}
\begin{center}
\scalebox{.8}{
  \includegraphics{module-sort-hierarchy.eps}
}
\end{center}
\caption{\label{unit-sort-hierarchy}Hierarchy of Unit Sorts.}
\end{figure}

\small
\begin{verbatim}
%)

  sorts Unit FUnit SUnit OUnit 
        StrFModule StrSModule StrOModule StrModule 
        StrFTheory StrSTheory StrOTheory StrTheory .
  subsorts FModule < StrFModule < FUnit StrSModule .
  subsorts Module < StrSModule < SUnit StrOModule .
  subsorts StrFTheory < StrSTheory FUnit .
  subsorts StrSTheory < StrOTheory SUnit .
  subsort FUnit < SUnit .
  subsort StrOTheory < StrTheory .
  subsorts StrOTheory SUnit StrOModule < OUnit .
  subsort StrOModule < StrModule .
  subsorts StrTheory OUnit StrModule < Unit .

  op noModule : -> Module .
  op unitError : QidList -> Unit .

  op fmod_is________endfm : 
        ModName ParameterList EImportList ESortDecl ESubsortDeclSet
        EOpDeclSet EVarDeclSet EMembAxSet EquationSet -> StrFModule
        [gather (& & & & & & & & &)] .
  op fth_is________endfth : 
        ModName ParameterList EImportList ESortDecl ESubsortDeclSet
        EOpDeclSet EVarDeclSet EMembAxSet EquationSet -> StrFTheory
        [gather (& & & & & & & & &)] .
  op mod_is_________endm : 
        ModName ParameterList EImportList ESortDecl ESubsortDeclSet
        EOpDeclSet EVarDeclSet EMembAxSet EquationSet RuleSet -> StrSModule
        [gather (& & & & & & & & & &)] .
  op th_is_________endth : 
        ModName ParameterList EImportList ESortDecl ESubsortDeclSet
        EOpDeclSet EVarDeclSet EMembAxSet EquationSet RuleSet -> StrSTheory
        [gather (& & & & & & & & & &)] .
  op omod_is____________endom : 
        ModName ParameterList EImportList ESortDecl ESubsortDeclSet
        ClassDeclSet SubclassDeclSet EOpDeclSet MsgDeclSet EVarDeclSet
        EMembAxSet EquationSet RuleSet -> StrOModule
        [gather (& & & & & & & & & & & & &)] .
  op oth_is____________endoth : 
        ModName ParameterList EImportList ESortDecl ESubsortDeclSet
        ClassDeclSet SubclassDeclSet EOpDeclSet MsgDeclSet EVarDeclSet
        EMembAxSet EquationSet RuleSet -> StrOTheory
        [gather (& & & & & & & & & & & & &)] .

***(%
\end{verbatim}
\normalsize

In addition to the constructor operators, the following functions are
introduced in the \texttt{UNIT} module:
\begin{itemize}
\item
A function \verb~_in_~ to check whether a given importation
declaration is in a set of importation declarations or not.

\begin{comment}

Functions \texttt{varInModule} and \verb~_in_~ to check whether there is a
variable with a given name in a module and whether a given importation
declaration is in a set of importation declarations or not, respectively.

\small
\begin{verbatim}
%)

  op varInModule : Qid Unit -> Bool .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op _in_ : EImport EImportList -> Bool .

***(%
\end{verbatim}
\normalsize

\item
Selector functions for the different components of a unit.

\small
\begin{verbatim}
%)

  op name : Unit -> ModName .
  op importList : Unit -> EImportList .
  op parameterList : Unit -> ParameterList .
  op sortDecl : Unit -> ESortDecl .
  op subsortDeclSet : Unit -> ESubsortDeclSet .
  op opDeclSet : Unit -> EOpDeclSet .
  op varDeclSet : Unit -> EVarDeclSet .
  op membAxSet : Unit -> EMembAxSet .
  op equationSet : Unit -> EquationSet .
  op ruleSet : Unit -> RuleSet .
  op classDeclSet : Unit -> ClassDeclSet .
  op subclassDeclSet : Unit -> SubclassDeclSet .
  op msgDeclSet : Unit -> MsgDeclSet .

***(%
\end{verbatim}
\normalsize

\item
Functions to change the value of each of the components of a unit.

\small
\begin{verbatim}
%)

  op setName : Unit ModName -> Unit .
  op setParameterList : Unit ParameterList -> Unit .
  op setImportList : Unit EImportList -> Unit .
  op setSortDecl : Unit ESortDecl -> Unit .
  op setSubsortDeclSet : Unit ESubsortDeclSet -> Unit .
  op setOpDeclSet : Unit EOpDeclSet -> Unit .
  op setVarDeclSet : Unit EVarDeclSet -> Unit .
  op setMembAxSet : Unit EMembAxSet -> Unit .
  op setEquationSet : Unit EquationSet -> Unit .
  op setRuleSet : Unit RuleSet -> Unit .
  op setClassDeclSet : Unit ClassDeclSet -> Unit .
  op setSubclassDeclSet : Unit SubclassDeclSet -> Unit .
  op setMsgDeclSet : Unit MsgDeclSet -> Unit .

***(%
\end{verbatim}
\normalsize

\item
Functions to add new declarations to the set of declarations already in a unit.

\small
\begin{verbatim}
%)

  op addImportList : EImportList Unit -> Unit .
  op addSortSet : ESortSet Unit -> Unit .
  op addSubsortDeclSet : ESubsortDeclSet Unit -> Unit .
  op addOpDeclSet : EOpDeclSet Unit -> Unit .
  op addVarDeclSet : EVarDeclSet Unit -> Unit .
  op addMembAxSet : EMembAxSet Unit -> Unit .
  op addEquationSet : EquationSet Unit -> Unit .
  op addRuleSet : RuleSet Unit -> Unit .
  op addClassDeclSet : ClassDeclSet Unit -> Unit .
  op addSubclassDeclSet : SubclassDeclSet Unit -> Unit .
  op addMsgDeclSet : MsgDeclSet Unit -> Unit .

***(%
\end{verbatim}
\normalsize

\item 
There are functions and constants to create empty units of the different
types. For example, the function \texttt{emptyStrFTheory} returns an empty
structured functional theory. There is also a function \texttt{empty} which
takes a unit as argument and returns an empty unit of the same type.

\small
\begin{verbatim}
%)

  op emptyFModule : ModName -> FModule .
  op emptyStrFModule : -> StrFModule .
  op emptyStrSModule : -> StrSModule .
  op emptyStrOModule : -> StrOModule .
  op emptyStrFTheory : -> StrFTheory .
  op emptyStrSTheory : -> StrSTheory .
  op emptyStrOTheory : -> StrOTheory .
  op empty : Unit -> Unit .

***(%
\end{verbatim}
\normalsize

\item
A function \texttt{addDecls} which returns the unit resulting from adding
all the declarations in the unit passed as second argument to the unit passed
as first argument.

\small
\begin{verbatim}
%)

  op addDecls : Unit Unit -> Unit .

***(%
\end{verbatim}
\normalsize

\end{itemize}

Note that some of the `set' and `add' functions are partial functions.

\begin{comment}

\small
\begin{verbatim}
%)

  vars QI V : Qid .
  vars SD SD' : SortDecl .
  var ES : ESort .
  vars ESD ESD' : ESortDecl .
  vars ESSDS ESSDS' : ESubsortDeclSet .
  vars SSDS SSDS' SSDS'' : SubsortDeclSet .
  vars EOD EOD' : EOpDecl .
  vars EODS EODS' : EOpDeclSet .
  vars ODS ODS' : OpDeclSet .
  var At : Attr .
  vars EVDS EVDS' : EVarDeclSet .
  vars VDS VDS' : VarDeclSet .
  vars EMAS EMAS' : EMembAxSet .
  vars MAS MAS' : MembAxSet .
  vars EqS EqS' : EquationSet .
  vars RlS RlS' : RuleSet .
  vars ESS ESS' : ESortSet .
  vars IL IL' : ImportList .
  vars MN MN' : ModName .
  var QIL : QidList .
  vars PL PL' : ParameterList .
  vars CDS CDS' : ClassDeclSet .
  vars SCD SCD' : SubclassDecl .
  vars SCDS SCDS' : SubclassDeclSet .
  vars U U' : Unit .
  vars MDS MDS' : MsgDeclSet .
  vars EI EI' : EImport .
  vars EIL EIL' : EImportList .
  var T : Term .

  eq varInModule(QI, U) = varInVarDeclSet(QI, varDeclSet(U)) .

  eq EI in (EI EIL) = true .
  eq EI in (EI' EIL) = (EI == EI') or-else (EI in EIL) .
  eq EI in nil = false .

  op my-leastSort : Unit Term -> Sort .
  eq my-leastSort(U, T) 
    = if (U : Module) and (T =/= error*)
      then leastSort(U, T)
      else errorSort(none) 
      fi .

*** Selection functions for units

  eq name(unitError(QIL)) = nullModName .
  eq name(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm) = MN .
  eq name(mod QI is IL SD SSDS ODS VDS MAS EqS RlS endm) = QI .
  eq name(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth) = MN .
  eq name(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm) = MN .
  eq name(fmod QI is IL SD SSDS ODS VDS MAS EqS endfm) = QI .
  eq name(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth) = MN .
  eq name(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = MN .
  eq name(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = MN .

  eq importList(unitError(QIL)) = nil .
  eq importList(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm) = EIL .
  eq importList(mod QI is IL SD SSDS ODS VDS MAS EqS RlS endm) = IL .
  eq importList(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth) = EIL .
  eq importList(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm) = EIL .
  eq importList(fmod QI is IL SD SSDS ODS VDS MAS EqS endfm) = IL .
  eq importList(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth) = EIL .
  eq importList(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = EIL .
  eq importList(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = EIL .

  eq parameterList(unitError(QIL)) = nilParameterList .
  eq parameterList(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm)
    = PL .
  eq parameterList(mod QI is IL SD SSDS ODS VDS MAS EqS RlS endm)
    = nilParameterList .
  eq parameterList(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth)
    = PL .
  eq parameterList(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm) = PL .
  eq parameterList(fmod QI is IL SD SSDS ODS VDS MAS EqS endfm) 
    = nilParameterList .
  eq parameterList(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth) = PL .
  eq parameterList(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = PL .
  eq parameterList(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = PL .

  eq sortDecl(unitError(QIL)) = (sorts none .) .
  eq sortDecl(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm) = ESD .
  eq sortDecl(mod QI is IL SD SSDS ODS VDS EMAS EqS RlS endm) = SD .
  eq sortDecl(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth) = ESD .
  eq sortDecl(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm) = ESD .
  eq sortDecl(fmod QI is IL SD SSDS ODS VDS EMAS EqS endfm) = SD .
  eq sortDecl(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth) = ESD .
  eq sortDecl(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = ESD .
  eq sortDecl(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = ESD .
   
  eq subsortDeclSet(unitError(QIL)) = none .
  eq subsortDeclSet(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm)
    = ESSDS .
  eq subsortDeclSet(mod QI is IL SD SSDS ODS VDS MAS EqS RlS endm) = SSDS .
  eq subsortDeclSet(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth)
    = ESSDS .
  eq subsortDeclSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm)
    = ESSDS .
  eq subsortDeclSet(fmod QI is IL SD SSDS ODS VDS MAS EqS endfm) = SSDS .
  eq subsortDeclSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth)
    = ESSDS .
  eq subsortDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = ESSDS .
  eq subsortDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = ESSDS .
   
  eq opDeclSet(unitError(QIL)) = none .
  eq opDeclSet(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm) = EODS .
  eq opDeclSet(mod QI is IL SD SSDS ODS VDS MAS EqS RlS endm) = ODS .
  eq opDeclSet(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth) = EODS .
  eq opDeclSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm) = EODS .
  eq opDeclSet(fmod QI is IL SD SSDS ODS VDS MAS EqS endfm) = ODS .
  eq opDeclSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth) = EODS .
  eq opDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = EODS .
  eq opDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = EODS .
   
  eq varDeclSet(unitError(QIL)) = none .
  eq varDeclSet(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm)
    = EVDS .
  eq varDeclSet(mod QI is IL SD SSDS ODS VDS MAS EqS RlS endm) = VDS .
  eq varDeclSet(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth)
    = EVDS .
  eq varDeclSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm) = EVDS .
  eq varDeclSet(fmod QI is IL SD SSDS ODS VDS MAS EqS endfm) = VDS .
  eq varDeclSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth) = EVDS .
  eq varDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = EVDS .
  eq varDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = EVDS .
   
  eq membAxSet(unitError(QIL)) = none .
  eq membAxSet(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm) = EMAS .
  eq membAxSet(mod QI is IL SD SSDS ODS VDS EMAS EqS RlS endm) = EMAS .
  eq membAxSet(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth) = EMAS .
  eq membAxSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm) = EMAS .
  eq membAxSet(fmod QI is IL SD SSDS ODS VDS EMAS EqS endfm) = EMAS .
  eq membAxSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth) = EMAS .
  eq membAxSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = EMAS .
  eq membAxSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = EMAS .
   
  eq equationSet(unitError(QIL)) = none .
  eq equationSet(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm)
    = EqS .
  eq equationSet(mod QI is IL SD SSDS ODS VDS MAS EqS RlS endm) = EqS .
  eq equationSet(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth)
    = EqS .
  eq equationSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm) = EqS .
  eq equationSet(fmod QI is IL SD SSDS ODS VDS MAS EqS endfm) = EqS .
  eq equationSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth) = EqS .
  eq equationSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = EqS .
  eq equationSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = EqS .
   
  eq ruleSet(unitError(QIL)) = none .
  eq ruleSet(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm) = RlS .
  eq ruleSet(mod QI is IL SD SSDS ODS VDS MAS EqS RlS endm) = RlS .
  eq ruleSet(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth) = RlS .
  eq ruleSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm) = none .
  eq ruleSet(fmod QI is IL SD SSDS ODS VDS MAS EqS endfm) = none .
  eq ruleSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth) = none .
  eq ruleSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = RlS .
  eq ruleSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = RlS .
   
  eq classDeclSet(unitError(QIL)) = none .
  eq classDeclSet(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm)
    = none .
  eq classDeclSet(mod MN is IL SD SSDS ODS VDS MAS EqS RlS endm) = none .
  eq classDeclSet(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth)
    = none .
  eq classDeclSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm)
    = none .
  eq classDeclSet(fmod MN is IL SD SSDS ODS VDS MAS EqS endfm) = none .
  eq classDeclSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth)
    = none .
  eq classDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = CDS .
  eq classDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = CDS .

  eq subclassDeclSet(unitError(QIL)) = none .
  eq subclassDeclSet(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm)
    = none .
  eq subclassDeclSet(mod MN is IL SD SSDS ODS VDS MAS EqS RlS endm) = none .
  eq subclassDeclSet(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth)
    = none .
  eq subclassDeclSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm)
    = none .
  eq subclassDeclSet(fmod MN is IL SD SSDS ODS VDS MAS EqS endfm) = none .
  eq subclassDeclSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth)
    = none .
  eq subclassDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = SCDS .
  eq subclassDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = SCDS .

  eq msgDeclSet(unitError(QIL)) = none .
  eq msgDeclSet(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm)
    = none .
  eq msgDeclSet(mod MN is IL SD SSDS ODS VDS EMAS EqS RlS endm) = none .
  eq msgDeclSet(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth)
    = none .
  eq msgDeclSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm) = none .
  eq msgDeclSet(fmod MN is IL SD SSDS ODS VDS MAS EqS endfm) = none .
  eq msgDeclSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth) = none .
  eq msgDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = MDS .
  eq msgDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = MDS .

*** Set functions

  eq setImportList(unitError(QIL), EIL) = unitError(QIL) .
  eq setImportList(mod MN is EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, EIL')
    = mod MN is EIL' ESD ESSDS EODS EVDS EMAS EqS RlS endm .
  eq setImportList(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, EIL')
    = mod MN is PL EIL' ESD ESSDS EODS EVDS EMAS EqS RlS endm .
  eq setImportList(
       th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth, EIL')
    = th MN is PL EIL' ESD ESSDS EODS EVDS EMAS EqS RlS endth .
  eq setImportList(fmod MN is EIL ESD ESSDS EODS EVDS EMAS EqS endfm, EIL')
    = fmod MN is EIL' ESD ESSDS EODS EVDS EMAS EqS endfm .
  eq setImportList(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm, EIL')
    = fmod MN is PL EIL' ESD ESSDS EODS EVDS EMAS EqS endfm .
  eq setImportList(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth, EIL')
    = fth MN is PL EIL' ESD ESSDS EODS EVDS EMAS EqS endfth .
  eq setImportList(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       EIL')
    = omod MN is PL EIL' ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom .
  eq setImportList(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       EIL')
    = oth MN is PL EIL' ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth .

  eq setOpDeclSet(unitError(QIL), EODS) = unitError(QIL) .
  eq setOpDeclSet(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, EODS')
    = mod MN is PL EIL ESD ESSDS EODS' EVDS EMAS EqS RlS endm .
  eq setOpDeclSet(mod MN is EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, EODS')
    = mod MN is EIL ESD ESSDS EODS' EVDS EMAS EqS RlS endm .
  eq setOpDeclSet(
       th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth, EODS')
    = th MN is PL EIL ESD ESSDS EODS' EVDS EMAS EqS RlS endth .
  eq setOpDeclSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm, EODS')
    = fmod MN is PL EIL ESD ESSDS EODS' EVDS EMAS EqS endfm .
  eq setOpDeclSet(fmod MN is EIL ESD ESSDS EODS EVDS EMAS EqS endfm, EODS')
    = fmod MN is EIL ESD ESSDS EODS' EVDS EMAS EqS endfm .
  eq setOpDeclSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth, EODS')
    = fth MN is PL EIL ESD ESSDS EODS' EVDS EMAS EqS endfth .
  eq setOpDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       EODS')
    = omod MN is PL EIL ESD ESSDS CDS SCDS EODS' MDS EVDS EMAS EqS RlS endom .
  eq setOpDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       EODS')
    = oth MN is PL EIL ESD ESSDS CDS SCDS EODS' MDS EVDS EMAS EqS RlS endoth .

  eq setVarDeclSet(unitError(QIL), EVDS) = unitError(QIL) .
  eq setVarDeclSet(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, EVDS')
    = mod MN is PL EIL ESD ESSDS EODS EVDS' EMAS EqS RlS endm .
  eq setVarDeclSet(mod MN is EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, EVDS')
    = mod MN is EIL ESD ESSDS EODS EVDS' EMAS EqS RlS endm .
  eq setVarDeclSet(
       th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth, EVDS')
    = th MN is PL EIL ESD ESSDS EODS EVDS' EMAS EqS RlS endth .
  eq setVarDeclSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm, EVDS')
    = fmod MN is PL EIL ESD ESSDS EODS EVDS' EMAS EqS endfm .
  eq setVarDeclSet(fmod MN is EIL ESD ESSDS EODS EVDS EMAS EqS endfm, EVDS')
    = fmod MN is EIL ESD ESSDS EODS EVDS' EMAS EqS endfm .
  eq setVarDeclSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth, EVDS')
    = fth MN is PL EIL ESD ESSDS EODS EVDS' EMAS EqS endfth .
  eq setVarDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       EVDS')
    = omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS' EMAS EqS RlS endom .
  eq setVarDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       EVDS')
    = oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS' EMAS EqS RlS endoth .

  eq setSubsortDeclSet(unitError(QIL), ESSDS) = unitError(QIL) .
  eq setSubsortDeclSet(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, ESSDS')
    = mod MN is PL EIL ESD ESSDS' EODS EVDS EMAS EqS RlS endm .
  eq setSubsortDeclSet(
       mod MN is EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, ESSDS')
    = mod MN is EIL ESD ESSDS' EODS EVDS EMAS EqS RlS endm . 
  eq setSubsortDeclSet(
       th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth, ESSDS')
    = th MN is PL EIL ESD ESSDS' EODS EVDS EMAS EqS RlS endth .
  eq setSubsortDeclSet(
       fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm, ESSDS')
    = fmod MN is PL EIL ESD ESSDS' EODS EVDS EMAS EqS endfm .
  eq setSubsortDeclSet(
       fmod MN is EIL ESD ESSDS EODS EVDS EMAS EqS endfm, ESSDS')
    = fmod MN is EIL ESD ESSDS' EODS EVDS EMAS EqS endfm .
  eq setSubsortDeclSet(
       fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth, ESSDS')
    = fth MN is PL EIL ESD ESSDS' EODS EVDS EMAS EqS endfth .
  eq setSubsortDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       ESSDS')
    = omod MN is PL EIL ESD ESSDS' CDS SCDS EODS MDS EVDS EMAS EqS RlS endom .
  eq setSubsortDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       ESSDS')
    = oth MN is PL EIL ESD ESSDS' CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth . 

  eq setMembAxSet(unitError(QIL), EMAS) = unitError(QIL) .
  eq setMembAxSet(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, EMAS')
    = mod MN is PL EIL ESD ESSDS EODS EVDS EMAS' EqS RlS endm .
  eq setMembAxSet(mod MN is EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, EMAS')
    = mod MN is EIL ESD ESSDS EODS EVDS EMAS' EqS RlS endm .
  eq setMembAxSet(
       th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth, EMAS')
    = th MN is PL EIL ESD ESSDS EODS EVDS EMAS' EqS RlS endth .
  eq setMembAxSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm, EMAS')
    = fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS' EqS endfm .
  eq setMembAxSet(fmod MN is EIL ESD ESSDS EODS EVDS EMAS EqS endfm, EMAS')
    = fmod MN is EIL ESD ESSDS EODS EVDS EMAS' EqS endfm .
  eq setMembAxSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth, EMAS')
    = fth MN is PL EIL ESD ESSDS EODS EVDS EMAS' EqS endfth .
  eq setMembAxSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       EMAS')
    = omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS' EqS RlS endom .
  eq setMembAxSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       EMAS')
    = oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS' EqS RlS endoth .

  eq setEquationSet(unitError(QIL), EqS) = unitError(QIL) .
  eq setEquationSet(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, EqS')
    = mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS' RlS endm .
  eq setEquationSet(mod MN is EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, EqS')
    = mod MN is EIL ESD ESSDS EODS EVDS EMAS EqS' RlS endm .
  eq setEquationSet(
       th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth, EqS')
    = th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS' RlS endth .
  eq setEquationSet(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm, EqS')
    = fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS' endfm .
  eq setEquationSet(fmod QI is IL SD SSDS ODS VDS MAS EqS endfm, EqS')
    = fmod QI is IL SD SSDS ODS VDS MAS EqS' endfm .
  eq setEquationSet(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth, EqS')
    = fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS' endfth .
  eq setEquationSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       EqS')
    = omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS' RlS endom .
  eq setEquationSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       EqS')
    = oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS' RlS endoth .

  eq setRuleSet(unitError(QIL), RlS) = unitError(QIL) .
  eq setRuleSet(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, RlS')
    = mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS' endm .
  eq setRuleSet(mod MN is EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, RlS')
    = mod MN is EIL ESD ESSDS EODS EVDS EMAS EqS RlS' endm .
  eq setRuleSet(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth, RlS')
    = th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS' endth .
  eq setRuleSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       RlS')
    = omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS' endom .
  eq setRuleSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       RlS')
    = oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS' endoth .

  eq setSortDecl(unitError(QIL), ESD) = unitError(QIL) .
  eq setSortDecl(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, ESD')
    = mod MN is PL EIL ESD' ESSDS EODS EVDS EMAS EqS RlS endm .
  eq setSortDecl(mod MN is EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, ESD')
    = mod MN is EIL ESD' ESSDS EODS EVDS EMAS EqS RlS endm .
  eq setSortDecl(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth, ESD')
    = th MN is PL EIL ESD' ESSDS EODS EVDS EMAS EqS RlS endth .
  eq setSortDecl(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm, ESD')
    = fmod MN is PL EIL ESD' ESSDS EODS EVDS EMAS EqS endfm .
  eq setSortDecl(fmod MN is EIL ESD ESSDS EODS EVDS EMAS EqS endfm, ESD')
    = fmod MN is EIL ESD' ESSDS EODS EVDS EMAS EqS endfm .
  eq setSortDecl(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth, ESD')
    = fth MN is PL EIL ESD' ESSDS EODS EVDS EMAS EqS endfth .
  eq setSortDecl(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       ESD')
    = omod MN is PL EIL ESD' ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom .
  eq setSortDecl(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       ESD')
    = oth MN is PL EIL ESD' ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth .

  eq setParameterList(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, PL')
    = mod MN is PL' EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm .
  eq setParameterList(
       th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth, PL')
    = th MN is PL' EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth .
  eq setParameterList(
       fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm, PL')
    = fmod MN is PL' EIL ESD ESSDS EODS EVDS EMAS EqS endfm .
  eq setParameterList(
       fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth, PL')
    = fth MN is PL' EIL ESD ESSDS EODS EVDS EMAS EqS endfth .
  eq setParameterList(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       PL')
    = omod MN is PL' EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom .
  eq setParameterList(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       PL')
    = oth MN is PL' EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth .

  eq setClassDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       CDS')
    = omod MN is PL EIL ESD ESSDS CDS' SCDS EODS MDS EVDS EMAS EqS RlS endom .
  eq setClassDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       CDS')
    = oth MN is PL EIL ESD ESSDS CDS' SCDS EODS MDS EVDS EMAS EqS RlS endoth .

  eq setSubclassDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       SCDS')
    = omod MN is PL EIL ESD ESSDS CDS SCDS' EODS MDS EVDS EMAS EqS RlS endom .
  eq setSubclassDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       SCDS')
    = oth MN is PL EIL ESD ESSDS CDS SCDS' EODS MDS EVDS EMAS EqS RlS endoth .

  eq setMsgDeclSet(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       MDS')
    = omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS' EVDS EMAS EqS RlS endom .
  eq setMsgDeclSet(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       MDS')
    = oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS' EVDS EMAS EqS RlS endoth .

  eq setName(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, MN') 
    = mod MN' is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm .
  eq setName(mod MN is IL SD SSDS ODS VDS MAS EqS RlS endm, MN') 
    = mod MN' is IL SD SSDS ODS VDS MAS EqS RlS endm .
  eq setName(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm, MN') 
    = fmod MN' is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm .
  eq setName(fmod MN is IL SD SSDS ODS VDS MAS EqS endfm, MN') 
    = fmod MN' is IL SD SSDS ODS VDS MAS EqS endfm .
  eq setName(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth, MN') 
    = fth MN' is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth .
  eq setName(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth, MN') 
    = th MN' is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth .
  eq setName(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom,
       MN') 
    = omod MN' is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom .
  eq setName(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth,
       MN') 
    = oth MN' is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth .
  eq setName(unitError(QIL), MN') = unitError(QIL) .

*** Add functions

  eq addSortSet(ESS, U)
    = setSortDecl(U, (sorts (ESS ; sortSet(sortDecl(U))) .)) .
  eq addSubsortDeclSet(ESSDS, U)
    = setSubsortDeclSet(U, (ESSDS subsortDeclSet(U))) .
  eq addOpDeclSet(EODS, U)
    = setOpDeclSet(U, (EODS opDeclSet(U))) .
  eq addVarDeclSet(EVDS, U)
    = setVarDeclSet(U, (EVDS varDeclSet(U))) .
  eq addMembAxSet(EMAS, U)
    = setMembAxSet(U, (EMAS membAxSet(U))) .
  eq addEquationSet(EqS, U)
    = setEquationSet(U, (EqS equationSet(U))) .
  eq addRuleSet(RlS, U)
    = setRuleSet(U, (RlS ruleSet(U))) .
  eq addImportList(EIL, U)
    = setImportList(U, (importList(U) EIL)) .
  eq addClassDeclSet(CDS, U)
    = setClassDeclSet(U, (classDeclSet(U) CDS)) .
  eq addSubclassDeclSet(SCDS, U)
    = setSubclassDeclSet(U, (subclassDeclSet(U) SCDS)) .
  eq addMsgDeclSet(MDS, U)
    = setMsgDeclSet(U, (msgDeclSet(U) MDS)) .

*** Creation of empty units

  eq emptyFModule(MN)
    = fmod modNameToQid(MN) is
         nil (sorts none .) none none none none none
      endfm .
  eq emptyStrFModule
    = fmod nullModName is
         nilParameterList nil (sorts none .) none none none none none
      endfm .
  eq emptyStrSModule
    = mod nullModName is
         nilParameterList nil (sorts none .) none none none none none none
      endm . 
  eq emptyStrOModule
    = omod nullModName is
         nilParameterList nil (sorts none .) 
         none none none none none none none none none
      endom . 

  eq emptyStrFTheory
    = fth nullModName is
         nilParameterList nil (sorts none .) none none none none none
      endfth .

  eq emptyStrSTheory
    = th nullModName is
         nilParameterList nil (sorts none .) none none none none none none
      endth .

  eq emptyStrOTheory
    = oth nullModName is
         nilParameterList nil (sorts none .) 
         none none none none none none none none none
      endoth .

***(%
\end{verbatim}
\normalsize

\texttt{empty} returns an empty unit of the same type of the one given as
argument.

\small
\begin{verbatim}
%)
  
  eq empty(mod MN is EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm)
    = (mod MN is nil sorts none . none none none none none none endm) .
  eq empty(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm)
    = (mod MN is 
          nilParameterList nil sorts none . none none none none none none 
       endm) .
  eq empty(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth)
    = (th MN is 
          nilParameterList nil sorts none . none none none none none none 
       endth) .
  eq empty(fmod MN is EIL ESD ESSDS EODS EVDS EMAS EqS endfm)
    = (fmod MN is nil sorts none . none none none none none endfm) .
  eq empty(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm)
    = (fmod MN is 
          nilParameterList nil sorts none . none none none none none 
       endfm) .
  eq empty(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth)
    = (fth MN is 
          nilParameterList nil sorts none . none none none none none 
       endfth) .
  eq empty(
       omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = (omod MN is 
          nilParameterList nil sorts none . 
          none none none none none none none none none 
       endom) .
  eq empty(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = (oth MN is 
          nilParameterList nil sorts none . 
          none none none none none none none none none 
       endoth) .

***(%
\end{verbatim}
\normalsize

In the following \texttt{addDecls} function, the declarations of the unit
given as second argument are added to the unit given as first argument.

\small
\begin{verbatim}
%)

  eq addDecls(unitError(QIL), U) = unitError(QIL) .
  eq addDecls(U, unitError(QIL)) = unitError(QIL) .
  ceq addDecls(U, U')
    = addImportList(importList(U'),
        addSortSet(sortSet(sortDecl(U')),
          addSubsortDeclSet(subsortDeclSet(U'),
            addOpDeclSet(opDeclSet(U'),
              addVarDeclSet(varDeclSet(U'),
                addMembAxSet(membAxSet(U'),
                  addEquationSet(equationSet(U'), 
                    if U : FUnit 
                    then U
                    else addRuleSet(ruleSet(U'), 
                           if U : SUnit 
                           then U
                           else addClassDeclSet(classDeclSet(U'),
                                  addSubclassDeclSet(subclassDeclSet(U'),
                                    addMsgDeclSet(msgDeclSet(U'), U)))
                           fi)
                    fi)))))))
      if ((U : StrModule) or (U : StrTheory)) 
         and ((U' : StrModule) or (U' : StrTheory)) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\section{The Abstract Data Type \texttt{View}}
\label{sec:viewADT}

In this section we present the data type \texttt{View} for views. Basically,
the data elements of sort \texttt{View} are composed by the name of the view,
the names of the source and target units, and a set of maps representing the
maps asserting how the given target unit is claimed to satisfy the source
theory (see Section~\ref{Views}).

Internally, renaming maps are considered to be a particular case of
view maps. The sort \texttt{ViewMap} is declared as a supersort of
\texttt{Map}. The only kind of maps in sort \texttt{ViewMap} not in
sort \texttt{Map} are maps of operators going to derived operators. We
start introducing the declarations for renaming maps and sets of
renaming maps in Section~\ref{renaming-maps}, we then introduce view
maps and sets of view maps in Section~\ref{view-maps}, and finally we
introduce the sort \texttt{View}, its constructor, and some operations
on it in Section~\ref{viewADT}.


\subsection{Renaming Maps}
\label{renaming-maps}

We introduce the different types of renaming maps in the following module
\texttt{MAP}. A sort is introduced for each of these types of maps, with the
appropriate constructors for each sort (see
Section~\ref{module-expressions}). All these sorts are declared to be subsorts
of the sort \texttt{Map}. A sort for sets of maps (\texttt{MapSet}) is then
declared as supersort of \texttt{Map} with constructors \texttt{none} and
\verb~_,_~.

\small
\begin{verbatim}
%)

fmod MAP is
  pr EXT-SORT .

  sorts OpMap SortMap LabelMap ClassMap MsgMap AttrMap Map .
  subsorts OpMap SortMap LabelMap ClassMap MsgMap AttrMap < Map .
  op op_to_[_] : Qid Qid AttrSet -> OpMap .
  op op_:_->_to_[_] : Qid ESortList ESort Qid AttrSet -> OpMap .
  op sort_to_ : ESort ESort -> SortMap .
  op label_to_ : Qid Qid -> LabelMap .
  op class_to_ : ESort ESort -> ClassMap .
  op attr_._to_ : Qid ESort Qid -> AttrMap .
  op msg_to_ : Qid Qid -> MsgMap .
  op msg_:_->_to_ : Qid ESortList ESort Qid -> MsgMap .

  sort MapSet .
  subsort Map < MapSet .
  op none : -> MapSet .
  op _,_ : MapSet MapSet -> MapSet [assoc comm id: none] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

Given a set of maps, the function \texttt{sortMapSet} returns the subset of
sort maps in it.

\small
\begin{verbatim}
%)

  var MAP : Map .
  var MAPS : MapSet .

  op sortMapSet : MapSet -> MapSet .

  eq sortMapSet((MAP, MAPS))
    = if MAP : SortMap
      then (MAP, sortMapSet(MAPS))
      else sortMapSet(MAPS)
      fi .
  eq sortMapSet(none) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{View Maps}
\label{view-maps}

In addition to the maps of sort \texttt{Map} declared in the \texttt{MAP}
module, in views there can also be maps from operators to derived operators,
that is, terms with variables (see Section~\ref{Views}). Maps of this kind are
given with the constructor \texttt{termMap}, which, in addition to the source
and target terms, takes the set of variable declarations for the variables
used in the map. The source term must be of the form
$\texttt{F(X}_1\texttt{,}\ldots,\texttt{X}_n\texttt{)}$, where \texttt{F} is
an operator name declared with $n$ arguments of sorts in the connected
components of the variables $\texttt{X}_1\ldots\texttt{X}_n$, respectively. We
will see in Section~\ref{view-processing} how in the initial processing of a
view the variables declared in it are associated to each of the maps in which
they are used.

\small
\begin{verbatim}
%)

fmod VIEW-MAP is
  pr MAP .
  pr EXT-DECL .

  sort TermMap .
  op termMap : EVarDeclSet Term Term -> TermMap .

  sorts ViewMap ViewMapSet .
  subsorts Map TermMap < ViewMap .
  subsorts ViewMap MapSet < ViewMapSet .
  op _,_ : ViewMapSet ViewMapSet -> ViewMapSet [assoc comm id: none] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var VMAP : ViewMap .
  var VMAPS : ViewMapSet .

***(%
\end{verbatim}
\normalsize

As for sets of maps,
\texttt{SortMapSet} returns the subset of sort maps in a set of view maps.
\small
\begin{verbatim}
%)

  op sortMapSet : ViewMapSet -> MapSet .

  eq sortMapSet((VMAP, VMAPS))
    = if VMAP : SortMap
      then (VMAP, sortMapSet(VMAPS))
      else sortMapSet(VMAPS)
      fi .
  eq sortMapSet(none) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Views}
\label{viewADT}

The \texttt{View} sort is introduced in the following module \texttt{VIEW}.
In addition to the constructor for views (\texttt{view}), selector functions
are added for each of the components of a view (\texttt{name},
\texttt{source}, \texttt{target}, and \texttt{mapSet}), and a constant
\texttt{emptyView}, which is identified in an equation with the empty view, is
defined.

Although the declaration of the constructor for views includes an argument for
the list of parameters, parameterized views are not handled yet, so at present
this argument must be set to the \texttt{nilParameterList}.

\small
\begin{verbatim}
%)

fmod VIEW is
  pr UNIT .
  pr VIEW-MAP .

  sort View .
  op view : ViewExp ParameterList ModExp ModExp ViewMapSet -> View .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var QI : Qid .
  var VE : ViewExp .
  var PL : ParameterList .
  vars ME ME' : ModExp .
  var VMAPS : ViewMapSet .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op name : View -> ViewExp .
  op source : View -> ModExp .
  op target : View -> ModExp .
  op mapSet : View -> ViewMapSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq name(view(VE, PL, ME, ME', VMAPS)) = VE .
  eq target(view(VE, PL, ME, ME', VMAPS)) = ME' .
  eq source(view(VE, PL, ME, ME', VMAPS)) = ME .
  eq mapSet(view(VE, PL, ME, ME', VMAPS)) = VMAPS .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op emptyView : Qid ModExp ModExp -> View .

  eq emptyView(QI, ME, ME')
    = view(QI, nilParameterList, ME, ME', none) .

***(%
\end{verbatim}
\normalsize

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\section{The Abstract Data Type \texttt{Database}}
\label{sec:databaseADT}

In this section we present the data type \texttt{Database}, which will be used
to store information about the units and views in the system. Before
discussing this data type in Section~\ref{databaseADT}, we present the
predefined units added in Full Maude to those already available in Core
Maude.


\subsection{Non-Built-In Predefined Modules}
\label{non-built-in-predefined}

As we shall see in the following section, except for the
\texttt{LOOP-MODE} module, all the predefined modules that are
available in Core Maude are also available in Full Maude. In addition
to these Core Maude predefined modules, in Full Maude we have some
additional predefined units. In the present system, the only units
with which the database is initialized (see Section~\ref{main-module})
are the functional theory \texttt{TRIV}, the module
\texttt{CONFIGURATION} (see Section~\ref{object-oriented-modules}),
and the module \texttt{UP}, which will be used to evaluate the
\texttt{up} functions (see Sections~\ref{structured-specifications}
and~\ref{bubble-parsing}). We shall see in Section~\ref{main-module}
how new predefined modules can be added to the initial database.

\small
\begin{verbatim}
%)

fmod PREDEF-UNITS is
  pr UNIT .

  op TRIV : -> StrFTheory .
  eq TRIV = (fth 'TRIV is 
                nilParameterList
                nil
                sorts 'Elt . 
                none 
                none 
                none 
                none 
                none 
             endfth) .

  op CONFIGURATION : -> StrFModule .
  eq CONFIGURATION 
    = (fmod 'CONFIGURATION is
          nilParameterList
          nil
          sorts 'Oid ; 'Cid ; 'Attribute ; 'AttributeSet ; 
                'Configuration ; 'Object ; 'Msg .
          subsort 'Attribute < 'AttributeSet .
          subsort 'Object < 'Configuration .
          subsort 'Msg < 'Configuration .
          op 'none : nil -> 'AttributeSet [none] .
          op '_`,_ : 'AttributeSet 'AttributeSet -> 'AttributeSet
                [comm assoc id({'none}'AttributeSet)] .
          op 'none : nil -> 'Configuration [none] .
          op '__ : 'Configuration 'Configuration -> 'Configuration 
                [comm assoc id({'none}'Configuration)] .
          op '<_:_|_> : 'Oid 'Cid 'AttributeSet -> 'Object [none] .
          op '<_:_|`> : 'Oid 'Cid -> 'Object [none] .
          var 'O : 'Oid . var 'C : 'Cid .
          none
          eq '<_:_|`>['O, 'C] = '<_:_|_>['O, 'C, {'none}'AttributeSet] .
       endfm) .

***(%
\end{verbatim}
\normalsize

The following module \texttt{UP} contains the necessary declarations to be
able to parse the \texttt{up} functions presented in
Section~\ref{structured-specifications}. We shall see in
Section~\ref{evaluation} how a declaration importing the following module
\texttt{UP} is added to all the modules importing the predefined module
\texttt{META-LEVEL}. With this declaration, it is possible to parse the
\texttt{up} commands in the bubbles of such modules or in commands being
evaluated in such modules. We shall see in Section~\ref{bubble-parsing} how
these commands are then evaluated.

\small
\begin{verbatim}
%)

  op UP : -> StrFModule .
  eq UP
    = (fmod 'UP is
          nilParameterList
          including 'QID-LIST .
          including 'META-LEVEL .
          sorts 'Token ; 'Bubble .
          none
          op 'token : 'Qid -> 'Token 
               [special(
                 (id-hook('Bubble, '1 '1)
                  op-hook('qidBaseSymbol, '<Qids>, nil, 'Qid)))] .
          op 'bubble : 'QidList -> 'Bubble 
               [special(
                 (id-hook('Bubble, '1 '-1 '`( '`))
                  op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                  op-hook('qidBaseSymbol, '<Qids>, nil, 'Qid)))] .
          op 'up : 'Token 'Bubble -> 'Term [none] .
          op 'up : 'Token -> 'Module [none] .
          none
          none
          none
       endfm) .

endfm

***(%
\end{verbatim}
\normalsize


\subsection{The Database}
\label{databaseADT}

In order to be able to refer to modules by name, which is extremely useful for
module definition purposes at the user level, the evaluation of module
expressions takes place in the context of a database, in
which we keep information about the modules already introduced in the system,
and also about those modules generated internally.  This information is stored
as a set of elements of sort \texttt{UnitInfo} and \texttt{ViewInfo}, in which
we hold, respectively, the information concerning units and views.  For each
unit we save:
\begin{itemize}
\item
Its original form, as introduced by the user, or, in case of an internally
generated unit, as generated from the original form of some other unit.
\item
Its internal representation, in which variables have been renamed to avoid
collisions with the names of variables in other units in the same hierarchy.
In the case of object-oriented units, we store its equivalent system
module, that is, the result of transforming it into a system module.
\item
Its signature, which is given as a functional module of sort \texttt{FModule}
with no axioms, ready to be used in calls to \texttt{meta-parse}. There can
only be importation declarations including built-in modules in this
module. These are the only inclusions handled by the Core Maude engine.
\item
Its flattened version, for which, as for signatures, only the importation
of built-in modules is left unevaluated.
\end{itemize}

For each view we keep its name and the view itself.

As a simple mechanism to keep the database consistent, for each unit we
maintain the list of names of all the units and views ``depending'' on
it. Similarly, for each view we maintain the list of names of all the units
``depending'' on it. The idea is that if a unit or view is redefined or
removed, all those units and/or views depending on it will also be
removed. This dependency does not only mean direct importation. For example,
the module resulting from the renaming of some module also depends on the
module being renamed; the instantiation of a parameterized module also depends
on the parameterized module and on all the views used in its instantiation; a
view depends on its source and target units, etc. This dependency is
transitive: if a module, theory, or view has to be removed, all the units
and/or views depending on them will be removed as well. The dependencies
derived from the module expressions themselves are established by the function
\texttt{setUpModExpDependencies}. The function \texttt{setUpUnitDependencies}
calls \texttt{setUpModExpDependencies}, and then
\texttt{setUpImportSetDependencies} to add the \emph{back references} in the
modules being imported. The function \texttt{setUpViewDependencies} sets up
the back references for the views being introduced.

In addition to this set of information cells for units and views, we
also keep lists with the names of all the units and views in the
database, and a list of quoted identifiers in which we store the
messages generated during the process of treatment of the inputs in
order to simplify the communication with the read-eval-print loop
process.

\small
\begin{verbatim}
%)

fmod DATABASE is
  pr VIEW .

  sort UnitInfo .
  op <_;_;_;_;_;_;_> : ModName Unit Unit Unit Module 
        ModNameSet ViewExpSet -> UnitInfo .

  sort ViewInfo .
  op <_;_;_> : ViewExp View ModNameSet -> ViewInfo .

  sort InfoSet .
  subsort UnitInfo ViewInfo < InfoSet .
  op emptyInfoSet : -> InfoSet .
  op __ : InfoSet InfoSet -> InfoSet 
        [assoc comm id: emptyInfoSet] .

  sort Database .
  op database : InfoSet ModNameSet ViewExpSet QidList -> Database .

  vars QI X : Qid .
  vars QIL QIL' : QidList .
  var VE : ViewExp .
  vars VES VES' : ViewExpSet .
  var IS : InfoSet .
  vars MNS MNS' MNS'' : ModNameSet .
  var PL : ParameterList .
  vars ME ME' : ModExp .
  var VI : View .
  var VMAPS : ViewMapSet .
  vars U U' U'' : Unit .
  var DB : Database .
  vars M M' M'' : Module .
  var EIL : EImportList .
  vars MN MN' : ModName .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var VIf : ViewInfo .

***(%
\end{verbatim}
\normalsize

\end{comment}

The constant \texttt{emptyDatabase} denotes the empty database, and
there are predicates \texttt{viewInDatabase} and \texttt{unitInDatabase} to
check, respectively, whether a view and a unit are in a database or not.

\small
\begin{verbatim}
%)

  op emptyDatabase : -> Database .
  eq emptyDatabase 
    = database(emptyInfoSet, noneModNameSet, noneViewExpSet, nil) .

  op unitInDatabase : ModName Database -> Bool .
  op viewInDatabase : ViewExp Database -> Bool .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq viewInDatabase(VE, database(IS, MNS, VES, QIL)) 
    = VE inViewExpSet VES .

  eq unitInDatabase(MN, database(IS, MNS, VES, QIL)) 
    = MN inModNameSet MNS .

***(%
\end{verbatim}
\normalsize

\end{comment}

If a module, theory, or view is being redefined, that is, if there was already
in the database a module, theory, or view with the same name, then all the
units and/or views depending on it are removed using the functions
\texttt{deleteUnits} and \texttt{deleteViews}. Removing a view or a unit from
the database means removing its info cell from the set of cells in the
database.

\small
\begin{verbatim}
%)

  op deleteUnits : ModNameSet Database -> Database .
  op deleteViews : ViewExpSet Database -> Database .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq deleteUnits((MN & MNS), 
       database((< MN ; U ; U' ; M ; M' ; MNS' ; VES > IS), 
         (MN & MNS''), VES', QIL))
    = deleteUnits((MNS & MNS'), 
        deleteViews(VES, 
          database(IS, MNS'', VES', 
           (QIL ('\n 'ADVISORY: 'Module modNameToQidList(MN) 'removed))))) .
  ceq deleteUnits((MN & MNS), DB)
    = deleteUnits(MNS, DB)
      if not unitInDatabase(MN, DB) .
  eq deleteUnits(noneModNameSet, DB) = DB .

  eq deleteViews((VE # VES), 
       database((< VE ; VI ; MNS > IS), MNS', (VE # VES'), QIL))
    = deleteViews(VES, 
        deleteUnits(MNS, 
          database(IS, MNS', VES', 
            (QIL ('\n 'ADVISORY: 'View viewExpToQidList(VE) 'removed))))) .
  ceq deleteViews((VE # VES), DB)
    = deleteViews(VES, DB)
      if not viewInDatabase(VE, DB) .
  eq deleteViews(noneViewExpSet, DB) = DB .

***(%
\end{verbatim}
\normalsize

\end{comment}

The \texttt{warning} function allows us to place messages (warning, error, or
any other kind of messages) in the last argument of the database
constructor. These messages are given in the form of quoted identifier lists,
and will be passed to the third argument of the read-eval-print loop, to be
printed in the terminal.

\small
\begin{verbatim}
%)

  op warning : Database QidList -> Database .
  eq warning(database(IS, MNS, VES, QIL), QIL')
    = database(IS, MNS, VES, (QIL QIL')) .

***(%
\end{verbatim}
\normalsize

The constant \texttt{builtIns} denotes the set of identifiers of the
predefined modules of Core Maude. It will be used to check whether a
particular module is a built-in Core Maude module or not. 

\small
\begin{verbatim}
%)

  op builtIns : -> ModNameSet .
  eq builtIns 
    = 'TRUTH-VALUE & 'TRUTH & 'BOOL & 'IDENTICAL & 'MACHINE-INT & 
      'QID & 'QID-LIST & 'META-LEVEL & 'LOOP-MODE .

***(%
\end{verbatim}
\normalsize

Core Maude built-in modules are handled in a special way in the current
version of the system. They are not explicitly defined in the Full Maude
database; their importation is directly handled by Core Maude. This has some
drawbacks: Core Maude built-in modules cannot be renamed; they cannot be
directly used with built-in functions, such as \texttt{meta-reduce} or
\texttt{sameComponent}, although they can be imported in modules being used in
the calls to these functions; and, in general, any function taking as argument
or returning as result the metarepresentation of a module cannot take one of
these built-in modules as argument. This is the case, for example, for the
\texttt{up} function presented in Section~\ref{changing-levels}, or for
functions or commands in which the name of a module has to be
specified, as the \texttt{select} or \texttt{down} commands, or the
\texttt{up} function presented in
Section~\ref{structured-specifications}. Nevertheless, there are also
some advantages: The flattening of the built-in part of the structure
is accomplished more efficiently, and, since these modules do not have
to be stored in the database of Full Maude, the size of the database
is reduced.

Our plan is to have in the future a hybrid solution. Once we have some way of
storing the modules entered to Full Maude in Core Maude's database, it will be
enough to keep in the Full Maude database just the original form of the top of
all the modules, including built-ins, leaving all the importation declarations
to be resolved by the engine. The structures will be normalized as they are
now, so that the engine will have to deal just with inclusions, but it will be
possible to use the predefined modules as any other module. Moreover, the Full
Maude database will be relatively smaller and the flattening will be computed
more efficiently.

When a new module or theory is entered, the names of all the modules,
theories, and views depending on it are included in its lists of dependencies
with functions \texttt{setUpUnitDependencies} and
\texttt{setUpViewDependencies}. Notice that if new module expressions are
defined, the function \texttt{setUpModExpDependencies} will have to be
extended accordingly.

\small
\begin{verbatim}
%)

  op setUpUnitDependencies : Unit Database -> Database .
  op setUpModExpDependencies : ModName Database -> Database .
  op setUpImportSetDependencies : 
        ModName EImportList Database -> Database .

  eq setUpUnitDependencies(U, DB)
    = setUpImportSetDependencies(name(U), importList(U), 
        setUpModExpDependencies(name(U), DB)) .

  eq setUpModExpDependencies((par X :: ME), 
       database((< ME ; U ; U' ; M ; M' ; MNS ; VES > IS), 
         MNS', VES', QIL))
    = database(
        (< ME ; U ; U' ; M ; M' ; MNS & (par X :: ME) ; VES > IS), 
        MNS', VES', QIL) .
  ceq setUpModExpDependencies((par X :: ME), DB)
    = warning(DB, 
        ('\n 'ERROR: 
         'module modNameToQidList(ME) 'not 'in 'database '.))
      if not unitInDatabase(ME, DB) .
  eq setUpModExpDependencies(QI, DB) = DB .

  eq setUpImportSetDependencies(MN, ((including MN' .) EIL), 
       database((< MN' ; U ; U' ; M ; M' ; MNS' ; VES > IS), 
         MNS'', VES', QIL))
    = setUpImportSetDependencies(MN, EIL, 
         database((< MN' ; U ; U' ; M ; M' ; MNS' & MN ; VES > IS), 
            MNS'', VES', QIL)) .
  ceq setUpImportSetDependencies(MN, ((including MN' .) EIL), DB)
    = if MN' inModNameSet builtIns
      then DB
      else warning(DB, 
             ('\n 'ERROR: 
              'module modNameToQidList(MN') 'not 'in 'database '.))
      fi
      if not unitInDatabase(MN', DB) .
  eq setUpImportSetDependencies(MN, nil, DB) = DB .

  op setUpViewDependencies : ModExp ViewExp Database -> Database .

  eq setUpViewDependencies(ME, VE, 
        database(
          (< ME ; U ; U' ; M ; M' ; MNS' ; VES > IS), 
          MNS'', VES', QIL))
    = database(
         (< ME ; U ; U' ; M ; M' ; MNS' ; VES # VE > IS), 
         MNS'', VES', QIL) .
  ceq setUpViewDependencies(ME, VE, DB)
    = if ME inModNameSet builtIns
      then DB
      else warning(DB, 
             ('\n 'ERROR: 
              'module modNameToQidList(ME) 'not 'in 'database '.))
      fi
      if not unitInDatabase(ME, DB) .

***(%
\end{verbatim}
\normalsize

There are functions to insert and extract a view in the database.

\small
\begin{verbatim}
%)

  op insertView : View Database -> Database .
  op getView : ViewExp Database -> View .

  eq insertView(view(VE, PL, ME, ME', VMAPS), 
       database((< VE ; VI ; MNS > IS), MNS', VES, QIL))
    = setUpViewDependencies(ME, VE, 
        setUpViewDependencies(ME', VE, 
          deleteUnits(MNS, 
            database(
              (< VE ; view(VE, PL, ME, ME', VMAPS) ; noneModNameSet > IS), 
              MNS', VES, QIL)))) .
  ceq insertView(view(VE, PL, ME, ME', VMAPS), 
        database(IS, MNS, VES, QIL))
    = setUpViewDependencies(ME, VE, 
        setUpViewDependencies(ME', VE, 
          database(
            (< VE ; view(VE, PL, ME, ME', VMAPS) ; noneModNameSet > IS),
            MNS, (VE # VES), QIL)))
      if not (VE inViewExpSet VES) .

  eq getView(VE, database((< VE ; VI ; MNS > IS), MNS', VES, QIL)) 
    = VI .

***(%
\end{verbatim}
\normalsize

There are functions to insert the different versions of a unit, and to extract
them.
We only give here the equations for the insertion of top units to illustrate
the way in which the consistency of the database is maintained.  We assume
that when the internal version, the signature, or the flat version of a module
is entered in the database, its corresponding top module is already present in
it.


\small
\begin{verbatim}
%)

  op insertTopUnit : Unit Database -> Database .
  op insertInternalTopUnit : Unit Database -> Database .
  op insertSignature : ModName Unit Database -> Database .
  op insertFlatUnit : ModName Unit Database -> Database .
  op getTopUnit : ModName Database -> Unit .
  op getInternalTopUnit : ModName Database -> Unit .
  op getSignature : ModName Database -> Unit .
  op getFlatUnit : ModName Database -> Unit .

  ceq insertTopUnit(U, database(IS, MNS, VES, QIL))
    = setUpUnitDependencies(U, 
        database(
          (< name(U) ; U ; noModule ; noModule ; 
             noModule ; noneModNameSet ; noneViewExpSet > IS), 
          (name(U) & MNS), VES, QIL))
      if not (name(U) inModNameSet MNS) .
  ceq insertTopUnit(U, 
        database((< MN ; U' ; U'' ; M ; M' ; MNS ; VES > IS), 
          MNS', VES', QIL))
    = setUpUnitDependencies(U, 
        deleteUnits(MNS, 
          deleteViews(VES, 
             database(
               (< MN ; U ; noModule ; noModule ; 
                  noModule ; noneModNameSet ; noneViewExpSet > IS), 
               MNS', VES', 
               (QIL ('\n 'ADVISORY: 
                     'Module modNameToQidList(MN) 'redefined))))))
      if name(U) == MN .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  ceq insertInternalTopUnit(U, 
        database((< MN ; U' ; U'' ; M ; M' ; MNS ; VES > IS), MNS', VES', QIL))
    = database((< MN ; U' ; U ; M ; M' ; MNS ; VES > IS), MNS', VES', QIL)
      if name(U) == MN .
  eq insertInternalTopUnit(unitError(QIL), database(IS, MNS, VES, QIL'))
    = database(IS, MNS, VES, QIL' QIL) .

  eq insertSignature(MN, M, 
        database((< MN ; U ; U' ; M' ; M'' ; MNS ; VES > IS), MNS', VES', QIL))
    = database((< MN ; U ; U' ; M ; M'' ; MNS ; VES > IS), MNS', VES', QIL) .
  eq insertSignature(MN, unitError(QIL), database(IS, MNS, VES, QIL'))
    = database(IS, MNS, VES, QIL' QIL) .

  eq insertFlatUnit(MN, M, 
        database((< MN ; U ; U' ; M' ; M'' ; MNS ; VES > IS), MNS', VES', QIL))
    = database((< MN ; U ; U' ; M' ; M ; MNS ; VES > IS), MNS', VES', QIL) .
  eq insertFlatUnit(MN, unitError(QIL), database(IS, MNS, VES, QIL'))
    = database(IS, MNS, VES, (QIL' QIL)) .

  eq getTopUnit(MN, 
         database((< MN' ; U ; U' ; M ; M' ; MNS ; VES > IS), MNS', VES', QIL))
    = if MN == MN'
      then U
      else getTopUnit(MN, database(IS, MNS', VES', QIL))
      fi .
  eq getTopUnit(MN, database((VIf IS), MNS, VES, QIL))
    = getTopUnit(MN, database(IS, MNS, VES, QIL)) .
  eq getTopUnit(MN, database(emptyInfoSet, MNS, VES, QIL))
    = unitError(
        '\n 'ERROR: 'module modNameToQidList(MN) 'not 'in 'database '.) .

  eq getInternalTopUnit(MN, 
       database((< MN' ; U ; U' ; M ; M' ; MNS ; VES > IS), MNS', VES', QIL))
    = if MN == MN'
      then U'
      else getInternalTopUnit(MN, database(IS, MNS', VES', QIL))
      fi .
  eq getInternalTopUnit(MN, database((VIf IS), MNS, VES, QIL))
    = getInternalTopUnit(MN, database(IS, MNS, VES, QIL)) .
  eq getInternalTopUnit(MN, database(emptyInfoSet, MNS, VES, QIL))
    = unitError(
        '\n 'ERROR: 'module modNameToQidList(MN) 'not 'in 'database '.) .

***(%
\end{verbatim}
\normalsize

The name of the signature and the flattened module is not the module
expression used as the name of the module but the result of converting it into
a quoted identifier.

\small
\begin{verbatim}
%)

  eq getSignature(MN, 
       database((< MN' ; U ; U' ; M ; M' ; MNS ; VES > IS), MNS', VES', QIL))
    = if MN == MN' 
      then M
      else getSignature(MN, database(IS, MNS', VES', QIL))
      fi .
  eq getSignature(MN, database((VIf IS), MNS, VES, QIL))
    = getSignature(MN, database(IS, MNS, VES, QIL)) .
  eq getSignature(MN, database(emptyInfoSet, MNS, VES, QIL))
    = unitError(
        '\n 'ERROR: 'module modNameToQidList(MN) 'not 'in 'database '.) .

  eq getFlatUnit(MN, 
       database((< MN' ; U ; U' ; M ; M' ; MNS ; VES > IS), MNS', VES', QIL))
    = if MN == MN'
      then M'
      else getFlatUnit(MN, database(IS, MNS', VES', QIL))
      fi .
  eq getFlatUnit(MN, database((VIf IS), MNS, VES, QIL))
    = getFlatUnit(MN, database(IS, MNS, VES, QIL)) .
  eq getFlatUnit(MN, database(emptyInfoSet, MNS, VES, QIL))
    = unitError(
        '\n 'ERROR: 'module modNameToQidList(MN) 'not 'in 'database '.) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\section{The Evaluation of Units}
\label{evaluation-units}


The general principle for the evaluation of units in our design consists in
first evaluating any module expression, reducing it to a canonical form in
which only unit inclusions appear, that is, to a unit hierarchy, which can be
seen as a partial order of unit inclusions. The design of the Full Maude
system has been based upon the principle of evaluating all module expressions
to irreducible structured units, and on using the flat version of the units
only for execution purposes. We have then two different processes clearly
distinguished: a first step in which the structured unit is evaluated and
reduced to its normal form, and a second step in which this normal form is
flattened. We illustrate both stages of this process in
Section~\ref{evaluation-overview} with a very simple example, namely the
importation of a renamed module.

As explained in Section~\ref{execution-environment}, the process of evaluation
to normal form is also responsible for the parsing of the bubbles in the
premodules, which is accomplished once the signature has been built. The
parsing of bubbles is discussed in Section~\ref{bubble-parsing}. To be able to
handle the \texttt{up} function and the \texttt{down} command presented in
Section~\ref{structured-specifications}, it is necessary to be able to move
terms and modules from one level of reflection to another. The functionality
to move between levels is presented in Section~\ref{changing-levels}, where
functions \texttt{up} and \texttt{down} on sorts \texttt{Module} and
\texttt{Term} are defined. The transformation of object-oriented modules into
system modules in discussed in Section~\ref{omod2modfunction}. The evaluation
of module expressions is discussed in Sections~\ref{evalModExp},
\ref{application-of-maps}, \ref{instantiation}, and~\ref{renaming}.


\subsection{Overview of the Unit Evaluation Process}
\label{evaluation-overview}

Let us consider the following specification \texttt{NAT} of natural numbers,
as a functional module with a sort \texttt{Nat} and operations \texttt{zero}
and \texttt{suc} with the usual meaning, and a specification \texttt{NAT3} of
the natural numbers modulo 3, given by importing a renamed copy of the module
\texttt{NAT} and adding the corresponding congruence equation. Note that this
module is imported in {\it including} mode, that is, nothing is guaranteed
about the relationship between the initial models of \texttt{NAT} and
\texttt{NAT3}.

\small
\begin{verbatim}
 (fmod NAT is               
    sort Nat .              
    op zero : -> Nat .      
    op suc : Nat -> Nat .   
  endfm)

 (fmod NAT3 is
    including NAT *(sort Nat to Nat3) .
    eq suc(suc(suc(zero))) = zero .
  endfm)
\end{verbatim}
\normalsize

The renaming process is summarized in the following picture. Basically, we
create a copy of the module \texttt{NAT}, with name 
\mbox{\texttt{NAT *(sort Nat to Nat3)}}, in which the sort \texttt{Nat} has
been renamed to \texttt{Nat3}. This amounts to a module transformation denoted
by $\phi$ in the picture below. Then, the renamed module is included as a
submodule of \texttt{NAT3}, in which the congruence equation is added. It is
important to highlight the fact that there is no inclusion relationship
between the modules \texttt{NAT} and \texttt{NAT3}. The ``confusion''
associated to the congruence modulo 3 equation has only been introduced in the
sort \texttt{Nat3}, which has nothing to do with the sort \texttt{Nat}.  
$$
\xymatrix{
& 
{\xytextbox{\texttt{NAT3}}} \\
{\xytextbox{\texttt{NAT}}}
    \ar@{-->}[r]_(.2){\phi} &
{\xytextbox{\texttt{NAT *(sort Nat to Nat3)}}}
    \ar@{_{(}->}[u]
}
$$
%) for the open parenthesis in the arrow

\begin{comment}
$$
\xymatrix{ 
{\xytextbox{\texttt{NAT}}} 
  \ar[r]_(.2){\phi} & 
{\xytextbox{\texttt{NAT *(sort Nat to Nat3)}}} 
  \ar@{^{(}->}[r] & 
{\xytextbox{\texttt{ NAT3}}}
} 
$$
%) for the open parenthesis in the arrow
\end{comment}


The metarepresentations of the modules \texttt{NAT} and \texttt{NAT3}
before being evaluated are given by the following terms of sort
\texttt{StrFModule}:

\small
\begin{verbatim}
  fmod 'NAT is
    nilParameterList
    nil
    sorts 'Nat .
    none
    op 'zero : nil -> 'Nat [none] .
    op 'suc : 'Nat -> 'Nat [none] .
    none 
    none 
    none
  endfm

  fmod 'NAT3 is
    nilParameterList
    including 'NAT *(sort 'Nat to 'Nat3) .
    sorts none . 
    none
    none 
    none 
    none
    eq 'suc['suc['suc[{'zero}'Nat3]]] = {'zero}'Nat3 .
  endfm
\end{verbatim}
\normalsize

\subsubsection{Normalization of Extended Modules}
\label{NormalizationOfExtendedModules}

For \texttt{NAT3}, the first stage of the module evaluation process consists
in the reduction of the module to its structured normal form. This
normalization step can be understood as the evaluation of all module
expressions in it. Since the normal forms of all previously defined modules
have been computed and have been stored in the database, the module
expressions have to be evaluated only in the module at the top of the
hierarchy. However, some of the operations may affect the whole structure, or
part of it. This happens, for example, with the renaming operation when some
of the renamings affect sorts or operators in a submodule. We will discuss the
details about the evaluation of the renaming module expression in
Section~\ref{renaming}. Note that in this case, as in general for all the
module operations we deal with, given a structured module as input, we
evaluate it without flattening, and return a structured module as result.

The evaluation of the only module expression appearing in the module
\texttt{NAT3}, namely \texttt{NAT *(sort Nat to Nat3)}, results in a new
module, whose \textit{name} is given by the module expression itself. This
module is then introduced in the database, in such a way that if the module
expression appears again, it will not be recomputed. The representation of
this module at the metalevel is

\small
\begin{verbatim}
  fmod 'NAT *(sort Nat to Nat3) is 
    nilParameterList
    nil
    sorts 'Nat3 .
    none
    op 'zero : nil -> 'Nat3 [none] .
    op 'suc : 'Nat3 -> 'Nat3 [none] .
    none
    none
    none
  endfm
\end{verbatim}
\normalsize

Note that the name of the module is the module expression itself. Thus, the
normalization process does not change the text of the module being normalized,
such as \texttt{NAT3} in our example. Instead, each imported module expression
is evaluated and a new module with that expression as name is entered into the
database. In this way, the normalization yields a structured module in which
only inclusions appear. The following picture shows the form of this structure
for the example.
$$
\xymatrix{
{\xytextbox{\texttt{NAT3}}} \\
{\xytextbox{\texttt{NAT *(sort Nat to Nat3)}}}
    \ar@{_{(}->}[u]
}
$$
%) for the open parenthesis in the arrow

\begin{comment}
$$
\xymatrix{
{\texttt{NAT *(sort Nat to Nat3) }}
    \ar@{^{(}->}[r]
&
\texttt{ NAT3} 
}
$$
%) for the open parenthesis in the arrow
\end{comment}

\subsubsection{Flattening}
\label{Flattening}

The flattening of the normalized structure is accomplished following the
tradition of the Clear/OBJ family of languages, in which specification
structuring is based on the categorical concept of
\textit{colimit}~\cite{BurstallGoguen80,DiaconescuGoguenStefaneas91,GoguenBurstall84a}. However,
instead of considering the category of specifications and specification
morphisms~\cite{BurstallGoguen80}, flattening is understood as a colimit in
the category of specifications and inclusions of specifications.  The colimit
of a diagram in this category coincides with the set-theoretic union of the
theories in the diagram. This is accomplished by the function
$$\texttt{evalUnit} : 
  \texttt{Unit Database} \rightarrow \texttt{Database}$$
that takes a unit $U$ and a database and returns the database after having
evaluated all the module expressions appearing in $U$. The corresponding flat
form of the module is also included in the database.

The resulting flat specification for \texttt{NAT3} is:

\small
\begin{verbatim}
  fmod 'NAT3 is
    nilParameterList
    nil
    sorts 'Nat3 .
    none
    op 'zero : nil -> 'Nat3 [none] .
    op 'suc : 'Nat3 -> 'Nat3 [none] .
    none
    none
    eq 'suc['suc['suc[{'zero}'Nat3]]] 
      = {'zero}'Nat3 . 
  endfm
\end{verbatim}
\normalsize

Note that in the flattening of a structured module we are assuming that sort
names are unique in each structure, although not necessarily in the entire
database. This proposal is simpler than the solution taken, for example, in
OBJ3~\cite{OBJ92}, in which sorts and operations are qualified by module
names. However, although simpler, this solution would not be fully
satisfactory without some mechanism to help the user avoid the systematic
renaming of repeated sorts, which---as discussed in
Section~\ref{parameterized-modules}---is a common occurrence in the presence
of parameterized modules. This is accomplished by parameterized sorts, already
introduced in Section~\ref{extended-sorts} and further discussed in
Section~\ref{parameterized-modules}.

\subsection{Changing Levels}
\label{changing-levels}

Moving terms of sorts \texttt{Term} and \texttt{Module} from one level of
reflection to another is possible thanks to the \texttt{up} and \texttt{down}
functions, which are defined, respectively,
in the following modules \texttt{MOVE-UP} and \texttt{MOVE-DOWN}.


\subsubsection{The \texttt{up} Function}

Given a term of sort \texttt{Module} or \texttt{Term}, the \texttt{up}
function, defined in the following module \texttt{MOVE-UP}, returns the term
metarepresenting it. The function is also defined on the different components
of a unit. The \texttt{up} function on units is defined recursively by
applying it to the different components of a unit.

The semantics of the \texttt{up} functions can be inferred from the following
example. The result of applying the \texttt{up} function to the
metarepresentation of the flat form of the module \texttt{NAT3} presented in
Section~\ref{evaluation-overview} is the following.

\small
\begin{verbatim}
red up(fmod 'NAT3 is
          nil
          sorts 'Nat3 .
          none
          op 'zero : nil -> 'Nat3 [none] .
          op 'suc : 'Nat3 -> 'Nat3 [none] .
          none
          none
          eq 'suc['suc['suc[{'zero}'Nat3]]] 
            = {'zero}'Nat3 . 
        endfm) .

result Term: 
  'fmod_is_______endfm[
     {''NAT3}'Qid,
     {'nil}'ImportList,
     'sorts_.[{''Nat3}'Qid],
     {'none}'SubsortDeclSet,
     '__['op_:_->_`[_`].[{''zero}'Qid, {'nil}'QidList, {''Nat3}'Qid,
            {'none}'AttrSet],
         'op_:_->_`[_`].[{''suc}'Qid, {''Nat3}'Qid, {''Nat3}'Qid,
            {'none}'AttrSet]],
     {'none}'VarDeclSet,
     {'none}'MembAxSet,
     'eq_=_.['_`[_`][{''suc}'Qid, 
               '_`[_`][{''suc}'Qid, 
                 '_`[_`][{''suc}'Qid, 
                   '`{_`}_[{''zero}'Qid, {''Nat3}'Qid]]]],
             '`{_`}_[{''zero}'Qid, {''Nat3}'Qid]]]
\end{verbatim}
\normalsize

We shall see in Section~\ref{bubble-parsing} how the \texttt{up} function is
used to evaluate the homonymous function discussed in
Section~\ref{structured-specifications}. In Section~\ref{instantiation} we
shall discuss how the \texttt{up} function is used to evaluate the
\texttt{META-LEVEL} module expression (see
Section~\ref{structured-specifications}).



\small
\begin{verbatim}
%)

fmod MOVE-UP is
  pr UNIT .  
  op up : Unit -> Term .
  op up : Module -> Term .
  op up : Term -> Term .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op up : Qid -> Term .
  op up : QidList -> Term .
  op up : QidSet -> Term .
  op up : ImportList -> Term .
  op up : SortDecl -> Term .
  op up : SubsortDeclSet -> Term .
  op up : OpDeclSet -> Term .
  op up : VarDeclSet -> Term .
  op up : MembAxSet -> Term .
  op up : EquationSet -> Term .
  op up : RuleSet -> Term .
  op up : AttrSet -> Term .
  op up : Attr -> Term .
  op up : TermList -> Term .
  op up : HookList -> Term .
  op up : MachineIntList -> Term .

  vars QI QI' QI'' F V L : Qid .
  var QIL : QidList .
  var ME : ModExp .
  var ES : ESort .
  vars ESS ESS' : ESortSet .
  var ESL : ESortList .
  var IL : ImportList .
  var EIL : EImportList .
  var SD : SortDecl .
  var ESD : ESortDecl .
  var SSDS : SubsortDeclSet .
  var ESSDS : ESubsortDeclSet .
  var ODS : OpDeclSet .
  var EODS : EOpDeclSet .
  var VDS : VarDeclSet .
  var EVDS : EVarDeclSet .
  var MAS : MembAxSet .
  var EMAS : EMembAxSet .
  var EqS : EquationSet .
  var RlS : RuleSet .
  var At : Attr .
  var AtS : AttrSet .
  vars T T' T'' T''' : Term .
  var TL : TermList .
  var H : Hook .
  var HL : HookList .
  var I : MachineInt .
  var MIL : MachineIntList .

  eq up(unitError(QIL)) = error* .
  eq up(noModule) = error* .
  eq up(fmod QI is IL SD SSDS ODS VDS MAS EqS endfm)
    = 'fmod_is_______endfm[
          up(QI), up(IL), up(SD), up(SSDS),
          up(ODS), up(VDS), up(MAS), up(EqS)] .
  eq up(mod QI is IL SD SSDS ODS VDS MAS EqS RlS endm)
    = 'mod_is________endm[
          up(QI), up(IL), up(SD), up(SSDS),
          up(ODS), up(VDS), up(MAS),up(EqS), up(RlS)] .

  ceq up(((including ME .) EIL))
    = '__['including_.[up(ME)], up(EIL)]
      if EIL =/= nil .
  ceq up(((including ME .) EIL))
    = 'including_.[up(ME)]
      if EIL == nil .
  eq up((nil).ImportList) = {'nil}'ImportList .

  eq up((sorts ESS .)) = 'sorts_.[up(ESS)] .
  ceq up(((subsort ESS < ESS' .) ESSDS))
    = '__['subsort_<_.[up(ESS), up(ESS')], up(ESSDS)]
      if ESSDS =/= none .
  eq up((subsort ESS < ESS' .)) = 'subsort_<_.[up(ESS), up(ESS')] .
  eq up((none).SubsortDeclSet) = {'none}'SubsortDeclSet .

  ceq up(((op F : ESL -> ES [AtS] .) EODS))
    = '__['op_:_->_`[_`].[up(F), up(ESL), up(ES), up(AtS)], up(EODS)]
      if EODS =/= none .
  eq up((op F : ESL -> ES [AtS] .))
    = 'op_:_->_`[_`].[up(F), up(ESL), up(ES), up(AtS)] .
  eq up((none).OpDeclSet) = {'none}'OpDeclSet .

  ceq up((At AtS))
    = '__[up(At), up(AtS)] 
      if AtS =/= none .
  eq up((none).AttrSet) = {'none}'AttrSet .

  eq up(assoc) = {'assoc}'Attr .
  eq up(comm) = {'comm}'Attr .
  eq up(idem) = {'idem}'Attr .
  eq up(id(T)) = 'id[up(T)] .
  eq up(left-id(T)) = 'left-id[up(T)] .
  eq up(right-id(T)) = 'right-id[up(T)] .
  eq up(strat(MIL)) = 'strat[up(MIL)] .
  eq up(memo) = {'memo}'Attr .
  eq up(prec(I)) = 'prec[up(I)] .
  eq up(gather(QIL)) = 'gather[up(QIL)] .
  eq up(ctor) = {'ctor}'Attr .
  eq up(special(HL)) = 'special[up(HL)] .

  eq up((H HL)) = '__[up(H), up(HL)] .
  eq up(id-hook(QI, QIL))
    = 'id-hook[up(QI), up(QIL)] .
  eq up(op-hook(QI, QI', QIL, QI''))
    = 'op-hook[up(QI), up(QI'), up(QIL), up(QI'')] .
  eq up(term-hook(QI, T)) = 'term-hook[up(QI), up(T)] .

  eq up(QI) = {conc('', QI)}'Qid .
  eq up({QI}QI') = '`{_`}_[up(QI), up(QI')] .
  eq up(T[TL]) = '_`[_`][up(T), up(TL)] .
  eq up(T : ES) = '_:_[up(T), up(ES)] .
  eq up(T :: ES) = '_::_[up(T), up(ES)] .
  eq up((T, TL)) = '_`,_[up(T), up(TL)] .

  ceq up(((var V : ES .) EVDS))
    = '__['var_:_.[up(V), up(ES)], up(EVDS)]
      if EVDS =/= none .
  eq up((var V : ES .)) = 'var_:_.[up(V), up(ES)] .
  eq up((none).VarDeclSet) = {'none}'VarDeclSet .

  ceq up(((mb T : ES .) EMAS))
    = '__['mb_:_.[up(T), up(ES)], up(EMAS)]
      if EMAS =/= none .
  ceq up(((cmb T : ES if T' = T'' .) EMAS))
    = '__['cmb_:_if_=_.[
             up(T), up(ES), up(T'), up(T'')], up(EMAS)]
      if EMAS =/= none .
  eq up((mb T : ES .)) = 'mb_:_.[up(T), up(ES)] .
  eq up((cmb T : ES if T' = T'' .))
    = 'cmb_:_if_=_.[up(T), up(ES), up(T'), up(T'')] .
  eq up((none).MembAxSet) = {'none}'MembAxSet .

  ceq up(((eq T = T' .) EqS))
    = '__['eq_=_.[up(T), up(T')], up(EqS)]
      if EqS =/= none .
  ceq up(((ceq T = T' if T'' = T''' .) EqS))
    = '__['ceq_=_if_=_.[
             up(T), up(T'), up(T''), up(T''')], up(EqS)]
      if EqS =/= none .
  eq up((eq T = T' .)) = 'eq_=_.[up(T), up(T')] .
  eq up((ceq T = T' if T'' = T''' .))
    = 'ceq_=_if_=_.[up(T), up(T'), up(T''), up(T''')] .
  eq up((none).EquationSet) = {'none}'EquationSet .

  ceq up(((rl [L] : T => T' .) RlS))
    = '__['rl`[_`]:_=>_.[up(L), up(T), up(T')], up(RlS)]
      if RlS =/= none .
  ceq up(((crl [L]: T => T' if T'' = T''' .) RlS))
    = '__['crl`[_`]:_=>_if_=_.[
             up(L), up(T), up(T'), up(T''), up(T''')], 
          up(RlS)]
      if RlS =/= none .
  eq up((rl [L] : T => T' .))
    = 'rl`[_`]:_=>_.[up(L), up(T), up(T')] .
  eq up((crl [L]: T => T' if T'' = T''' .))
    = 'crl`[_`]:_=>_if_=_.[
         up(L), up(T), up(T'), up(T''), up(T''')] .
  eq up((none).RuleSet) = {'none}'RuleSet .

  ceq up((ES ; ESS))
    = '_;_[up(ES), up(ESS)] 
      if ESS =/= none .
  eq up((none).QidSet) = {'none}'QidSet .

  ceq up((ES ESL))
    = '__[up(ES), up(ESL)] 
      if ESL =/= nil .
  eq up((nil).QidList) = {'nil}'QidList .

  eq up(I) = {index(' , I)}'MachineInt .
  ceq up((I MIL))
    = '__[{index(' , I)}'MachineInt, up(MIL)]
      if MIL =/= nil .
  eq up((nil).MachineIntList) = {'nil}'MachineIntList .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

 
\subsubsection{The \texttt{down} Function}

Given a term of sort \texttt{Term} metarepresenting a term of sort
\texttt{Term} or \texttt{Module}, the \texttt{down} function can be seen as
the inverse of the \texttt{up} function discussed in the previous section,
that is, it returns the original term that had been metarepresented. There are
also \texttt{down} functions for terms metarepresenting terms in other
sorts. We present here only some of them.

We assume that the \texttt{down} functions are called with valid
metarepresentations. In fact, these functions should be declared as partial
functions going to error sorts when their arguments are invalid.

The main application of the \texttt{down} functions is in the
evaluation of the \texttt{down} command (see
Section~\ref{structured-specifications}).  However, they are also used
in other tasks, as for example in the parsing of some inputs.

\small
\begin{verbatim}
%)

fmod MOVE-DOWN is
  pr UNIT .
  op downTerm : Term -> Term .
  op downModule : Term -> Module .
  op downQid : Term -> Qid .
  op downQidList : Term -> QidList .
  op downQidSet : Term -> QidSet .
  op downModName : Term -> ModName .
  op downMachineInt : Term -> MachineInt .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op downQidList : TermList -> QidList .
  op downQidSet : TermList -> QidSet .
  op downTerm : TermList -> Term .
  op downImportList : TermList -> ImportList .
  op downSortDecl : Term -> SortDecl .
  op downSubsortDeclSet : TermList -> SubsortDeclSet .
  op downOpDeclSet : TermList -> OpDeclSet .
  op downVarDeclSet : TermList -> VarDeclSet .
  op downMembAxSet : TermList -> MembAxSet .
  op downEquationSet : TermList -> EquationSet .
  op downRuleSet : TermList -> RuleSet .
  op downAttrSet : TermList -> AttrSet .
  op downAttr : Term -> Attr .
  op downHookList : TermList -> HookList .
  op downMetaMachineInt : Term -> Term .
  op downMachineInt : TermList -> MachineIntList .

  vars T T' T'' T''' T1 T2 T3 T4 T5 T6 T7 T8 T9 : Term .
  vars TL TL' : TermList .
  vars QI QI' F V L : Qid .

  eq downModule('fmod_is_______endfm[T1, T2, T3, T4, T5, T6, T7, T8])
    = fmod downModName(T1) is
         downImportList(T2) downSortDecl(T3) 
         downSubsortDeclSet(T4) downOpDeclSet(T5) 
         downVarDeclSet(T6) downMembAxSet(T7) downEquationSet(T8)
      endfm .

  eq downModule('mod_is________endm[T1, T2, T3, T4, T5, T6, T7, T8, T9])
    = mod downModName(T1) is
         downImportList(T2) downSortDecl(T3)
         downSubsortDeclSet(T4) downOpDeclSet(T5) 
         downVarDeclSet(T6) downMembAxSet(T7)
         downEquationSet(T8) downRuleSet(T9)
      endm .

  eq downModName({QI}'Qid) = downQid({QI}'Qid) .

  eq downImportList({'nil}'ImportList) = nil .
  eq downImportList('__[TL]) = downImportList(TL) .
  eq downImportList((TL, TL'))
    = (downImportList(TL) downImportList(TL')) .
  eq downImportList('including_.[T])
    = (including downModName(T) .) .

  eq downSortDecl('sorts_.[T]) = (sorts downQidSet(T) .) .

  eq downSubsortDeclSet({'none}'SubsortDeclSet) = none .
  eq downSubsortDeclSet('__[TL]) = downSubsortDeclSet(TL) .
  eq downSubsortDeclSet((TL, TL'))
    = (downSubsortDeclSet(TL) downSubsortDeclSet(TL')) .
  eq downSubsortDeclSet('subsort_<_.[T, T'])
    = (subsort downQid(T) < downQid(T') .) .

  eq downOpDeclSet({'none}'OpDeclSet) = none .
  eq downOpDeclSet('__[TL]) = downOpDeclSet(TL) .
  eq downOpDeclSet((TL, TL'))
    = (downOpDeclSet(TL) downOpDeclSet(TL')) .
  eq downOpDeclSet('op_:_->_`[_`].[{F}'Qid, T, T', T''])
    = (op downQid(F) : downQidList(T) -> downQid(T') [downAttrSet(T'')] .) .

  eq downAttrSet({'none}'AttrSet) = none .
  eq downAttrSet('__[TL]) = downAttrSet(TL) .
  eq downAttrSet((TL, TL')) = (downAttr(TL) downAttrSet(TL')) .
  ceq downAttrSet(T)
    = downAttr(T)
      if T =/= {'none}'AttrSet .

  eq downAttr({'assoc}'Attr) = assoc .
  eq downAttr({'comm}'Attr) = comm .
  eq downAttr({'idem}'Attr) = idem .
  eq downAttr('id[T]) = id(downTerm(T)) .
  eq downAttr('left-id[T]) = left-id(downTerm(T)) .
  eq downAttr('right-id[T]) = right-id(downTerm(T)) .
  eq downAttr('strat[T]) = strat(downMachineInt(T)) .
  eq downAttr({'memo}'Attr) = memo .
  eq downAttr('prec[T]) = prec(downMachineInt(T)) .
  eq downAttr('gather[T]) = gather(downQidList(T)) .
  eq downAttr({'ctor}'Attr) = ctor .
  eq downAttr('special[T]) = special(downHookList(T)) .

  eq downHookList('__[TL]) = downHookList(TL) .
  eq downHookList((TL, TL')) = downHookList(TL) downHookList(TL') .
  eq downHookList('id-hook[T, T'])
    = id-hook(downQid(T), downQidList(T')) .
  eq downHookList('op-hook[T, T', T'', T'''])
    = op-hook(downQid(T), downQid(T'), downQidList(T''), downQid(T''')) .
  eq downHookList('term-hook[T, T'])
    = term-hook(downQid(T), downTerm(T')) .

  eq downTerm({F}QI) = downQid(F) .
  eq downTerm('`{_`}_[T, T']) = {downTerm(T)}downTerm(T') .
  eq downTerm('_:_[T, T']) = downTerm(T) : downQid(T') .
  eq downTerm('_::_[T, T']) = downTerm(T) :: downQid(T') .
  eq downTerm('_`[_`][T, T']) = downTerm(T)[downTerm(T')] .
  eq downTerm('_`,_[T, TL]) = (downTerm(T), downTerm(TL)) .
  eq downTerm((T, TL)) = (downTerm(T), downTerm(TL)) .
  eq downTerm(error*) = error* .
  ceq downTerm(F[TL]) 
    = error*
      if (F =/= '`{_`}_) and (F =/= '_:_) and (F =/= '_::_) 
         and (F =/= '_`[_`]) and (F =/= '_`,_) .

  eq downVarDeclSet({'none}'VarDeclSet) = none .
  eq downVarDeclSet('__[TL]) = downVarDeclSet(TL) .
  eq downVarDeclSet((TL, TL'))
    = (downVarDeclSet(TL) downVarDeclSet(TL')) .
  eq downVarDeclSet('var_:_.[{V}'Qid, T])
    = (var downQid(V) : downQid(T) .) .

  eq downMembAxSet({'none}'MembAxSet) = none .
  eq downMembAxSet('__[TL]) = downMembAxSet(TL) .
  eq downMembAxSet((TL, TL')) = (downMembAxSet(TL) downMembAxSet(TL')) .
  eq downMembAxSet('mb_:_.[T, T'])
    = (mb downTerm(T) : downQid(T') .) .
  eq downMembAxSet('cmb_:_if_=_.[T, T', T'', T'''])
    = (cmb downTerm(T) : downQid(T') if downTerm(T'') = downTerm(T''') .) .

  eq downEquationSet({'none}'EquationSet) = none .
  eq downEquationSet('__[TL]) = downEquationSet(TL) .
  eq downEquationSet((TL, TL'))
    = (downEquationSet(TL) downEquationSet(TL')) .
  eq downEquationSet('eq_=_.[T, T'])
    = (eq downTerm(T) = downTerm(T') .) .
  eq downEquationSet('ceq_=_if_=_.[T, T', T'', T'''])
    = (ceq downTerm(T) = downTerm(T') if downTerm(T'') = downTerm(T''') .) .

  eq downRuleSet({'none}'RuleSet) = none .
  eq downRuleSet('__[TL]) = downRuleSet(TL) .
  eq downRuleSet((TL, TL')) = (downRuleSet(TL) downRuleSet(TL')) .
  eq downRuleSet('rl`[_`]:_=>_.[{L}'Qid, T, T'])
    = (rl [downQid(L)] : downTerm(T) => downTerm(T') .) .
  eq downRuleSet('crl`[_`]:_=>_if_=_.[{L}'Qid, T, T', T'', T'''])
    = (crl [downQid(L)] : downTerm(T) 
         => downTerm(T') if downTerm(T'') = downTerm(T''') .) .

  eq downQidSet({'none}'QidSet') = none .
  eq downQidSet('_;_[TL]) = downQidSet(TL) .
  eq downQidSet((TL, TL')) = (downQidSet(TL) ; downQidSet(TL')) .
  eq downQidSet({QI}'Qid) = downQid(QI) .

  eq downQidList({'nil}'QidList) = nil .
  eq downQidList('__[TL]) = downQidList(TL) .
  eq downQidList((TL, TL')) = (downQidList(TL) downQidList(TL')) .
  eq downQidList({QI}'Qid) = downQid(QI) .
  eq downQidList('`(_`)[{QI}'Qid]) = downQid(QI) .

  eq downQid(QI) = strip(QI) .
  eq downQid('`(_`)[QI]) = strip(QI) .
  eq downQid({QI}QI') = strip(QI) .

  eq downMetaMachineInt({QI}'Qid)
    = {strip(QI)}'MachineInt .

  eq downMachineInt({QI}'NzMachineInt) 
    = downMachineInt({QI}'MachineInt) .
  eq downMachineInt({QI}'MachineInt) = convert(QI) .

  eq downMachineInt('__[TL])
    = downMachineInt(TL) . 
  eq downMachineInt((TL, TL'))
    = (downMachineInt(TL) downMachineInt(TL')) .
  eq downMachineInt({'nil}'MachineIntList) = nil .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Renaming of Variables}

To avoid the clash of names of variables appearing in different units in the
same unit hierarchy, which can appear very easily when such a hierarchy is
flattened to a single unit, variables are systematically renamed.  The
function \texttt{renameVars} takes a unit and returns it with all the
variables in it renamed following the convention of adding the character
`\texttt{@}' plus the name of its sort after being converted to a
\texttt{Qid}.
\begin{comment} 
which is accomplished by the \texttt{qualifyVar} function.
\end{comment} 
Thus, for example, a variable \texttt{'N} of sort \texttt{'Nat} is renamed to
\texttt{'N@Nat}, and a variable \texttt{'L} of sort \texttt{'List['X]} is
renamed to \texttt{'L@List`[X`]}.

\small
\begin{verbatim}
%)

fmod VBLE-RENAMING is
  pr UNIT .
  pr EXT-SORT-TO-QID .

  op renameVars : Unit -> Unit .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op renameVars : EVarDeclSet -> EVarDeclSet .
  op renameVars : EVarDeclSet EMembAxSet -> EMembAxSet .
  op renameVars : EVarDeclSet EquationSet -> EquationSet .
  op renameVars : EVarDeclSet RuleSet -> RuleSet .
  op renameVars : EVarDeclSet TermList -> TermList .
  op renameVars : EVarDeclSet EOpDeclSet -> EOpDeclSet .
  op renameVars : EVarDeclSet AttrSet -> AttrSet .

  op qualifyVar : Qid ESort -> Qid .

  var QI QI' V L F : Qid .
  var QIL : QidList .
  var VE : ViewExp .
  var MN : ModName .
  var PL : ParameterList .
  var EIL : EImportList .
  var ES : ESort .
  var ESL : ESortList .
  var ESD : ESortDecl .
  var ESSDS : ESubsortDeclSet .
  var EODS : EOpDeclSet .
  var EVDS : EVarDeclSet .
  var EMAS : EMembAxSet .
  var EqS : EquationSet .
  var RlS : RuleSet .
  var CDS : ClassDeclSet .
  var SCDS : SubclassDeclSet .
  var MDS : MsgDeclSet .
  var T T' T'' T''' : Term .
  var TL : TermList .
  var At : Attr .
  var AtS : AttrSet . 
  var I : MachineInt .
  var MIL : MachineIntList .
  var HL : HookList .

  eq qualifyVar(QI, ES) = conc(QI, conc('@, eSortToQid(ES))) .

  eq renameVars(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm) 
    = mod MN is 
          PL EIL ESD ESSDS 
          renameVars(EVDS, EODS)
          renameVars(EVDS)
          renameVars(EVDS, EMAS)
          renameVars(EVDS, EqS)
          renameVars(EVDS, RlS)
      endm .
  eq renameVars(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth) 
    = th MN is 
          PL EIL ESD ESSDS 
          renameVars(EVDS, EODS)
          renameVars(EVDS)
          renameVars(EVDS, EMAS)
          renameVars(EVDS, EqS)
          renameVars(EVDS, RlS)
      endth .
  eq renameVars(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm) 
    = fmod MN is
          PL EIL ESD ESSDS 
          renameVars(EVDS, EODS)
          renameVars(EVDS)
          renameVars(EVDS, EMAS)
          renameVars(EVDS, EqS)
      endfm .
  eq renameVars(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth) 
    = fth MN is 
          PL EIL ESD ESSDS 
          renameVars(EVDS, EODS)
          renameVars(EVDS)
          renameVars(EVDS, EMAS)
          renameVars(EVDS, EqS)
      endfth .
  eq renameVars(
        omod MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endom)
    = omod MN is 
           PL EIL ESD ESSDS CDS SCDS 
           renameVars(EVDS, EODS) MDS
           renameVars(EVDS)
           renameVars(EVDS, EMAS)
           renameVars(EVDS, EqS)
           renameVars(EVDS, RlS)
      endom .
  eq renameVars(
        oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth)
    = oth MN is 
           PL EIL ESD ESSDS CDS SCDS 
           renameVars(EVDS, EODS) MDS
           renameVars(EVDS)
           renameVars(EVDS, EMAS)
           renameVars(EVDS, EqS)
           renameVars(EVDS, RlS)
      endoth .
  eq renameVars(unitError(QIL)) = unitError(QIL) .

  eq renameVars(EVDS, ((op F : ESL -> ES [AtS] .) EODS))
    = ((op F : ESL -> ES [renameVars(EVDS, AtS)] .)
       renameVars(EVDS, EODS)) .
  eq renameVars(EVDS, (none).OpDeclSet) = none .
  eq renameVars(none, EODS) = EODS .

  eq renameVars(EVDS, (id(T) AtS))
    = (id(renameVars(EVDS, T)) renameVars(EVDS, AtS)) .
  eq renameVars(EVDS, (left-id(T) AtS))
    = (left-id(renameVars(EVDS, T)) renameVars(EVDS, AtS)) .
  eq renameVars(EVDS, (right-id(T) AtS))
    = (right-id(renameVars(EVDS, T)) renameVars(EVDS, AtS)) .
  eq renameVars(EVDS, (strat(MIL) AtS))
    = (strat(MIL) renameVars(EVDS, AtS)) .
  eq renameVars(EVDS, (gather(QIL) AtS))
    = (gather(QIL) renameVars(EVDS, AtS)) .
  eq renameVars(EVDS, (prec(I) AtS))
    = (prec(I) renameVars(EVDS, AtS)) .
  eq renameVars(EVDS, (special(HL) AtS))
    = (special(HL) renameVars(EVDS, AtS)) .
  ceq renameVars(EVDS, (At AtS))
    = (At renameVars(EVDS, AtS))
      if (At == comm) or (At == assoc) or (At == idem) 
         or (At == memo) or (At == ctor) .
  eq renameVars(EVDS, (none).AttrSet) = none .
  eq renameVars(none, AtS) = AtS .

  eq renameVars(((var V : ES .) EVDS))
    = ((var qualifyVar(V, ES) : ES .) renameVars(EVDS)) .
  eq renameVars(none) = none .

  eq renameVars(EVDS, ((mb T : ES .) EMAS))
    = ((mb renameVars(EVDS, T) : ES .) renameVars(EVDS, EMAS)) .
  eq renameVars(EVDS, ((cmb T : ES if T' = T'' .) EMAS))
    = ((cmb renameVars(EVDS, T) : ES  
           if renameVars(EVDS, T') = renameVars(EVDS, T'') .) 
       renameVars(EVDS, EMAS)) .
  eq renameVars(EVDS, (none).EMembAxSet) = none .

  eq renameVars(EVDS, ((eq T = T' .) EqS))
    = ((eq renameVars(EVDS, T) = renameVars(EVDS, T') .) 
       renameVars(EVDS, EqS)) .
  eq renameVars(EVDS, ((ceq T = T' if T'' = T''' .) EqS))
    = ((ceq renameVars(EVDS, T) = renameVars(EVDS, T')
           if renameVars(EVDS, T'') = renameVars(EVDS, T''') .) 
       renameVars(EVDS, EqS)) .
  eq renameVars(EVDS, (none).EquationSet) = none .

  eq renameVars(EVDS, ((rl [L] : T => T' .) RlS))
    = ((rl [L] : renameVars(EVDS, T) => renameVars(EVDS, T') .)
       renameVars(EVDS, RlS)) .
  eq renameVars(EVDS, ((crl [L]: T => T' if T'' = T''' .) RlS))
    = ((crl [L] : renameVars(EVDS, T) => renameVars(EVDS, T')
           if renameVars(EVDS, T'') = renameVars(EVDS, T''') .)
       renameVars(EVDS, RlS)) .
  eq renameVars(EVDS, (none).RuleSet) = none .

  eq renameVars(EVDS, error*) = error* .
  eq renameVars(EVDS, F[TL]) = F[renameVars(EVDS, TL)] .
  eq renameVars(((var V : ES .) EVDS), V) = qualifyVar(V, ES) .
  eq renameVars(EVDS, {F}ES) = {F}ES .
  eq renameVars(EVDS, T : ES) = renameVars(EVDS, T) : ES .
  eq renameVars(EVDS, T :: ES) = renameVars(EVDS, T) :: ES .
  eq renameVars(EVDS, (T, TL))
    = (renameVars(EVDS, T), renameVars(EVDS, TL)) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Parsing of Bubbles}
\label{bubble-parsing}

As discussed in Section~\ref{implementation-introduction}, in Full Maude, the
parsing process is split into two phases. In a first stage, the input is parsed
using the top-level grammar for Full Maude modules, theories, views, and
commands. Once this first stage is completed, we get a term with bubbles in
it, which is converted into a module, theory, or view. This unit or view may
still have the bubbles in it. We say that a module with bubbles is a
premodule, a view with bubbles a preview, and so on. The second stage of the
process consists in taking this preunit or preview and converting the bubbles
in it into terms by parsing them in the appropriate signatures, obtaining a
`valid' unit or view out of it, or otherwise a parsing error. In the case of
commands, if they contain any bubble, the same will have to be done. All
bubbles have to be parsed in the appropriate signature before any further
processing can be done with the module, view, or command in which they appear.


\subsubsection{Parsing of Bubbles}

In the following module \texttt{BUBBLE-PARSING}, the definitions for the basic
processing of bubbles are introduced. In it we declare a function
\texttt{solveBubbles} which takes a bubble and some other arguments and
returns the term resulting from parsing it.

\small
\begin{verbatim}
%)

fmod BUBBLE-PARSING is
  pr DATABASE .
  pr MOVE-UP .
  pr MOVE-DOWN .
  pr EXT-SORT-TO-QID .

  var T : Term .
  var M : Module .
  var B : Bool .
  var QIL : QidList .
  var DB : Database .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var T' : Term .
  var TL : TermList .
  var ES : ESort .
  vars QI QI' F : Qid .

***(%
\end{verbatim}
\normalsize

\end{comment}

As we shall see in Section~\ref{evaluation}, a declaration importing the
predefined module \texttt{UP} (see Section~\ref{non-built-in-predefined}) is
added to all modules importing the \texttt{META-LEVEL} module. The
\texttt{solveBubbles} function is called with a `flag' indicating whether
the module can contain calls to the \texttt{up} function or not. Thus, when we
call \texttt{meta-parse} with some bubble and the module in which such bubble
has to be parsed, if there are occurrences of the function \texttt{up} in it,
they will be of the form \verb~'up['token[T]]~ or 
\verb~'up['token[T], 'bubble[T']]~ for terms \texttt{T} and \texttt{T'}. The
function \texttt{solveUps} will evaluate them.

\small
\begin{verbatim}
%)

  op solveBubbles : Term Module Bool Database -> Term .
  op solveBubbles1 : QidList Module Bool Database -> Term .
  op solveUps : TermList Database -> TermList .

***(%
\end{verbatim}
\normalsize

The function \texttt{solveBubbles} calls the function \texttt{solveBubbles1}
after lowering the list of quoted identifiers of the bubble.

\small
\begin{verbatim}
%)

  eq solveBubbles('bubble[T], M, B, DB)
    = solveBubbles1(downQidList(T), M, B, DB) .

***(%
\end{verbatim}
\normalsize

The \texttt{solveBubbles1} function is in charge of calling the function
\texttt{meta-parse}. The flag indicating the inclusion of the module
\texttt{META-LEVEL} in the module in which the term appears decides whether
the function \texttt{solveUps} is called or not, so the extra price of
searching for calls to the \texttt{up} function is paid only when an occurrence
of the function is possible. This function takes care of the occurrences
of the \texttt{up} function that may exist in such bubbles.

The function \texttt{solveUps} goes through the term looking for a term with
\texttt{'up} as top operator and \texttt{'token} as top operator of its unique
argument if there is only one argument, or with \texttt{'token} and
\texttt{'bubble} as top operators of its first and second arguments,
respectively, if there are two. If a term of the form
\mbox{\texttt{'up['token[T]]}} is reached, it is replaced by the
metarepresentation of the flat version of the module in the database with the
name given by the token. If a term of form \mbox{\texttt{'up['token[T],
'bubble[T']]}} is reached, the metarepresentation of the result of parsing the
bubble in the signature of the module with the name given by the token, after
solving possible nested calls to the \texttt{up} function, is returned.

\small
\begin{verbatim}
%)

  eq solveBubbles1(QIL, M, true, DB) = solveUps(meta-parse(M, QIL), DB) .
  eq solveBubbles1(QIL, M, false, DB) = meta-parse(M, QIL) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq solveUps({QI}QI', DB) = {QI}QI' .
  eq solveUps(QI, DB) = QI .
  ceq solveUps(F[TL], DB)
    = F[solveUps(TL, DB)] 
      if F =/= 'up .
  eq solveUps(T : ES, DB) = solveUps(T, DB) : ES .
  eq solveUps(T :: ES, DB) = solveUps(T, DB) :: ES .
  eq solveUps((T, TL), DB) = (solveUps(T, DB), solveUps(TL, DB)) .
  eq solveUps(error*, DB) = error* .
  eq solveUps('up['token[T]], DB)
    = if unitInDatabase(downQid(T), DB)
      then up(getFlatUnit(downQid(T), DB))
      else error*
      fi .
  ceq solveUps('up[F[TL]], DB)
    = 'up[F[solveUps(TL, DB)]]
      if F =/= 'token .
  eq solveUps('up[{QI}QI'], DB) = 'up[{QI}QI'] .
  eq solveUps('up[QI], DB) = 'up[QI] .
  eq solveUps('up[T : ES], DB) = 'up[T : ES] .
  eq solveUps('up[T :: ES], DB) = 'up[T :: ES] .
  eq solveUps('up['token[T], 'bubble[T']], DB)
    = if unitInDatabase(downQid(T), DB)
      then if ((including 'UP .) 
                  in importList(getInternalTopUnit(downQid(T), DB)))
           then up(solveUps(
                     meta-parse(getSignature(downQid(T), DB), 
                       downQidList(T')), DB))
           else up(meta-parse(
                     getSignature(downQid(T), DB), downQidList(T'))) 
           fi
      else error*
      fi .
  ceq solveUps('up[F[TL], T], DB)
    = 'up[F[solveUps(TL, DB)], solveUps(T, DB)]
      if F =/= 'token .
  eq solveUps('up[{QI}QI', T], DB) = 'up[{QI}QI', solveUps(T, DB)] .
  eq solveUps('up[QI, T], DB) = 'up[QI, solveUps(T, DB)] .
  eq solveUps('up[T : ES, T'], DB) = 'up[T : ES, solveUps(T', DB)] .
  eq solveUps('up[T :: ES, T'], DB) = 'up[T :: ES, solveUps(T', DB)] .
  ceq solveUps('up[T, F[TL]], DB)
    = 'up[solveUps(T, DB), F[solveUps(TL, DB)]]
      if F =/= 'bubble .
  eq solveUps('up[T, {QI}QI'], DB) = 'up[solveUps(T, DB), {QI}QI'] .
  eq solveUps('up[T, QI], DB) = 'up[solveUps(T, DB), QI] .
  eq solveUps('up[T, T' : ES], DB) = 'up[solveUps(T, DB), T' : ES] .
  eq solveUps('up[T, T' :: ES], DB) = 'up[solveUps(T, DB), T' :: ES] .
  eq solveUps('up[T, T', TL], DB)
    = 'up[solveUps(T, DB), solveUps(T', DB), solveUps(TL, DB)] .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsubsection{Parsing the Bubbles in a Unit}

The \texttt{solveBubbles} function defined in the \texttt{UNIT-BUBBLE-PARSING}
module takes a term of sort \texttt{Unit} (a preunit in fact) and a signature,
and returns the unit resulting from the evaluation (parsing) of all the
bubbles in it. 
\begin{comment}
Note that if there is no parsing for some bubble,
\texttt{meta-parse} returns the term \texttt{error*}.
\end{comment}

\small
\begin{verbatim}
%)

fmod UNIT-BUBBLE-PARSING is
  pr BUBBLE-PARSING .
  pr DATABASE .
  pr MOVE-UP .
  pr MOVE-DOWN .
  pr EXT-SORT-TO-QID .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  vars T T' T'' : Term .
  var B : Bool .
  var M : Module .
  var DB : Database .
  var PU : Unit .
  var ES : ESort .
  var ESL : ESortList .
  var AtS : AttrSet .
  var MIL : MachineIntList .
  var QI QI' QI'' F L : Qid .
  var QIL  : QidList .
  var I : MachineInt .
  var H : Hook .
  var HL : HookList .
  var MAS : MembAxSet .
  var EqS : EquationSet .
  var RlS : RuleSet .
  var EODS : EOpDeclSet .
  var EMAS : EMembAxSet .
  var TL TL' : TermList .

***(%
\end{verbatim}
\normalsize

In the parsing of bubbles themselves, we consider three different cases: The
case of having one single bubble in which no context is considered (used to
parse bubbles in term maps in views and in the special attributes of
operators); the case of two bubbles to be parsed in the same connected
component (used for bubbles in equations and rules), and the case of one
bubble to be parsed in a specific sort (used for the bubbles appearing in the
identity element attributes in the declarations of operators, and in
membership axioms). These three cases are reduced to the case of one single
bubble without context, which is handled by the function
\texttt{solveBubbles3}.

\small
\begin{verbatim}
%)

  op solveBubbles : Term Term Module Bool Database -> Term .
  op solveBubbles2 : Term ESort Module Bool Database -> Term .

***(%
\end{verbatim}
\normalsize

The case of two bubbles, generated in the case of equations and rules, is
reduced to the case with one single bubble using the polymorphic operator
\verb~_==_~ and enclosing each of the bubbles in parentheses. Below, we shall
see how after calling this function the terms corresponding to each of the
bubbles is extracted.

\small
\begin{verbatim}
%)

  eq solveBubbles('bubble[T], 'bubble[T'], M, B, DB)
    = solveBubbles1(
        ('`( downQidList(T) '`) '== '`( downQidList(T') '`)), M, B, DB) .

***(%
\end{verbatim}
\normalsize

The case of a bubble \fbox{$T$} to be parsed in a sort $S$ is reduced to the
case with one single bubble using the qualification operators, that is,
generating a bubble of form \fbox{$T\texttt{.}S$}. 

\small
\begin{verbatim}
%)

  eq solveBubbles2('bubble[T], ES, M, B, DB)
    = solveBubbles1(
        ('`( downQidList(T) '`) conc('., eSortToQid(ES))), M, B, DB) .

***(%
\end{verbatim}
\normalsize

Since bubbles can only appear in the identity or special attributes in the
declaration of operators, in equations, membership axioms, and rules, the
evaluation of bubbles on a preunit is reduced to calls to the
\texttt{solveBubbles} functions on each of these sets of declarations.

\end{comment}

\small
\begin{verbatim}
%)

  op solveBubbles : Unit Module Bool Database -> Unit .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op solveBubbles : EquationSet Module Bool Database -> EquationSet .
  op solveBubbles : RuleSet Module Bool Database -> RuleSet .
  op solveBubbles : EMembAxSet Module Bool Database -> EMembAxSet .
  op solveBubbles : EOpDeclSet Module -> EOpDeclSet .
  op solveBubbles : AttrSet ESort Module -> AttrSet .
  op solveBubbles : HookList Module -> HookList .

  eq solveBubbles(PU, M, B, DB)
    = setOpDeclSet(
        setEquationSet(
          setMembAxSet(
            (if (PU : FUnit)
             then PU
             else setRuleSet(PU, solveBubbles(ruleSet(PU), M, B, DB))
             fi),
            solveBubbles(membAxSet(PU), M, B, DB)),
          solveBubbles(equationSet(PU), M, B, DB)),
        solveBubbles(opDeclSet(PU), M)) .

***(%
\end{verbatim}
\normalsize

To avoid the parsing ambiguities in the identity elements we add the sort of
the operator to be used as context in which doing the parsing. We assume that
the term given as identity element of an operator is in the kind of the sort
of such operator.

\small
\begin{verbatim}
%)

  eq solveBubbles(((op F : ESL -> ES [AtS] .) EODS), M)
    = ((op F : ESL -> ES [solveBubbles(AtS, ES, M)] .) 
       solveBubbles(EODS, M)) .
  eq solveBubbles((none).OpDeclSet, M) = none .

  eq solveBubbles((none).AttrSet, ES, M) = none .
  eq solveBubbles((assoc AtS), ES, M) 
    = (assoc solveBubbles(AtS, ES, M)) .
  eq solveBubbles((comm AtS), ES, M) 
    = (comm solveBubbles(AtS, ES, M)) .
  eq solveBubbles((idem AtS), ES, M) 
    = (idem solveBubbles(AtS, ES, M)) .
  eq solveBubbles((id(T) AtS), ES, M)
    = (id(solveBubbles2(T, ES, M, false, emptyDatabase)) 
       solveBubbles(AtS, ES, M)) .
  eq solveBubbles((left-id(T) AtS), ES, M)
    = (left-id(solveBubbles2(T, ES, M, false, emptyDatabase)) 
       solveBubbles(AtS, ES, M)) .
  eq solveBubbles((right-id(T) AtS), ES, M)
    = (right-id(solveBubbles2(T, ES, M, false, emptyDatabase)) 
       solveBubbles(AtS, ES, M)) .
  eq solveBubbles((strat(MIL) AtS), ES, M) 
    = (strat(MIL) solveBubbles(AtS, ES, M)) .
  eq solveBubbles((memo AtS), ES, M) 
    = (memo solveBubbles(AtS, ES, M)) .
  eq solveBubbles((prec(I) AtS), ES, M) 
    = (prec(I) solveBubbles(AtS, ES, M)) .
  eq solveBubbles((gather(QIL) AtS), ES, M) 
    = (gather(QIL) solveBubbles(AtS, ES, M)) .
  eq solveBubbles((ctor AtS), ES, M) 
    = (ctor solveBubbles(AtS, ES, M)) .
  eq solveBubbles((special(HL) AtS), ES, M)
    = (special(solveBubbles(HL, M)) solveBubbles(AtS, ES, M)) .

  eq solveBubbles((H HL), M) 
    = (solveBubbles(H, M) solveBubbles(HL, M)) .
  eq solveBubbles(id-hook(QI, QIL), M) = id-hook(QI, QIL) .
  eq solveBubbles(op-hook(QI, QI', QIL, QI''), M)
    = op-hook(QI, QI', QIL, QI'') .
  eq solveBubbles(term-hook(QI, T), M)
    = term-hook(QI, solveBubbles(T, M, false, emptyDatabase)) .

***(%
\end{verbatim}
\normalsize

Since both sides of any equation or rule have to be in the same connected
component of sorts, we parse the two bubbles together using the polymorphic
operator \verb~_==_~\footnote{Note that if including \texttt{BOOL} the
operator \texttt{\_\,==\_\,} is added for each kind.}. That is, given for
example an equation as \verb~eq T = T' .~, we parse \verb~T == T'~, forcing
them to be parsed in the same connected component, if possible. We add
functions \texttt{lhs} and \texttt{rhs} to extract, respectively, the lefthand
and righthand side terms from the result. Note that these are partial
functions.

\small
\begin{verbatim}
%)

  ops lhs rhs : Term -> Term .
  eq lhs('_==_[T, T']) = T .
  eq rhs('_==_[T, T']) = T' .
  eq lhs(error*) = error* .
  eq rhs(error*) = error* .

  eq solveBubbles(((eq T = T' .) EqS), M, B, DB)
    = ((eq lhs(solveBubbles(T, T', M, B, DB)) 
          = rhs(solveBubbles(T, T', M, B, DB)) .)
       solveBubbles(EqS, M, B, DB)) .
  eq solveBubbles(
       ((ceq T = T' if T'' = {'true}'Bool .) EqS), M, B, DB)
    = ((ceq solveBubbles(T, M, B, DB) = solveBubbles(T', M, B, DB)
          if solveBubbles2(T'', 'Bool, M, B, DB) = {'true}'Bool .)
       solveBubbles(EqS, M, B, DB)) .
  eq solveBubbles((none).EquationSet, M, B, DB) = none .

  eq solveBubbles(((rl [L] : T => T' .) RlS), M, B, DB)
    = ((rl [L] : solveBubbles(T, M, B, DB) => solveBubbles(T', M, B, DB) .)
       solveBubbles(RlS, M, B, DB)) .
  eq solveBubbles(
       ((crl [L] : T => T' if T'' = {'true}'Bool .) RlS), M, B, DB)
    = ((crl [L] : solveBubbles(T, M, B, DB) => solveBubbles(T', M, B, DB)
          if solveBubbles2(T'', 'Bool, M, B, DB) = {'true}'Bool .)
       solveBubbles(RlS, M, B, DB)) .
  eq solveBubbles((none).RuleSet, M, B, DB) = none .

***(%
\end{verbatim}
\normalsize

In the call to solve the bubbles in membership axioms we add the 
sort to which it is constrained to be used as context.

\small
\begin{verbatim}
%)

  eq solveBubbles(((mb T : ES .) EMAS), M, B, DB)
    = ((mb solveBubbles(T, M, B, DB) : ES .) 
       solveBubbles(EMAS, M, B, DB)) .
  eq solveBubbles(
       ((cmb T : ES if T' = {'true}'Bool .) EMAS), M, B, DB)
    = ((cmb solveBubbles2(T, ES, M, B, DB) : ES
          if solveBubbles2(T', 'Bool, M, B, DB) = {'true}'Bool .)
       solveBubbles(EMAS, M, B, DB)) .
  eq solveBubbles((none).MembAxSet, M, B, DB) = none .

***(%
\end{verbatim}
\normalsize

The parsing process may generate \texttt{error*} terms. Since in the current
version of the system Core Maude is generating the appropriate error messages,
we just have to worry about the elimination of these terms. The effect is the
same one as introducing a module at the object level of Core Maude: If there
is any term in an identity attribute in an operator declaration, equation,
rule, or membership axiom with a parsing error a message is generated and the
axiom is eliminated.

\small
\begin{verbatim}
%)

  eq (op F : ESL -> ES [id(error*) AtS] .) = none .
  eq (op F : ESL -> ES [left-id(error*) AtS] .) = none .
  eq (op F : ESL -> ES [right-id(error*) AtS] .) = none .
  eq (eq error* = T .) = none .
  eq (eq T = error* .) = none .
  eq (ceq error* = T if T' = T'' .) = none .
  eq (ceq T = error* if T' = T'' .) = none .
  eq (ceq T = T' if error* = T'' .) = none .
  eq (ceq T = T'' if T' = error* .) = none .
  eq (mb error* : ES .) = none .
  eq (cmb error* : ES if T' = T'' .) = none .
  eq (cmb T : ES if error* = T'' .) = none .
  eq (cmb T : ES if T' = error* .) = none .
  eq (rl [L] : error* => T .) = none .
  eq (rl [L] : T => error* .) = none .
  eq (crl [L] : error* => T if T' = T'' .) = none .
  eq (crl [L] : T => error* if T' = T'' .) = none .
  eq (crl [L] : T => T' if error* = T'' .) = none .
  eq (crl [L] : T => T'' if T' = error* .) = none .

  eq F[error*, TL] = error* .
  eq F[TL, error*] = error* .
  eq F[TL, error*, TL'] = error* .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Module Expression Evaluation}
\label{evalModExp}

So far we have not introduced more module expressions than those given
by simple quoted identifiers. We will introduce some later, but the
scheme followed for evaluating them is very simple and can be
presented in a generic way. Given a module expression and a database
state, the evaluation of a module expression results in the generation
of a new module, which is introduced in the database, with the module
expression as its name. The resulting database is then returned. If
there is already a module in the database with that name, the function
returns the original database without any change. The evaluation of a
module expression may produce the evaluation of other module
expressions contained in the modules involved in the process. This is
the case, for example, for the renaming of modules, in which not only
the top module is renamed but, perhaps, some of its submodules as
well; it is also the case for the instantiation of parameterized
modules, where the module being instantiated may contain submodules
which are parameterized by some of the parameter theories of the
parameterized module in which are imported. We shall discuss in more
detail the renaming and instantiation of module expressions in
Sections~\ref{renaming} and~\ref{instantiation}, respectively.

We saw in Section~\ref{module-expressions} how it is possible to import a
module expression in which a parameterized module is instantiated by some of
the formal parameters of the parameterized module into which it is
imported. To be able to evaluate this kind of module expression, the list of
parameters of the module in which the module expression appears has to be
given.

\small
\begin{verbatim}
%)

fmod MOD-EXPR-EVAL is
  pr DATABASE .

  op evalModExp : ModExp Database -> Database .
  op evalModExp : ModExp ParameterList Database -> Database .

  var QI : Qid .
  var ME : ModExp .
  var PL : ParameterList .
  var DB : Database .

  eq evalModExp(ME, DB) 
    = evalModExp(ME, nilParameterList, DB) .

  ceq evalModExp(QI, PL, DB) 
    = if QI inModNameSet builtIns
      then DB
      else warning(DB, ('ERROR: 'module QI 'not 'in 'database))
      fi
      if not unitInDatabase(QI, DB) .
  ceq evalModExp(ME, PL, DB) 
    = DB 
      if unitInDatabase(ME, DB) .

endfm

***(%
\end{verbatim}
\normalsize


\subsection{The Transformation of Object-Oriented Modules to System Modules}
\label{omod2modfunction}

The transformation of object-oriented modules into system modules has already
been discussed in Section~\ref{omod2mod}, and also
in~\cite{Meseguer93b,DuranMeseguer98,ClavelDuranEkerLincolnMarti-OlietMeseguerQuesada99}.
We focus here on the part of the process accomplished by each of the main
functions involved in the transformation.  

%and in the differences between this transformation and the one proposed
%initially by Jos\'e Meseguer in his 93 paper.

The transformation discussed in~\cite{DuranMeseguer98} assumed that 
object-oriented modules were flattened before being transformed into system
modules. However, doing it in this way, the transformations already made for
the modules in the structure were not reused. In the current system, the
transformation is done only for the module being introduced, the top of the
structure, and using the `internal' representations of the submodules stored
in the database for the rest of the structure.

This approach requires gathering all class and subclass relation
declarations in the structure before starting with the transformation process
itself. The function \texttt{prepareClasses} collects all these declarations
in the structure, and completes all the declarations of classes with the
attributes inherited from their superclasses. 
\begin{comment}
This function makes use of a
`dummy' module, in which the classes are introduced as sorts and the subclass
relations as subsort relations to be able to compute all the operations on the
subclass relation using the built-in functions on sorts.
\end{comment}

Once all the class declarations in the structure have been collected and
completed, the transformation is accomplished in two stages. First, the
function \texttt{objectOrientedToSystemModuleAux} carries out the following
tasks: \begin{itemize} \item For each class declaration of the form
$\texttt{class }C\texttt{ | }a_1\texttt{:} S_1\texttt{,} \ldots\texttt{,}
a_n\texttt{:} S_n$, the following items are introduced: a subsort $C$ of sort
\texttt{Cid}, a constant $C$ of sort $C$, and declarations of operations $a_i
\texttt{\ :\_} \texttt{ :\,\,} S_i \texttt{ -> Attribute}$ for each attribute
$a_i$ (the function \texttt{attributeOpDeclSet} creates these declarations).
\item For each subclass relation of the form $\texttt{subclass\ }C\texttt{\ <\
}C'$, a subsort declaration $\texttt{subsort\ }C\texttt{\ <\ }C'$ is
introduced.  \item For each message declaration of the form 
\verb~msg F : ESL -> ES~, an operator declaration \verb~op F : ESL -> ES~ is
added.  \end{itemize} When this process has been completed, the function
\texttt{prepareAxioms} is called.  This function applies to the membership
axioms, equations, and rewriting rules in the module the transformations
indicated in Section~\ref{omod2mod}, so that they become applicable to all the
objects of the given class and of their subclasses. The set of attributes of
the objects appearing in the membership axioms, equations, and rewriting rules
are completed, so that the default convention of not having to exhaustively
mention the set of attributes of a class is supported.

Note that in Meseguer's paper~\cite{Meseguer93b} a parallel hierarchy of sorts
was defined to deal with objects in different classes, and membership axioms
constraining the objects to their corresponding sorts were added. The
transformation could be easily completed with sorts, subsort relations, and
membership constraints as indicated there. In fact, these declarations were
added in an initial version and were then removed because they were
computationally expensive. However, there are examples in which it would be
interesting to have them; when needed, these declarations can be explicitly
added by the user in the current version.

\small
\begin{verbatim}
%)

fmod O-O-TO-SYSTEM-MOD-TRANSF is
  pr DATABASE .
  pr VBLE-RENAMING .
  pr DECL-EXT-SORT-TO-QID .

  var DB : Database .
  var I : MachineInt .
  var MN : ModName .
  var F : Qid .
  vars ES C C' : ESort .
  var ESS : ESortSet .
  var ESL : ESortList .
  vars T T' T'' T''' : Term .
  var PL : ParameterList .
  vars EIL EIL' EIL'' : EImportList .
  var ESD : ESortDecl .
  vars CDS CDS' : ClassDeclSet .
  var ADS : AttrDeclSet .
  var ESSDS : ESubsortDeclSet .
  var SCDS : SubclassDeclSet .
  var EODS : EOpDeclSet .
  var MDS : MsgDeclSet .
  var EVDS : EVarDeclSet .
  vars EMAS EMAS' : EMembAxSet .
  vars EqS EqS' : EquationSet .
  vars RlS RlS' : RuleSet .
  var QIL : QidList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var SS : QidSet .
  var SSDS : SubsortDeclSet .
  vars TL TL' : TermList .
  var EVDS' : EVarDeclSet .
  vars O O' : Term .
  var U : Unit .
  var M : Module .
  vars QI A A' V S S' S'' L : Qid .
  var SCDS' : SubclassDeclSet .
  var ADS' : AttrDeclSet .
  var CD : ClassDecl .
  vars SCD SCD' : SubclassDecl .

***(%
\end{verbatim}
\normalsize

\end{comment}

The function \texttt{prepareClasses} completes all classes in the module with
all the attributes they inherit from their superclasses.

\small
\begin{verbatim}
%)

  op prepareClasses : ESortSet ESubsortDeclSet
       ClassDeclSet SubclassDeclSet EImportList Database -> ClassDeclSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op prepareClasses2 : QidSet SubsortDeclSet ClassDeclSet SubclassDeclSet 
        EImportList EImportList EImportList Database -> ClassDeclSet .
  op prepareClasses3 : ClassDeclSet SubclassDeclSet ClassDeclSet 
        SubclassDeclSet Module -> ClassDeclSet .
  op prepareClasses4 : 
        ClassDeclSet ClassDeclSet SubclassDeclSet Module -> ClassDeclSet .
  op maximalClass : ClassDecl ClassDeclSet Module -> Bool .
  op getDirectAncestors : 
          ClassDecl ClassDeclSet SubclassDeclSet -> ClassDeclSet .
  op inSubclassDeclSet : SubclassDecl SubclassDeclSet -> Bool .
  op addAttributes : ClassDeclSet ClassDecl -> ClassDecl .
  op addAttributesAux : AttrDeclSet AttrDeclSet -> AttrDeclSet .
  op inAttrDeclSet : Qid AttrDeclSet -> Bool .

  eq prepareClasses(ESS, ESSDS, CDS, SCDS, EIL, DB)
    = prepareClasses2(eSortToQid(ESS), eSortToQid(ESSDS), 
         CDS, SCDS, EIL, nil, nil, DB) .

  eq prepareClasses2(SS, SSDS, CDS, SCDS, 
        ((including MN .) EIL), EIL', EIL'', DB)
    = if MN inModNameSet builtIns
      then prepareClasses2(SS, SSDS, CDS, SCDS, 
              EIL, EIL', ((including MN .) EIL''), DB)
      else if (including MN . ) in EIL' 
           then prepareClasses2(SS, SSDS, CDS, SCDS, EIL, EIL', EIL'', DB)
           else prepareClasses2(
                   (eSortToQid(sortSet(sortDecl(getTopUnit(MN, DB)))) ; SS), 
                   (eSortToQid(subsortDeclSet(getTopUnit(MN, DB))) SSDS),
                   (classDeclSet(getTopUnit(MN, DB)) CDS), 
                   (subclassDeclSet(getTopUnit(MN, DB)) SCDS), 
                   (importList(getTopUnit(MN, DB)) EIL), 
                   ((including MN .) EIL'), EIL'', DB)
           fi
      fi .

***(
  ceq prepareClasses2(ESS, ESSDS, CDS, SCDS, ((including MN .) EIL), EIL', DB)
    = prepareClasses2(ESS, ESSDS, CDS, SCDS, EIL, EIL', DB)
      if (including MN . ) in EIL' .
  ceq prepareClasses2(ESS, ESSDS, CDS, SCDS, ((including MN .) EIL), EIL', DB)
    = prepareClasses2(ESS, ESSDS, 
        (classDeclSet(getTopUnit(MN, DB)) CDS), 
        (subclassDeclSet(getTopUnit(MN, DB)) SCDS), 
        (importList(getTopUnit(MN, DB)) EIL), 
        ((including MN .) EIL'), DB)
      if not ((including MN .) in EIL') .
)
  eq prepareClasses2(ESS, ESSDS, CDS, SCDS, nil, EIL, EIL', DB)
    = prepareClasses3(CDS, SCDS, CDS, SCDS, 
         setImportList(
            setSortDecl(
               setSubsortDeclSet(
                  emptyFModule('DUMMY), ESSDS), (sorts ESS .)), EIL')) .

  eq prepareClasses3(CDS, SCDS, ((class C | ADS .) CDS'), SCDS', M)
    = prepareClasses3(CDS, SCDS, CDS', SCDS', 
        setSortDecl(M, (sorts sortSet(sortDecl(M)) ; eSortToSort(C) .))) .
  eq prepareClasses3(CDS, SCDS, CDS', ((subclass C < C' .) SCDS'), M)
    = prepareClasses3(CDS, SCDS, CDS', SCDS', 
        addSubsortDeclSet((subsort eSortToSort(C) < eSortToSort(C') .), M)) .
  eq prepareClasses3(CDS, SCDS, none, none, M)
    = prepareClasses4(CDS, none, SCDS, M) .

  ceq prepareClasses4((CD CDS), CDS', SCDS, M)
    = prepareClasses4(CDS, 
        (addAttributes(getDirectAncestors(CD, CDS', SCDS), CD) CDS'), 
        SCDS, M)
      if maximalClass(CD, CDS, M) .
  eq prepareClasses4(none, CDS, SCDS, M) = CDS .

  eq maximalClass((class C | ADS .), ((class C' | ADS' .) CDS), M)
    = (not sortLeq(M, eSortToSort(C), eSortToSort(C')))
       and-then maximalClass((class C | ADS .), CDS, M) .
  eq maximalClass(CD, none, M) = true .

  eq getDirectAncestors((class C | ADS .), ((class C' | ADS' .) CDS), SCDS)
    = if inSubclassDeclSet((subclass C < C' .), SCDS)
      then ((class C' | ADS' .)
            getDirectAncestors((class C | ADS .), CDS, SCDS))
      else getDirectAncestors((class C | ADS .), CDS, SCDS)
      fi .
  eq getDirectAncestors(CD, none, SCDS) = none .
  eq getDirectAncestors(CD, CDS, none) = none .

  eq addAttributes(((class C | ADS .) CDS), (class C' | ADS' .))
    = addAttributes(CDS, (class C' | addAttributesAux(ADS, ADS') .)) .
  eq addAttributes(none, CD) = CD .

  eq addAttributesAux(((attr A : ES), ADS), ADS')
    = if inAttrDeclSet(A, ADS')
      then addAttributesAux(ADS, ADS')
      else addAttributesAux(ADS, ((attr A : ES), ADS'))
      fi .
  eq addAttributesAux(none, ADS) = ADS .

  eq inAttrDeclSet(A, ((attr A' : ES), ADS))
    = (A == A') or-else inAttrDeclSet(A, ADS) .
  eq inAttrDeclSet(A, none) = false .

  eq inSubclassDeclSet(SCD, (SCD' SCDS))
    = (SCD == SCD') or-else inSubclassDeclSet(SCD, SCDS) .
  eq inSubclassDeclSet(SCD, none) = false .

***(%
\end{verbatim}
\normalsize

\end{comment}

Given a set of attribute declarations, the \texttt{attributeOpDeclSet}
function returns a set of operator declarations as indicated above. That is,
for each attribute $a\texttt{:} S$, an operator of the form
$a \texttt{\ :\_} \texttt{ :\,\,} S \texttt{ -> Attribute}$ is declared.

\small
\begin{verbatim}
%)

  op attributeOpDeclSet : AttrDeclSet -> OpDeclSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq attributeOpDeclSet(((attr A : ES), ADS))
    = ((op conc(A, '`:_) : ES -> 'Attribute [gather('&)] .)
       attributeOpDeclSet(ADS)) .
  eq attributeOpDeclSet(none) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

The function \texttt{prepareLHS} takes the term in the lefthand side of a
rule, equation, or membership axiom, and replaces each object 
$\texttt{<\ }O\texttt{\ :\ }C\texttt{\ |\ }ADS\texttt{\ >}$ in it---with $O$
of sort \texttt{Oid}, $C$ the name of a class, and $ADS$ a set of
attributes with their corresponding values---by an object 
$\texttt{<\ }O\texttt{\ :\ }V\texttt{\ |\ }ADS\ ADS'\ Atts\texttt{\ >}$ where
the identifier of the class is replaced by a variable $V$ of sort $C$, which is
not used in the axiom, and where the set of attributes is completed with
attributes $ADS'$ as indicated in Section~\ref{omod2mod}, so that each
attribute declared in class $C$ or in any of its superclasses is added with a
new variable as value. $Atts$ is a new variable of sort \texttt{AttributeSet},
which is used to range over the additional attributes that may appear in
objects of a subclass.

The function \texttt{prepareLHS} takes as arguments a term (in the initial
call, the term in the lefthand side of a rule, equation, or membership axiom),
the set of variable declarations of those variables declared in the module
that are not used in the axiom---new variables are created only if there are
no variables in the module with the appropriate sort---the set of class
declarations in the module---to be able to complete the set of attributes in
the occurrences of the objects---and an index---to make sure that the
variables being added have not been added previously. In the initial call this
index is set to zero. \texttt{prepareLHS} gives as result a tuple composed of
the resulting term, the set of objects in the term (so that the modification
of the objects in the righthand side of the rule is simplified), the set of
variable declarations corresponding to the new added variables, the set of
variable declarations of the variables in the module that have not been used,
and the index for the creation of new variables.

The set of objects in the lefthand side will be given as a set of terms. The
sort \texttt{TermSet} is defined as a supersort of the sort \texttt{Term}, and
with constructors \texttt{emptyTermSet} and \texttt{termSet} as follows.

\small
\begin{verbatim}
%)

  sort TermSet .
  subsort Term < TermSet .
  op emptyTermSet : -> TermSet .
  op termSet : TermSet TermSet -> TermSet 
        [comm assoc id: emptyTermSet] .

***(%
\end{verbatim}
\normalsize

Terms of sort \texttt{PrepareLHSResult} are built with constructor
\verb~<_;_;_;_;_>~, and have selectors for their different components.

\small
\begin{verbatim}
%)

  sort PrepareLHSResult .
  op <_;_;_;_;_;_> : TermList TermSet EVarDeclSet EVarDeclSet MachineInt QidList
       -> PrepareLHSResult .
  op term : PrepareLHSResult -> TermList .
  op objects : PrepareLHSResult -> TermSet .
  op oldVbles : PrepareLHSResult -> EVarDeclSet .
  op newVbles : PrepareLHSResult -> EVarDeclSet .
  op index : PrepareLHSResult -> MachineInt .
  op messages : PrepareLHSResult -> QidList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var TS TS' : TermSet .

  eq term(< TL ; TS ; EVDS ; EVDS' ; I ; QIL >) = TL .
  eq objects(< TL ; TS ; EVDS ; EVDS' ; I ; QIL >) = TS .
  eq newVbles(< TL ; TS ; EVDS ; EVDS' ; I ; QIL >) = EVDS .
  eq oldVbles(< TL ; TS ; EVDS ; EVDS' ; I ; QIL >) = EVDS' .
  eq index(< TL ; TS ; EVDS ; EVDS' ; I ; QIL >) = I .
  eq messages(< TL ; TS ; EVDS ; EVDS' ; I ; QIL >) = QIL .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op prepareLHS : TermList EVarDeclSet ClassDeclSet MachineInt 
       -> PrepareLHSResult .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op createObject : Term ESort AttrDeclSet 
        PrepareLHSResult -> PrepareLHSResult .
  op createObject2 : Term Qid TermList TermList AttrDeclSet TermSet 
        EVarDeclSet EVarDeclSet MachineInt QidList -> PrepareLHSResult .
  op createObject3 : Term Qid TermList AttrDeclSet TermSet 
        EVarDeclSet EVarDeclSet MachineInt QidList -> PrepareLHSResult .

  eq prepareLHS(error*, EVDS, CDS, I)
    = < error* ; emptyTermSet ; none ; EVDS ; I ; nil > .
  eq prepareLHS(F, EVDS, CDS, I)
    = < F ; emptyTermSet ; none ; EVDS ; I ; nil > .
  eq prepareLHS({F}S, EVDS, CDS, I)
    = < {F}S ; emptyTermSet ; none ; EVDS ; I ; nil > .

***(%
\end{verbatim}
\normalsize

\texttt{prepareLHS} on a list of terms $\texttt{(}T\texttt{,\ }TL\texttt{)}$,
with $T$ a term and $TL$ a list of terms, has to make a call to itself with $T$
and with $TL$. The call with $TL$ has to be made with the result of the call
with $T$ so that the variables and the index are right.

\small
\begin{verbatim}
%)

  eq prepareLHS((T, TL), EVDS, CDS, I)
    = < (term(prepareLHS(T, EVDS, CDS, I)),
         term(prepareLHS(
                TL, oldVbles(prepareLHS(T, EVDS, CDS, I)), 
                CDS, index(prepareLHS(T, EVDS, CDS, I))))) ;
        termSet(objects(prepareLHS(T, EVDS, CDS, I)),
                objects(prepareLHS(
                          TL, oldVbles(prepareLHS(T, EVDS, CDS, I)), 
                          CDS, index(prepareLHS(T, EVDS, CDS, I))))) ;
        (newVbles(prepareLHS(T, EVDS, CDS, I))
         newVbles(prepareLHS(
                    TL, oldVbles(prepareLHS(T, EVDS, CDS, I)), 
                    CDS, index(prepareLHS(T, EVDS, CDS, I))))) ;
        oldVbles(prepareLHS(
                   TL, oldVbles(prepareLHS(T, EVDS, CDS, I)), 
                   CDS, index(prepareLHS(T, EVDS, CDS, I)))) ;
        index(prepareLHS(
                TL, oldVbles(prepareLHS(T, EVDS, CDS, I)), 
                CDS, index(prepareLHS(T, EVDS, CDS, I)))) ;
        (messages(prepareLHS(T, EVDS, CDS, I))
         messages(prepareLHS(
                     TL, oldVbles(prepareLHS(T, EVDS, CDS, I)), 
                     CDS, index(prepareLHS(T, EVDS, CDS, I))))) > .
  ceq prepareLHS(F[TL], EVDS, CDS, I)
    = < F[term(prepareLHS(TL, EVDS, CDS, I))] ;
        objects(prepareLHS(TL, EVDS, CDS, I)) ;
        newVbles(prepareLHS(TL, EVDS, CDS, I)) ;
        oldVbles(prepareLHS(TL, EVDS, CDS, I)) ;
        index(prepareLHS(TL, EVDS, CDS, I)) ;
        messages(prepareLHS(TL, EVDS, CDS, I)) >
      if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  ceq prepareLHS('<_:_|_>[O, {QI}S, T], EVDS, ((class C | ADS .) CDS), I)
    = createObject(O, C, ADS, prepareLHS(T, EVDS, ((class C | ADS .) CDS), I)) 
      if QI == eSortToQid(C) .
  eq prepareLHS('<_:_|_>[O, V, T], EVDS, CDS, I)
    = < '<_:_|_>[O, V, T] ; emptyTermSet ; none ; EVDS ; I ; nil > .
  ceq prepareLHS('<_:_|`>[O, {QI}S], EVDS, ((class C | ADS .) CDS), I)
    = createObject(O, C, ADS, 
        prepareLHS({'none}'AttributeSet, EVDS, ((class C | ADS .) CDS), I))
      if QI == eSortToQid(C) .
  eq prepareLHS('<_:_|`>[O, V], EVDS, CDS, I)
    = < '<_:_|_>[O, V, {'none}'AttributeSet] ; 
        emptyTermSet ; none ; EVDS ; I ; nil > .

  ceq createObject(O, C, ADS, < T ; TS ; EVDS ; EVDS' ; I ; QIL >) 
    = createObject2(O, index(qualifyVar('V, C), I), 
        T, {'none}'AttributeSet, ADS, TS, 
        ((var index(qualifyVar('V, C), I) : C .) 
         EVDS), 
        EVDS', (I + 1), QIL)
      if not isThereVbleOfSort(EVDS', C) .
  eq createObject(O, C, ADS, 
        < T ; TS ; EVDS ; ((var V : C .) EVDS') ; I ; QIL >)
    = createObject2(O, V, T, {'none}'AttributeSet, 
         ADS, TS, EVDS, EVDS', I, QIL) .

***(%
\end{verbatim}
\normalsize

The function \texttt{createObject2} is called with the metarepresentation of
the list of attributes appearing in the current object (third argument) and
the set of attribute declarations of the class to which such object belongs
plus all the attributes declared in its superclasses (fifth argument). The
function proceeds recursively removing the attribute declarations from the set
of declarations of attributes for those attributes that appear in the
object. Each time an attribute is found, it is passed with its actual value to
the fourth argument of \texttt{createObject2}, which initially has value
\verb~{'none}'AttributeSet~, composing a list of terms with them.

We assume that:
\begin{itemize}
\item 
The metarepresentation of a list of attributes is always given with form
\verb~'_`,_[F[T], T]~, \verb~F[T]~, or \verb~{'none}'AttributeSet~, where
\texttt{TL} is the metarepresentation of a list of attributes with the same
form (this is ensured by the \verb~(e E)~ gathering pattern in the
corresponding declaration in the signature in which the parsing is done), and
\item 
that all the attributes appearing in an object have been declared in the
corresponding class declaration or in one of its superclasses.
\end{itemize}

\small
\begin{verbatim}
%)

  eq createObject2(O, C, '_`,_[F[T], TL], TL', ADS, TS, EVDS, EVDS', I, QIL)
    = createObject2(O, C, (F[T], TL), TL', ADS, TS, EVDS, EVDS', I, QIL) .

  ceq createObject2(O, C, (F[T], TL), TL', 
       ((attr A : ES), ADS), TS, EVDS, EVDS', I, QIL)
    = createObject2(O, C, TL, (F[T], TL'), ADS, TS, EVDS, EVDS', I, QIL)
      if conc(A, '`:_) == F .
  ceq createObject2(O, C, (F[T], TL), TL', ADS, TS, EVDS, EVDS', I, QIL)
    = createObject2(O, C, TL, TL', ADS, TS, EVDS, EVDS', I, 
         (QIL 'WARNING: 'Attribute F 'not 'valid '\n))
      if not inAttrDeclSet(F, ADS) .
  ceq createObject2(O, C, F[T], TL, 
       ((attr A : ES), ADS), TS, EVDS, EVDS', I, QIL)
    = createObject3(O, C, (F[T], TL), ADS, TS, EVDS, EVDS', I, QIL)
      if conc(A, '`:_) == F .
  ceq createObject2(O, C, F[T], TL, ADS, TS, EVDS, EVDS', I, QIL)
    = createObject3(O, C, TL, ADS, TS, EVDS, EVDS', I,
         (QIL 'WARNING: 'Attribute F 'not 'valid '\n))
      if not inAttrDeclSet(F, ADS) .

  eq createObject2(O, C, {'none}'AttributeSet, TL, 
       ADS, TS, EVDS, EVDS', I, QIL) 
    = createObject3(O, C, TL, ADS, TS, EVDS, EVDS', I, QIL) .

***(%
\end{verbatim}
\normalsize

When \texttt{createObject2} has gone through all the attributes in the current
object, the function \texttt{createObject3} is in charge of returning the
metarepresentation of the current object completed with the attributes that
did not appear in it. These attributes are added with new variables not used
in the axiom as value. \texttt{createObject3} returns a four-tuple composed by
this resulting object, the set of terms representing all the objects in the
lefthand side (the current object is added to this set), the set of the
variables that have been defined, and the set of variables in the module that
have not been used yet.

\small
\begin{verbatim}
%)

  eq createObject3(O, C, TL, 
       ((attr A : ES), ADS), TS, EVDS, ((var V : ES .) EVDS'), I, QIL)
    = createObject3(O, C, (conc(A, '`:_)[V], TL), 
         ADS, TS, EVDS, EVDS', I, QIL) .
  ceq createObject3(O, C, TL, ((attr A : ES), ADS), TS, EVDS, EVDS', I, QIL)
    = createObject3(O, C, 
        (conc(A, '`:_)[conc(eSortToQid(ES), index('@, I))], TL), ADS, TS, 
        ((var conc(eSortToQid(ES), index('@, I)) : ES .) EVDS), 
        EVDS', (I + 1), QIL)
      if not isThereVbleOfSort(EVDS', ES) .
  eq createObject3(
       O, C, TL, none, TS, EVDS, ((var V : 'AttributeSet .) EVDS'), I, QIL)
    = < '<_:_|_>[O, C, '_`,_[TL, V]] ;
        termSet('<_:_|_>[O, C, '_`,_[TL, V]], TS) ; EVDS ; EVDS' ; I ; QIL > .
  ceq createObject3(O, C, TL, none, TS, EVDS, EVDS', I, QIL)
    = < '<_:_|_>[O, C, '_`,_[TL, index('ATTS@, I)]] ; 
        termSet('<_:_|_>[O, C, '_`,_[TL, index('ATTS@, I)]], TS) ;
        ((var index('ATTS@, I) : 'AttributeSet .) EVDS) ; 
        EVDS' ; (I + 1) ; QIL >
      if not isThereVbleOfSort(EVDS', 'AttributeSet) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

Once the lefthand side of a rule or equation has been `prepared', the function
\texttt{prepareRHS} is called with the set of objects returned by
\texttt{prepareLHS} and the term in the righthand side of such rule or
equation. The function \texttt{prepareRHS} proceeds recursively throughout the
term looking for objects. Each time an object is found, its set of attributes
is completed with those in the modified object of the lefthand side which do
not appear in it.  

\small
\begin{verbatim}
%)

  op prepareRHS : TermSet TermList -> TermList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op adjustObject : TermSet Term -> Term .

  op adjustObjectRHS : TermSet Term -> Term .
  op adjustAttributesObjectRHS : Term Term -> Term .
  op adjustAttributesObjectRHSAux : TermSet Term -> Term .

  op termAttrListToTermSet : TermList -> TermSet .
  op _attrInTermSet_ : Qid TermSet -> Bool .

  eq prepareRHS(TS, error*) = error* .
  eq prepareRHS(TS, F) = F .
  eq prepareRHS(TS, {F}S) = {F}S .
  eq prepareRHS(TS, T : ES)
    = prepareRHS(TS, T) : ES .
  eq prepareRHS(TS, T :: ES)
    = prepareRHS(TS, T) :: ES .
  ceq prepareRHS(TS, F[TL])
    = F[prepareRHS(TS, TL)]
      if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq prepareRHS(TS, '<_:_|_>[O, {C}S, T])
    = adjustObjectRHS(TS, '<_:_|_>[O, {C}S, prepareRHS(TS, T)]) .
  eq prepareRHS(TS, '<_:_|_>[O, V, T])
    = '<_:_|_>[O, V, prepareRHS(TS, T)] .
  eq prepareRHS(TS, '<_:_|`>[O, {C}S])
    = adjustObjectRHS(TS, 
        '<_:_|_>[O, {C}S, prepareRHS(TS, {'none}'AttributeSet)]) .
  eq prepareRHS(TS, '<_:_|`>[O, V])
    = '<_:_|_>[O, V, prepareRHS(TS, {'none}'AttributeSet)] .
  eq prepareRHS(TS, (T, TL))
    = (prepareRHS(TS, T), prepareRHS(TS, TL)) .

  eq adjustObjectRHS(termSet('<_:_|_>[O, C, T], TS), 
       '<_:_|_>[O', {C'}S, T'])
    = if O == O'
      then '<_:_|_>[O, C, adjustAttributesObjectRHS(T, T')]
      else adjustObjectRHS(TS, '<_:_|_>[O', {C'}S, T'])
      fi .
  eq adjustObjectRHS(termSet('<_:_|_>[O, C, T], TS), 
       '<_:_|_>[{O'}S, {C'}S', T'])
    = adjustObjectRHS(TS, '<_:_|_>[{O'}S, {C'}S', T']) .
  eq adjustObjectRHS(termSet('<_:_|_>[{O}S, C, T], TS), 
       '<_:_|_>[O', {C'}S', T'])
    = adjustObjectRHS(TS, '<_:_|_>[O', {C'}S', T']) .
  eq adjustObjectRHS(termSet('<_:_|_>[{O}S, C, T], TS), 
       '<_:_|_>[{O'}S', {C'}S'', T'])
    = if {O}S == {O'}S'
      then '<_:_|_>[{O}S, C, adjustAttributesObjectRHS(T, T')]
      else adjustObjectRHS(TS, '<_:_|_>[{O'}S', {C'}S'', T'])
      fi .
  eq adjustObjectRHS(emptyTermSet, '<_:_|_>[{O}S, {C}S', T])
    = '<_:_|_>[{O}S, {C}S', T] .
  eq adjustObjectRHS(emptyTermSet, '<_:_|_>[O, {C}S, T])
    = '<_:_|_>[O, {C}S, T] .

***(%
\end{verbatim}
\normalsize

The function \texttt{adjustAttributesObjectRHS} completes the set of
attributes of an object in the righthand side with those in the object in the
lefthand side or in the class not used in the lefthand side, which have been
completed by the function \texttt{createObject}.

\small
\begin{verbatim}
%)

  eq adjustAttributesObjectRHS('_`,_[TL], T)
    = adjustAttributesObjectRHSAux(termAttrListToTermSet(TL), T) .

  eq adjustAttributesObjectRHSAux(termSet(A[T], TS), '_`,_[A[T'], T''])
    = '_`,_[A[T'], adjustAttributesObjectRHSAux(TS, T'')] .
  ceq adjustAttributesObjectRHSAux(TS, '_`,_[A[T], T'])
    = error* 
      if not A attrInTermSet TS .
  eq adjustAttributesObjectRHSAux(termSet(A[T], TS), A[T'])
    = '_`,_[A[T'], adjustAttributesObjectRHSAux(TS, {'none}'AttributeSet)] .
  ceq adjustAttributesObjectRHSAux(TS, A[T])
    = error* 
      if not A attrInTermSet TS .
  eq adjustAttributesObjectRHSAux(termSet(A[T], TS), {'none}'AttributeSet)
    = '_`,_[A[T], adjustAttributesObjectRHSAux(TS, {'none}'AttributeSet)] .
  eq adjustAttributesObjectRHSAux(V, {'none}'AttributeSet) = V .

  eq A attrInTermSet termSet(V, TS)
    = A attrInTermSet TS .
  eq A attrInTermSet termSet(A'[T], TS)
    = (A == A') or-else (A attrInTermSet TS) .
  eq A attrInTermSet emptyTermSet
    = false .

  eq termAttrListToTermSet((T, TL))
    = if T == {'none}'AttributeSet
      then termAttrListToTermSet(TL)
      else termSet(T, termAttrListToTermSet(TL))
      fi .
  eq termAttrListToTermSet(T)
    = if T == {'none}'AttributeSet
      then emptyTermSet
      else T 
      fi .

***(%
\end{verbatim}
\normalsize

\end{comment}

In the case of equations and rules, the function
\texttt{prepareAxioms} calls the function \texttt{prepareLHS} with the
term in the lefthand side of the axiom, and then use the generated set
of objects to call the \texttt{prepareRHS} function. For conditional
equations, rules, and membership axioms, this set of terms
representing the objects in the lefthand side is also used in the
calls to \texttt{prepareRHS} with each of the terms in the
conditions. The term in the lefthand side of the equation, rule, or
membership axiom is replaced by the term returned by
\texttt{prepareLHS}. The variables generated are added to the
variables in the module, and the index is used in the recursive calls
to \texttt{prepareAxioms}.

\texttt{prepareLHS} returns as second argument the set of objects (as a set of
terms) appearing in it. These objects are returned after extending their set
of attributes by those of the class to which they belong not already
specified.

\small
\begin{verbatim}
%)

  op prepareAxioms : Unit EMembAxSet EquationSet RuleSet 
       ClassDeclSet MachineInt QidList -> Unit .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq prepareAxioms(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, 
       ((mb T : ES .) EMAS'), EqS', RlS', CDS, I, QIL)
    = prepareAxioms(
        mod MN is
           PL EIL ESD ESSDS EODS
           (EVDS newVbles(
                   prepareLHS(T, 
                     varDeclSetDiff(EVDS, 
                       varDeclSetInTerm(EVDS, T)),
                     CDS, I)))
           ((mb term(
                 prepareLHS(T, varDeclSetDiff(EVDS, varDeclSetInTerm(EVDS, T)),
                   CDS, I)) : ES .) EMAS) 
           EqS RlS
        endm,
        EMAS', EqS', RlS', CDS, 
        index(
          prepareLHS(T, varDeclSetDiff(EVDS, varDeclSetInTerm(EVDS, T)), 
            CDS, I)), 
        (QIL messages(
                prepareLHS(T, varDeclSetDiff(EVDS, varDeclSetInTerm(EVDS, T)), 
                   CDS, I)))) .
  eq prepareAxioms(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, 
       ((cmb T : ES if T' = T'' .) EMAS'), EqS', RlS', CDS, I, QIL)
    = prepareAxioms(
        mod MN is 
           PL EIL ESD ESSDS EODS
           (EVDS newVbles(
                   prepareLHS(T, 
                     varDeclSetDiff(EVDS, varDeclSetInTerm(EVDS, T)), CDS, I)))
           ((cmb term(
                 prepareLHS(T, varDeclSetDiff(EVDS, varDeclSetInTerm(EVDS, T)),
                   CDS, I)) : ES
               if prepareRHS(
                    objects(
                      prepareLHS(T, 
                        varDeclSetDiff(EVDS, varDeclSetInTerm(EVDS, T)), 
                        CDS, I)), T')
                  = prepareRHS(
                      objects(
                        prepareLHS(T, 
                          varDeclSetDiff(EVDS, varDeclSetInTerm(EVDS, T)), 
                          CDS, I)), T'') .) EMAS)
           EqS RlS
        endm,  
        EMAS', EqS', RlS', CDS, 
        index(
          prepareLHS(T, varDeclSetDiff(EVDS, varDeclSetInTerm(EVDS, T)), 
            CDS, I)), 
        (QIL messages(
                prepareLHS(T, varDeclSetDiff(EVDS, varDeclSetInTerm(EVDS, T)), 
                   CDS, I)))) .
  eq prepareAxioms(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, 
       EMAS', ((eq T = T' .) EqS'), RlS', CDS, I, QIL)
    = prepareAxioms(
        mod MN is
           PL EIL ESD ESSDS EODS
           (EVDS newVbles(
                   prepareLHS(T, 
                     varDeclSetDiff(EVDS, 
                       (varDeclSetInTerm(EVDS, T) varDeclSetInTerm(EVDS, T'))),
                     CDS, I)))
           EMAS 
           ((eq term(
                  prepareLHS(T, 
                    varDeclSetDiff(EVDS, 
                      (varDeclSetInTerm(EVDS, T) varDeclSetInTerm(EVDS, T'))), 
                    CDS, I))
               = prepareRHS(
                   objects(
                     prepareLHS(T, 
                       varDeclSetDiff(EVDS, 
                         (varDeclSetInTerm(EVDS, T) 
                          varDeclSetInTerm(EVDS, T'))), 
                       CDS, I)), 
                    T') .) EqS)
            RlS
        endm,
        EMAS', EqS', RlS', CDS, 
        index(
          prepareLHS(T, 
            varDeclSetDiff(EVDS, 
              (varDeclSetInTerm(EVDS, T) varDeclSetInTerm(EVDS, T'))), 
            CDS, I)), 
        (QIL messages(
                prepareLHS(T, 
                   varDeclSetDiff(EVDS, 
                      (varDeclSetInTerm(EVDS, T) varDeclSetInTerm(EVDS, T'))), 
                   CDS, I)))) .

***(%
\end{verbatim}
\normalsize

\end{comment}

We illustrate the process presenting the equation corresponding to the case of
conditional equations.

\small
\begin{verbatim}
%)

  eq prepareAxioms(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, 
       EMAS', ((ceq T = T' if T'' = T''' .) EqS'), RlS', CDS, I, QIL)
    = prepareAxioms(
        mod MN is 
           PL EIL ESD ESSDS EODS
           (EVDS newVbles(
                   prepareLHS(T, 
                     varDeclSetDiff(EVDS, 
                       (varDeclSetInTerm(EVDS, T) 
                        varDeclSetInTerm(EVDS, T'))),
                     CDS, I)))
           EMAS 
           ((ceq term(
                   prepareLHS(T, 
                     varDeclSetDiff(EVDS, 
                       (varDeclSetInTerm(EVDS, T) 
                        varDeclSetInTerm(EVDS, T'))), 
                     CDS, I))
               = prepareRHS(
                   objects(
                     prepareLHS(T, 
                       varDeclSetDiff(EVDS, 
                         (varDeclSetInTerm(EVDS, T) 
                          varDeclSetInTerm(EVDS, T'))), 
                       CDS, I)), 
                   T')
               if prepareRHS(
                    objects(
                      prepareLHS(T, 
                        varDeclSetDiff(EVDS, 
                          (varDeclSetInTerm(EVDS, T) 
                           varDeclSetInTerm(EVDS, T'))), 
                        CDS, I)), T'')
                  = prepareRHS(
                      objects(
                        prepareLHS(T, 
                          varDeclSetDiff(EVDS, 
                            (varDeclSetInTerm(EVDS, T) 
                             varDeclSetInTerm(EVDS, T'))), 
                          CDS, I)), T''') .) EqS)
            RlS
        endm,  
        EMAS', EqS', RlS', CDS, 
        index(
          prepareLHS(T, 
            varDeclSetDiff(EVDS, 
              (varDeclSetInTerm(EVDS, T) varDeclSetInTerm(EVDS, T'))), 
            CDS, I)), 
        (QIL messages(
                prepareLHS(T, 
                  varDeclSetDiff(EVDS, 
                    (varDeclSetInTerm(EVDS, T) varDeclSetInTerm(EVDS, T'))), 
                  CDS, I)))) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq prepareAxioms(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, 
       EMAS', EqS', ((rl [L] : T => T' .) RlS'), CDS, I, QIL)
    = prepareAxioms(
        mod MN is
           PL EIL ESD ESSDS EODS
           (EVDS newVbles(
                   prepareLHS(T, 
                     varDeclSetDiff(EVDS, 
                       (varDeclSetInTerm(EVDS, T) 
                        varDeclSetInTerm(EVDS, T'))),
                     CDS, I)))
           EMAS EqS
           ((rl [L] : 
               term(
                 prepareLHS(T, 
                   varDeclSetDiff(EVDS, 
                     (varDeclSetInTerm(EVDS, T) 
                      varDeclSetInTerm(EVDS, T'))), 
                   CDS, I))
               => prepareRHS(
                    objects(
                      prepareLHS(T, 
                        varDeclSetDiff(EVDS, 
                          (varDeclSetInTerm(EVDS, T) 
                           varDeclSetInTerm(EVDS, T'))), 
                        CDS, I)), 
                    T') .)
            RlS)
        endm,
        EMAS', EqS', RlS', CDS, 
        index(
          prepareLHS(T, 
            varDeclSetDiff(EVDS, 
              (varDeclSetInTerm(EVDS, T) 
               varDeclSetInTerm(EVDS, T'))), 
            CDS, I)), 
        (QIL messages(
               prepareLHS(T, 
                  varDeclSetDiff(EVDS, 
                     (varDeclSetInTerm(EVDS, T) 
                      varDeclSetInTerm(EVDS, T'))), 
                  CDS, I)))) .
  eq prepareAxioms(
       mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, 
       EMAS', EqS', ((crl [L] : T => T' if T'' = T''' .) RlS'), CDS, I, QIL)
    = prepareAxioms(
        mod MN is 
           PL EIL ESD ESSDS EODS
           (EVDS newVbles(
                   prepareLHS(T, 
                     varDeclSetDiff(EVDS, 
                       (varDeclSetInTerm(EVDS, T) 
                        varDeclSetInTerm(EVDS, T'))),
                     CDS, I)))
           EMAS EqS
           ((crl [L] : 
               term(
                 prepareLHS(T, 
                   varDeclSetDiff(EVDS, 
                     (varDeclSetInTerm(EVDS, T) 
                      varDeclSetInTerm(EVDS, T'))), 
                   CDS, I))
               => prepareRHS(
                     objects(
                        prepareLHS(T, 
                           varDeclSetDiff(EVDS, 
                                (varDeclSetInTerm(EVDS, T) 
                                 varDeclSetInTerm(EVDS, T'))), 
                           CDS, I)), 
                     T')
               if prepareRHS(
                    objects(
                      prepareLHS(T, 
                        varDeclSetDiff(EVDS, 
                          (varDeclSetInTerm(EVDS, T) 
                           varDeclSetInTerm(EVDS, T'))), 
                        CDS, I)), T'')
                  = prepareRHS(
                      objects(
                        prepareLHS(T, 
                          varDeclSetDiff(EVDS, 
                            (varDeclSetInTerm(EVDS, T) 
                             varDeclSetInTerm(EVDS, T'))), 
                          CDS, I)), T''') .)
            RlS)
        endm,  
        EMAS', EqS', RlS', CDS, 
        index(
          prepareLHS(T, 
            varDeclSetDiff(EVDS, 
              (varDeclSetInTerm(EVDS, T) 
               varDeclSetInTerm(EVDS, T'))), 
            CDS, I)), 
        (QIL messages(
               prepareLHS(T, 
                  varDeclSetDiff(EVDS, 
                     (varDeclSetInTerm(EVDS, T) 
                      varDeclSetInTerm(EVDS, T'))), 
                  CDS, I)))) .
  eq prepareAxioms(U, none, none, none, CDS, I, QIL) 
    = if QIL == nil 
      then U 
      else unitError(QIL) 
      fi .

***(%
\end{verbatim}
\normalsize

\end{comment}

After completing the set of classes in the module with the attributes from
their superclasses, the function \texttt{objectOrientedToSystemModule} calls
the function \texttt{objectOrientedToSystemModuleAux} with the same module and
the set of class declarations. The definition of the
\texttt{objectOrientedToSystemModule} function is given by the five
equations below.

\small
\begin{verbatim}
%)

  op objectOrientedToSystemModule : 
       StrOModule Database -> StrSModule .
  op objectOrientedToSystemModuleAux : 
       StrOModule ClassDeclSet -> StrSModule .

  eq objectOrientedToSystemModule(
       omod MN is 
          PL EIL (sorts ESS .) ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS 
       endom,
       DB)
    = objectOrientedToSystemModuleAux(
        omod MN is 
           PL EIL (sorts ESS .) ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS 
        endom, 
        prepareClasses(ESS, ESSDS, CDS, SCDS, EIL, DB)) .

  eq objectOrientedToSystemModuleAux(
       omod MN is 
          PL EIL (sorts ESS .) ESSDS ((class C | ADS .) CDS)
          SCDS EODS MDS EVDS EMAS EqS RlS endom, 
       CDS')
    = objectOrientedToSystemModuleAux(
        omod MN is 
           PL EIL (sorts (ESS ; C) .)
           (subsort C < 'Cid . ESSDS)
           CDS SCDS
           ((op eSortToQid(C) : nil -> C [none] .) 
            attributeOpDeclSet(ADS) EODS)
           MDS EVDS EMAS EqS RlS
        endom,
        CDS') .
  eq objectOrientedToSystemModuleAux(
       omod MN is 
          PL EIL ESD ESSDS CDS ((subclass C < C' .) SCDS) 
          EODS MDS EVDS EMAS EqS RlS 
       endom, 
       CDS')
    = objectOrientedToSystemModuleAux(
        omod MN is 
           PL EIL ESD ((subsort C < C' .) ESSDS) 
           CDS SCDS EODS MDS EVDS EMAS EqS RlS 
        endom, 
        CDS') .
  eq objectOrientedToSystemModuleAux(
        omod MN is 
           PL EIL ESD ESSDS CDS SCDS EODS ((msg F : ESL -> ES .) MDS)
           EVDS EMAS EqS RlS
        endom, 
        CDS')
    = objectOrientedToSystemModuleAux(
         omod MN is 
            PL EIL ESD ESSDS CDS SCDS ((op F : ESL -> ES [none] .) EODS)
            MDS EVDS EMAS EqS RlS
         endom, 
         CDS') .
  eq objectOrientedToSystemModuleAux(
       omod MN is 
          PL EIL ESD ESSDS none none EODS none EVDS EMAS EqS RlS 
       endom, CDS)
    = prepareAxioms(
        mod MN is PL EIL ESD ESSDS EODS EVDS none none none endm, 
        EMAS, EqS, RlS, CDS, 0, nil) .

***(%
\end{verbatim}
\normalsize

  \texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Evaluation of Modules and Theories}
\label{evaluation}

As explained in Section~\ref{evaluation-overview}, in our approach
transforming a module from its possibly complex structured version to its
unstructured form is a two-step process. First, all module expressions are
evaluated, generating an intermediate form in which there are only simple
inclusion relationships among the modules. This first step can be seen as the
reduction of a structured specification to its structured \emph{normal
form}. Then, in a second step, this structured normal form is flattened into
an unstructured specification. Note, however, that the importation of built-in
modules is left explicit in the flattened form. The function
\texttt{normalization} is in charge of normalizing the structure.

The process of evaluation of a preunit has to take into account the
possibility of bubbles being contained in it. Depending on whether it is
dealing with a preunit or with a unit, the evaluation process is accomplished
by two different functions, namely, \texttt{evalPreUnit} and
\texttt{evalUnit}. One function or the other will be called in each
case. Evaluating a module already in the database, which is done by
\texttt{evalUnit}, does not require bubble handling. Besides this difference,
both functions proceed in a similar way. Before presenting the functions
\texttt{evalPreUnit} and \texttt{evalUnit} we introduce some auxiliary
declarations.

\small
\begin{verbatim}
%)

fmod EVALUATION is
  pr O-O-TO-SYSTEM-MOD-TRANSF .
  pr MOD-EXPR-EVAL .
  pr UNIT-BUBBLE-PARSING .
  pr DECL-EXT-SORT-TO-QID .

  sort UnitList .
  subsort Unit < UnitList .

  op nil : -> UnitList .
  op __ : UnitList UnitList -> UnitList [assoc id: nil] .

  var QIL : QidList .
  var M : Module .
  vars PU U U' U'' : Unit .
  var UL : UnitList .
  var DB : Database .
  var ME : ModExp .
  var P : Parameter .
  var PL : ParameterList .
  var EIL : EImportList .
  var ESD : ESortDecl .
  var CDS : ClassDeclSet .
  var ESSDS : ESubsortDeclSet .
  var SCDS : SubclassDeclSet .
  var EODS : EOpDeclSet .
  var MDS : MsgDeclSet .
  var EVDS : EVarDeclSet .
  var EMAS : EMembAxSet .
  var EqS : EquationSet .
  var RlS : RuleSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var B : Bool .
  vars QI QI' S S' V L L' L'' A A' A'' F F' F'' X Y W Z : Qid .
  var SL : QidList .
  var SS : QidSet .
  vars ES ES' ES'' C C' C'' : ESort .
  vars ESL ESL' : ESortList .
  vars ESS ESS' : ESortSet .
  var ME' : ModExp .
  var MN : ModName .
  var PL' PL'' : ParameterList .
  var IL : ImportList .
  var EIL' EIL'' : EImportList .
  var SD : SortDecl .
  var SSDS : SubsortDeclSet .
  var EOD : EOpDecl .
  var ODS : OpDeclSet .
  vars AtS AtS' : AttrSet .
  var VDS : VarDeclSet .
  var MAS : MembAxSet .
  var Rl : Rule .
  var CD : ClassDecl .
  var ADS : AttrDeclSet .
  var MD : MsgDecl .
  vars T T' T'' T''' : Term .
  var TL : TermList .
  var VMAP : ViewMap .
  var VMAPS : ViewMapSet .
  vars VE VE' VE'' : ViewExp .

***(%
\end{verbatim}
\normalsize

\end{comment}

The \texttt{subunitImportList} function returns the list of all the
subunits of a given unit. It is called with the list of importations
of the given unit as first argument, and proceeds recursively through
its structure collecting all the subunits in it.

\begin{comment}
The function \texttt{subunitImportList} proceeds storing the importations
considered up to that point, so it does not have to go through the same part
of the structure more than once. When the function is initially called the
second argument is set to \texttt{nil}.
\end{comment}

\small
\begin{verbatim}
%)

  op subunitImportList : EImportList Database -> EImportList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op subunitImportList : EImportList EImportList Database -> EImportList .

  eq subunitImportList(EIL, DB) = subunitImportList(EIL, nil, DB) .

  eq subunitImportList(((including MN .) EIL), 
       (EIL' (including MN .) EIL''), DB) 
    = subunitImportList(EIL, (EIL' (including MN .) EIL''), DB)  .
  ceq subunitImportList(((including MN .) EIL), EIL', DB) 
    = subunitImportList(
         (importList(getTopUnit(MN, DB)) EIL), ((including MN .) EIL'), DB)
      if not ((including MN .) in EIL') .
  eq subunitImportList(nil, EIL, DB) = EIL .

***(%
\end{verbatim}
\normalsize

\end{comment}

The function \texttt{getNonBuiltInUnitList} returns the list of those units in
the list of importations given as argument which are not built-in.

\small
\begin{verbatim}
%)

  op getNonBuiltInUnitList : EImportList Database -> UnitList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op getNonBuiltInUnitList : EImportList UnitList Database -> UnitList .

  eq getNonBuiltInUnitList(EIL, DB) = getNonBuiltInUnitList(EIL, nil, DB) .

  eq getNonBuiltInUnitList(((including MN .) EIL), UL, DB) 
    = if MN inModNameSet builtIns
      then getNonBuiltInUnitList(EIL, UL, DB) 
      else getNonBuiltInUnitList(EIL, (UL getInternalTopUnit(MN, DB)), DB)
      fi .
  eq getNonBuiltInUnitList(nil, UL, DB) = UL .

***(%
\end{verbatim}
\normalsize

\end{comment}

The function \texttt{selectBuiltInImports} returns the sublist of the
importations of built-in modules.

\small
\begin{verbatim}
%)

  op selectBuiltInImports : EImportList -> EImportList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq selectBuiltInImports(((including MN .) EIL)) 
    = if MN inModNameSet builtIns
      then ((including MN .) selectBuiltInImports(EIL))
      else selectBuiltInImports(EIL)
      fi .
  eq selectBuiltInImports(nil) = nil .

***(%
\end{verbatim}
\normalsize

\end{comment}

The normalization of a structure consists in evaluating each of the module
expressions appearing in it. Note that, if the \texttt{evalModExp} function
generates new modules, they will be evaluated using the \texttt{evalUnit}
function, producing recursive calls on the part of the structure not
previously normalized.

\small
\begin{verbatim}
%)

  op normalization : EImportList ParameterList Database -> Database .
  eq normalization(((including P .) EIL), PL, DB)
    = normalization(EIL, PL, DB) .
  eq normalization(((including ME .) EIL), PL, DB)
    = normalization(EIL, PL, evalModExp(ME, PL, DB)) .
  eq normalization(nil, PL, DB) = DB .

***(%
\end{verbatim}
\normalsize

\texttt{checkSortClashes} checks whether the intersection of the two sets of
sorts given as arguments is empty or not. If it is nonempty, then there is a
clash of names, and a warning message is passed to the database.  The check is
very simple, and only reports the name of one of the modules from which the
sorts come. Only the name of the module from which the sorts given as
second argument come is known at this point. This is the module
name given as first argument.

\small
\begin{verbatim}
%)

  op checkSortClashes : ModName ESortSet ESortSet Database -> Database .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq checkSortClashes(MN, (ES ; ESS), (ES ; ESS'), DB)
    = checkSortClashes(MN, ESS, ESS', 
        warning(DB, ('\n 'sort 'clash: modNameToQid(MN) eSortToQid(ES)))) .
  ceq checkSortClashes(MN, (ES ; ESS), ESS', DB)
    = checkSortClashes(MN, ESS, ESS', DB)
      if not (ES inSortSet ESS') .
  eq checkSortClashes(MN, none, ESS, DB) = DB .

***(%
\end{verbatim}
\normalsize

\end{comment}

In the current system, the only transformation handled by the
\texttt{transform} function is the one from object-oriented modules to system
modules, which is accomplished by the \texttt{objectOrientedToSystemModule}
function presented in Section~\ref{omod2modfunction}. However,
\texttt{transform} has been defined as a general transformation that could
affect other kinds of modules in a future extension.

\small
\begin{verbatim}
%)

  op transform : Unit Database -> Unit .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq transform(unitError(QIL), DB) = unitError(QIL) .
  eq transform(mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm, DB)
    = mod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endm .
  eq transform(th MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS RlS endth, DB)
    = mod MN is PL EIL ESD ESSDS EODS EVDS none none none endm .
  eq transform(mod QI is IL SD SSDS ODS VDS MAS EqS RlS endm, DB)
    = mod QI is IL SD SSDS ODS VDS MAS EqS RlS endm .
  eq transform(fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm, DB)
    = fmod MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfm .
  eq transform(fmod QI is IL SD SSDS ODS VDS MAS EqS endfm, DB)
    = fmod QI is IL SD SSDS ODS VDS MAS EqS endfm .
  eq transform(fth MN is PL EIL ESD ESSDS EODS EVDS EMAS EqS endfth, DB)
    = fmod MN is PL EIL ESD ESSDS EODS EVDS none none endfm .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq transform(
       omod MN is 
          PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS 
       endom, DB)
    = objectOrientedToSystemModule(
        omod MN is 
           PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS 
        endom, DB) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq transform(
       oth MN is PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS endoth, 
       DB)
    = objectOrientedToSystemModule(
        omod MN is 
           PL EIL ESD ESSDS CDS SCDS EODS MDS EVDS none none none 
        endom, 
        DB) .

***(%
\end{verbatim}
\normalsize

\end{comment}

The function \texttt{signature} generates a functional module of sort
\texttt{FModule}, without equations, by ``forgetting'' the appropriate
declarations and converting extended sorts and module names into quoted
identifiers.

\small
\begin{verbatim}
%)

  op signature : Unit -> FModule .
  eq signature(unitError(QIL)) = unitError(QIL) .
  ceq signature(U) 
    = fmod modNameToQid(name(U)) is
         importList(U)
         sorts eSortToQid(sortSet(sortDecl(U))) .
         eSortToQid(subsortDeclSet(U))
         eSortToQid(opDeclSet(U))
         eSortToQid(varDeclSet(U))
         none
         none
      endfm 
      if (U : StrTheory) or (U : StrModule) .

***(%
\end{verbatim}
\normalsize

The function \texttt{flatUnit} generates a module of sort \texttt{Module}
``forgetting'' declarations and converting extended sorts and module
identifiers into quoted identifiers.

\small
\begin{verbatim}
%)

  op flatUnit : Unit -> Module .
  eq flatUnit(unitError(QIL)) = unitError(QIL) .
  ceq flatUnit(U)
    = if U : FUnit
      then (fmod modNameToQid(name(U)) is
               importList(U)
               sorts eSortToQid(sortSet(sortDecl(U))) .
               eSortToQid(subsortDeclSet(U))
               eSortToQid(opDeclSet(U))
               eSortToQid(varDeclSet(U))
               eSortToQid(membAxSet(U))
               equationSet(U)
            endfm)
      else (mod modNameToQid(name(U)) is
               importList(U)
               sorts eSortToQid(sortSet(sortDecl(U))) .
               eSortToQid(subsortDeclSet(U))
               eSortToQid(opDeclSet(U))
               eSortToQid(varDeclSet(U))
               eSortToQid(membAxSet(U))
               equationSet(U)
               ruleSet(U)
            endm)
      fi 
      if (U : StrTheory) or (U : StrModule) .

***(%
\end{verbatim}
\normalsize

The evaluation process for units without bubbles is as follows. After
normalizing the structure, the function \texttt{evalUnit} calls
\texttt{evalUnit1} with an empty copy of the module to which the list of
declarations of importations of built-in modules is added, and with the list
of its nonbuilt-in subunits.

\texttt{evalUnit1} accumulates all the declarations in all the nonbuilt-in
submodules in the copy of the module passed as second argument. The top module
is then introduced in the database, and, after calling the \texttt{transform}
function and renaming all the variables in it, the internal version of such a
module is entered in the database as well.

Finally, \texttt{evalUnit2} generates the signature and the flat version of
the module and enters them in the database.

\small
\begin{verbatim}
%)

  op evalUnit : Unit Database -> Database .
  op evalUnit1 : Unit Unit UnitList Database -> Database .
  op evalUnit2 : Unit Unit Database -> Database .

  eq evalUnit(U, DB)
    = evalUnit1(U,
        setImportList(empty(U), 
          selectBuiltInImports(
            subunitImportList(importList(U), 
              normalization(importList(U), parameterList(U), DB)))),
        getNonBuiltInUnitList(
          subunitImportList(importList(U), 
            normalization(importList(U), parameterList(U), DB)),
          normalization(importList(U), parameterList(U), DB)),
        normalization(importList(U), parameterList(U), DB)) .

  eq evalUnit1(U, U', (U'' UL), DB)
    = evalUnit1(U, addDecls(U', setImportList(U'', nil)), UL, 
        checkSortClashes(
          name(U), sortSet(sortDecl(U')), 
          sortSet(sortDecl(U'')), DB)) .
  eq evalUnit1(U, U', nil, DB) 
    = evalUnit2(setImportList(transform(U, DB), nil), U', 
        checkSortClashes(
          name(U'), sortSet(sortDecl(U)), sortSet(sortDecl(U')), 
          insertInternalTopUnit(renameVars(transform(U, DB)), 
            insertTopUnit(U, DB)))) .

  eq evalUnit2(U, U', DB)
    = insertFlatUnit(name(U), 
        flatUnit(addDecls(U, U')),
        insertSignature(name(U), 
          signature(addDecls(U, U')), DB)) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

*** attempt of adding operators for qualifications with extended sorts.

  op evalUnit : Unit Database -> Database .
  op evalUnit1 : Unit Unit UnitList Database -> Database .
  op evalUnit2 : Unit Unit Database -> Database .

  eq evalUnit(U, DB)
    = evalUnit1(
        addOpDeclSet(opDeclSetQualifications(sortSet(sortDecl(U))), U),
        setImportList(empty(U), 
          selectBuiltInImports(
            subunitImportList(importList(U), 
              normalization(importList(U), parameterList(U), DB)))),
        getNonBuiltInUnitList(
          subunitImportList(importList(U), 
            normalization(importList(U), parameterList(U), DB)),
          normalization(importList(U), parameterList(U), DB)),
        normalization(importList(U), parameterList(U), DB)) .

  op opDeclSetQualifications : ESortSet -> EOpDeclSet .

  eq opDeclSetQualifications(S ; ESS)
    = opDeclSetQualifications(ESS) .
  eq opDeclSetQualifications(eSort(ES, VE) ; ESS)
    = ((op qidListToQid('`(_`). eSortToQid(eSort(ES, VE))) : 
             eSort(ES, VE) -> eSort(ES, VE) [none] .)
       opDeclSetQualifications(ESS)) .
  eq opDeclSetQualifications(none)
    = none .

  eq evalUnit1(U, U', (U'' UL), DB)
    = evalUnit1(U, addDecls(U', setImportList(U'', nil)), UL, 
        checkSortClashes(
          name(U), sortSet(sortDecl(U')), sortSet(sortDecl(U'')), DB)) .
  eq evalUnit1(U, U', nil, DB) 
    = evalUnit2(setImportList(transform(U, DB), nil), U', 
        checkSortClashes(
          name(U'), sortSet(sortDecl(U)), sortSet(sortDecl(U')), 
          insertInternalTopUnit(renameVars(transform(U, DB)), 
            insertTopUnit(U, DB)))) .

  eq evalUnit2(U, U', DB)
    = insertFlatUnit(name(U), 
        flatUnit(addDecls(U, U')),
        insertSignature(name(U), 
          signature(addDecls(U, U')), DB)) .

\end{comment}

The function \texttt{evalPreUnit} has to take care of the bubbles in the
unit. As we explained in Section~\ref{evaluation-overview}, both the signature
and the flattened version of the module are created simultaneously, completing
the parsing of the bubbles once the signature has been built, and then
completing the flattened module.

The \texttt{evalPreUnit} function takes as arguments two copies of the
module and a database. We shall see in Section~\ref{unit-processing}
how these two modules are generated; the one passed as first argument
has still bubbles in it, while the other one, which will be used to
build the signature, does not contain any bubbles. This module without
bubbles is the result of removing the bubbles from the declarations in
it, or of removing the declarations themselves when they contain
bubbles, as in the case of equations, for example.

The \texttt{evalPreUnit} function is quite similar to the function
\texttt{evalUnit}. First, the structure is normalized by calling the
\texttt{normalization} function, and then all the subunits in the structure
are collected (accomplished by \texttt{subunitImportList} and
\texttt{getNonBuiltInUnitList}) and the list of importations is updated
with the sublist of importations of built-in modules
(\texttt{selectBuiltInImports}). Second, the structure of all the subunits
below the top is flattened to a single unit. This unit is used to create a
first version of the signature (without identity elements of operators) in
which all the bubbles in the top preunit are parsed
(\texttt{solveBubbles}). The final version of the signature and the flat unit
are generated once the bubbles have been parsed. The `internal' version of the
module is also generated by renaming the variables in it
(\texttt{renameVars}). All these versions of the module are finally entered in
the database.

Note that if the \texttt{META-LEVEL} module is imported in the module being
evaluated, a declaration importing the predefined module \texttt{UP} (see
Section~\ref{non-built-in-predefined}) is added. With the declarations in this
module it will be possible to parse bubbles containing calls to the
\texttt{up} functions (see Section~\ref{structured-specifications}) in them.

\small
\begin{verbatim}
%)

  op evalPreUnit : Unit Unit Database -> Database .
  op evalPreUnit1 : Unit Unit UnitList Unit Database -> Database .
  op evalPreUnit2 : Unit Unit Module Database -> Database .
  op evalPreUnit3 : Unit Unit Module Database -> Database .

  eq evalPreUnit(PU, U, DB)
    *** PU : top module with bubbles
    *** U  : top module without bubbles
    = evalPreUnit1(
        (if ((including 'META-LEVEL .) in 
                subunitImportList(importList(PU), 
                  normalization(importList(PU), parameterList(PU), DB)))
         then addImportList((including 'UP .), PU)
         else PU
         fi), 
        setName(empty(U), name(U)),
        getNonBuiltInUnitList(
          subunitImportList(
            importList(
              if ((including 'META-LEVEL .) in 
                     subunitImportList(importList(PU), nil, 
                       normalization(importList(PU), 
                         parameterList(PU), DB)))
              then addImportList((including 'UP .), PU)
              else PU
              fi), 
            normalization(importList(PU), parameterList(PU), DB)), 
          normalization(importList(PU), parameterList(PU), DB)), 
        setImportList(U, 
          selectBuiltInImports(
            subunitImportList(importList(PU), 
              normalization(importList(PU), parameterList(PU), DB)))), 
        normalization(importList(PU), parameterList(PU), DB)) .

  eq evalPreUnit1(PU, U, (U' UL), U'', DB)
    = evalPreUnit1(PU, addDecls(U, U'), UL, U'',
        checkSortClashes(
          name(U''), sortSet(sortDecl(U)), sortSet(sortDecl(U')), DB)) .
  ceq evalPreUnit1(PU, U, nil, U', DB) 
    = evalPreUnit2(PU, U, 
        signature(
           transform(addDecls(U', setImportList(U, nil)), DB)),
        checkSortClashes(
          name(U'), sortSet(sortDecl(U)), sortSet(sortDecl(U')), DB))
      if (U : StrTheory) or (U : StrModule) . 
  eq evalPreUnit1(PU, unitError(QIL), UL, U', DB) = warning(DB, QIL) .

  eq evalPreUnit2(PU, U, M, DB)
    *** PU : top module with bubbles
    *** U  : everything below
    *** M  : complete signature (with variables of the top module)
    = evalPreUnit3(
        solveBubbles(PU, addImportList((including 'BOOL .), M), 
          ((including 'META-LEVEL .) in importList(M)), DB),
        U, M, 
        insertTopUnit(
          solveBubbles(PU, addImportList((including 'BOOL .), M), 
            ((including 'META-LEVEL .) in importList(M)), DB), DB)) .

  eq evalPreUnit3(PU, U, M, DB)
    *** PU : top module without bubbles
    *** U  : everything below
    *** M  : complete signature (with variables of the top module)
    = insertFlatUnit(name(PU),
        flatUnit(
          setImportList(addDecls(transform(PU, DB), U), importList(M))),
        insertSignature(name(PU),
          setOpDeclSet(M,
            opDeclSet(
              flatUnit(
                setImportList(
                  addDecls(transform(PU, DB), U), importList(M))))),
          insertInternalTopUnit(renameVars(transform(PU, DB)), DB))) .

***(%
\end{verbatim}
\normalsize

  \texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

Note that in both \texttt{evalUnit} and \texttt{evalPreUnit}, the function
\texttt{transform} has to be invoked to transform the module into a functional
or system module. In the current system, the only transformation available is
from object-oriented modules to system modules.


\subsection{Application of Map Sets}
\label{application-of-maps}

The following two modules deal with the application of a set of
renaming maps to a module. Except for the proof obligations and
additional checks associated with views---almost none of these checks
are performed, and none of these proof obligations is generated in the
current version---the way of applying a renaming map and a view map on
a module is the same. Internally, they are treated in the same way;
the only difference between them consists in the way of calling the
function to accomplish this application.

Note that there might be some `interference' between sort maps, and operator
maps and message maps when they are applied. Let us consider for example a
module with an operator declaration
\begin{verbatim}
  op f : Foo -> Foo .
\end{verbatim}
and a renaming map set 
\begin{verbatim}
  (sort Foo to Bar, op f : Foo -> Foo to g)
\end{verbatim}
These renamings have to be applied carefully to avoid unintended behaviors.
Depending on which of the maps is applied first, the other will be applicable
or not.  All the maps must be applied to the original module.  To avoid the
interference between the sort maps and other maps, the map set is divided into
two sets: The first one contains the sort maps, and the second one contains
the other maps.

We assume that there are no ambiguous mappings, that is, that we do not have,
for example, maps \verb~op f to g~ and \verb~op f to h~. In case of such
ambiguity, one of the maps will be arbitrarily chosen.


\subsubsection{Map Sets on Terms}

The application of a set of view maps to a term is defined in the following
module \texttt{VIEW-MAP-SET-APPL-ON-TERM}. The function
\texttt{applyMapSetToTerm} is used to apply a given view map set to terms
appearing in equations, rules, identity element declarations, and membership
axioms, as part of the process of applying a map set to a unit. 
\begin{comment}
Some of the
auxiliary functions introduced in this module will also be used in the
application of maps to operator and message declarations in the
\texttt{VIEW-MAP-SET-APPL-ON-UNIT} module.
\end{comment}

\small
\begin{verbatim}
%)

fmod VIEW-MAP-SET-APPL-ON-TERM is
  pr UNIT .
  pr VIEW-MAP .
  pr EXT-SORT-TO-QID .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var VMAP : ViewMap .
  vars VMAPS VMAPS' VMAPS'' : ViewMapSet .
  var M : Module .
  vars F F' F'' S S' V V' A A' A'' : Qid .
  vars T T' T'' O : Term .
  vars TL TL' : TermList .
  vars ES ES' ES'' C C' C'' : ESort .
  vars ESL ESL' : ESortList .
  vars EVDS : EVarDeclSet .
  var Subst : Substitution .
  var AtS : AttrSet .
  var ODS : OpDeclSet .

***(%
\end{verbatim}
\normalsize

The following functions \texttt{applyMapSetToSort} and
\texttt{applyMapSetToClassSort} apply a set of maps, respectively, to a sort a
to a class name in its single identifier form, that is, when they appear
qualifying constants. Functions \texttt{applyMapSetToESort} and
\texttt{applyMapSetToClassName} are similar but being applied to sort or class
names in their normal form.

\small
\begin{verbatim}
%)

  op applyMapSetToSort : ViewMapSet Sort -> Sort .
  eq applyMapSetToSort(((sort ES to ES'), VMAPS), S)
    = if eSortToQid(ES) == S
      then eSortToQid(ES')
      else applyMapSetToSort(VMAPS, S)  
      fi .
  ceq applyMapSetToSort((VMAP, VMAPS), S)
    = applyMapSetToSort(VMAPS, S)
      if not (VMAP : SortMap) .
  eq applyMapSetToSort(none, S) = S .

  op applyMapSetToESort : ViewMapSet ESort -> ESort .
  eq applyMapSetToESort(((sort ES to ES'), VMAPS), ES'')
    = if ES == ES''
      then ES'
      else applyMapSetToESort(VMAPS, ES'')  
      fi .
  ceq applyMapSetToESort((VMAP, VMAPS), ES)
    = applyMapSetToESort(VMAPS, ES)
      if not (VMAP : SortMap) .
  eq applyMapSetToESort(none, ES) = ES .

  op applyMapSetToClassName : ViewMapSet ESort -> ESort .
  eq applyMapSetToClassName(((class C to C'), VMAPS), C'')
    = if C == C''
      then C'
      else if eSortToQid(C) == C''
           then eSortToQid(C')
           else applyMapSetToClassName(VMAPS, C'')  
           fi
      fi .
  ceq applyMapSetToClassName((VMAP, VMAPS), C)
    = applyMapSetToClassName(VMAPS, C)
      if not (VMAP : ClassMap) .
  eq applyMapSetToClassName(none, C) = C .

  op applyMapSetToClassSort : ViewMapSet Sort -> Sort .
  eq applyMapSetToClassSort(((class C to C'), VMAPS), S)
    = if eSortToSort(C) == S
      then eSortToSort(C')
      else applyMapSetToClassSort(VMAPS, S)  
      fi .
  ceq applyMapSetToClassSort((VMAP, VMAPS), S)
    = applyMapSetToClassSort(VMAPS, S)
      if not (VMAP : ClassMap) .
  eq applyMapSetToClassSort(none, S) = S .

***(%
\end{verbatim}
\normalsize

\texttt{applyOpMapSetToOpId} applies a map set to an operator name.

\small
\begin{verbatim}
%)

  op applyOpMapSetToOpId : Qid ViewMapSet -> Qid .
  eq applyOpMapSetToOpId(F, (op F to F' [AtS])) = F' .
  eq applyOpMapSetToOpId(F, (op F : ESL -> ES to F' [AtS])) = F' .
  eq applyOpMapSetToOpId(F, none) = F .

***(%
\end{verbatim}
\normalsize

\end{comment}

Note that all maps introduced in Sections~\ref{renaming-maps}
and~\ref{view-maps}, except for label maps, may affect a term. For example,
sort maps will be applied to the qualifications of terms, and class and
attribute maps have to be applied to the objects appearing in the
term. Operator and message maps in which an explicit arity and coarity is
given, and operator maps going to derived operators (see Section~\ref{Views})
must be applied to the complete family of subsort-overloaded operators.

The function \texttt{applyMapSetToTerm} takes as arguments two sets of view
maps (the first set for sort maps, and the second for the other maps), the
term to which the maps will be applied, and a module to be used in the
matching of terms, sort comparisons, etc. Its declaration is as follows.

\small
\begin{verbatim}
%)

  op applyMapSetToTerm : ViewMapSet ViewMapSet Term Unit -> Term .

***(%
\end{verbatim}
\normalsize

\begin{comment}

If the term on which the maps have to be applied is not an object, different
cases have to be considered for each of the possible forms of a term. If it is
a variable or \texttt{error*}, the same term is returned without change.
%If it is a sort test or a lazy sort test, with forms \verb~T : ES~ 
%\verb~T :: ES~, respectively, the maps are applied to the term \texttt{T} and
%to the sort \texttt{ES}. 
In case of being of forms \verb~{F}S~ or \verb~F[TL]~ with \texttt{F} an
operator name, \texttt{S} a sort, and \texttt{TL} a list of terms, the
function \texttt{getRightOpMapSet} will return the subset of maps which are
applicable on such term. If \texttt{none} is returned then no map is
applicable. If more than one map is returned then there is an ambiguity, and
any of them will be arbitrarily taken. The function \texttt{imageOfTerm} is
called with the term and the maps applicable on it and return the image of the
term. In case of a term of the form \texttt{F[TL]}, \texttt{imageOfTerm} will
make recursive calls with the arguments in \texttt{TL}.

The application of a term map to a term requires the `matching' of the source
term in the map with the term on which the map is applied, and then the
application of the obtained substitution. Note, however, that a complete
matching algorithm is not required. Given the form of the pattern we can
choose before hand the appropriate map, that is, we know that in fact there is
a match when the function is called. Note also that the map has to be applied
to the whole family of subsort overloaded operators. We just have to check
that the sort of the given variable and the corresponding term are in the same
connected component of sorts. In addition to getting the appropriate
substitution, the only thing we need to check is that there are no variables
with different assignments, that is, that in case of having a nonlinear
pattern, the terms being assigned to each variable are equal. We call
\texttt{pseudoMatch} to the function doing this task.

\end{comment}

\begin{comment}

\small
\begin{verbatim}
%)

  op applyMapSetToTerm : ViewMapSet ViewMapSet TermList Unit -> TermList .

  op imageOfTerm : ViewMapSet ViewMapSet Term ViewMapSet Module -> Term .
  op applyMapSetToSubstitution : 
        ViewMapSet ViewMapSet Substitution Module -> Substitution .
  op pseudoMatch : 
        TermList EVarDeclSet TermList Module Substitution -> Substitution .
  op applySubstitution : TermList Substitution -> TermList .

  op getRightOpMapSet : Qid ESortList ESort ViewMapSet Module -> ViewMapSet .
  op applyMapSetToObjectAttrSet : 
        ViewMapSet ViewMapSet ESort Term Module -> Term .
  op applyMapSetToAttrNameInTerm : ViewMapSet ESort Qid Module -> Qid .

  eq applyMapSetToTerm(VMAPS, VMAPS', {F}S, M) 
    = imageOfTerm(VMAPS, VMAPS', {F}S, 
         getRightOpMapSet(F, nil, S, VMAPS', M), M) .
  eq applyMapSetToTerm(VMAPS, VMAPS', V, M) = V .
  eq applyMapSetToTerm(VMAPS, VMAPS', error*, M) = error* .
  eq applyMapSetToTerm(VMAPS, VMAPS', T : ES, M)
    = applyMapSetToTerm(VMAPS, VMAPS', T, M) : applyMapSetToESort(VMAPS, ES) .
  eq applyMapSetToTerm(VMAPS, VMAPS', T :: ES, M)
    = applyMapSetToTerm(VMAPS, VMAPS', T, M) :: applyMapSetToESort(VMAPS, ES) .
  ceq applyMapSetToTerm(VMAPS, VMAPS', F[TL], M) 
    = imageOfTerm(VMAPS, VMAPS', F[TL], 
         getRightOpMapSet(F, termListLeastSort(M, TL), 
            my-leastSort(M, F[TL]), VMAPS', M), M)
      if (F =/= '<_:_|_>) and (F =/= '<_:_|`>) .
  eq applyMapSetToTerm(VMAPS, VMAPS', '<_:_|_>[O, {C}S, T], M) 
    = '<_:_|_>[applyMapSetToTerm(VMAPS, VMAPS', O, M), 
         {applyMapSetToClassName(VMAPS', C)} applyMapSetToClassSort(VMAPS', S),
         applyMapSetToObjectAttrSet(VMAPS, VMAPS', C, T, M)] .
  eq applyMapSetToTerm(VMAPS, VMAPS', '<_:_|_>[O, C, T], M) 
    = '<_:_|_>[applyMapSetToTerm(VMAPS, VMAPS', O, M), 
          applyMapSetToClassName(VMAPS', C), 
          applyMapSetToObjectAttrSet(VMAPS, VMAPS', C, T, M)] .
  eq applyMapSetToTerm(VMAPS, VMAPS', '<_:_|`>[O, {C}S], M) 
    = '<_:_|_>[applyMapSetToTerm(VMAPS, VMAPS', O, M), 
         {applyMapSetToClassName(VMAPS', C)} applyMapSetToClassSort(VMAPS', S),
         {'none}'AttributeSet] .
  eq applyMapSetToTerm(VMAPS, VMAPS', '<_:_|`>[O, C], M) 
    = '<_:_|_>[applyMapSetToTerm(VMAPS, VMAPS', O, M), 
         applyMapSetToClassName(VMAPS', C), {'none}'AttributeSet] .

  eq applyMapSetToTerm(VMAPS, VMAPS', (T, TL), M) 
    = (applyMapSetToTerm(VMAPS, VMAPS', T, M), 
       applyMapSetToTerm(VMAPS, VMAPS', TL, M)) .

  *** Application of a map set to the name of an attribute in an object

  eq applyMapSetToAttrNameInTerm(((attr A . ES to A'), VMAPS), C', A'', M)
    = if eSameComponent(M, ES, constantSort(M, C')) 
            and (conc(A, '`:_) == A'')
      then conc(A', '`:_)
      else applyMapSetToAttrNameInTerm(VMAPS, C', A'', M)
      fi .
  ceq applyMapSetToAttrNameInTerm((VMAP, VMAPS), C, A, M)
    = applyMapSetToAttrNameInTerm(VMAPS, C, A, M)
      if not (VMAP : AttrMap) .
  eq applyMapSetToAttrNameInTerm(none, S, A, M) = A .

  op constantSort : Module Qid -> Qid .
  op constantSort : OpDeclSet Qid -> Qid .
  *** since the constant and the sort have the same name this returns the
  *** same quoted identifier
  eq constantSort(M, F)
    = constantSort(opDeclSet(M), F) .
  eq constantSort(((op F : nil -> S [AtS] .) ODS), F) = S .

  *** Selection of all the operator or message maps that are applicable 
  *** on an operator with a given arity and coarity.

  ceq getRightOpMapSet(F, ESL, ES, (VMAP, VMAPS), M)
    = getRightOpMapSet(F, ESL, ES, VMAPS, M)
      if not ((VMAP : MsgMap) or (VMAP : OpMap) or (VMAP : TermMap)) .
  eq getRightOpMapSet(F, ESL, ES, ((msg F' to F''), VMAPS), M)
    = getRightOpMapSet(F, ESL, ES, ((op F' to F'' [none]), VMAPS), M) .
  eq getRightOpMapSet(F, ESL, ES, ((msg F' : ESL' -> ES' to F''), VMAPS), M)
    = getRightOpMapSet(F, ESL, ES, 
        ((op F' : ESL' -> ES' to F'' [none]), VMAPS), M) .
  eq getRightOpMapSet(F, ESL, ES, ((op F' to F'' [AtS]), VMAPS), M)
    = if F == F'
      then ((op F' to F'' [AtS]), getRightOpMapSet(F, ESL, ES, VMAPS, M))
      else getRightOpMapSet(F, ESL, ES, VMAPS, M)
      fi .
  eq getRightOpMapSet(F, ESL, ES, 
        ((op F' : ESL' -> ES' to F'' [AtS]), VMAPS), M)
    = if ((F == F') 
          and-then eSameComponent(M, ESL, ESL')) 
         and-then eSameComponent(M, ES, ES')
      then ((op F' : ESL' -> ES' to F'' [AtS]), 
            getRightOpMapSet(F, ESL, ES, VMAPS, M))
      else getRightOpMapSet(F, ESL, ES, VMAPS, M)
      fi .
  eq getRightOpMapSet(F, ESL, ES, (termMap(EVDS, F'[TL], T), VMAPS), M)
    = if F == F' and-then eSameComponent(M, ESL, varListSort(EVDS, TL))
      then (termMap(EVDS, F'[TL], T), getRightOpMapSet(F, ESL, ES, VMAPS, M))
      else getRightOpMapSet(F, ESL, ES, VMAPS, M) 
      fi .
  eq getRightOpMapSet(F, ESL, ES, (termMap(EVDS, {F'}S, T), VMAPS), M)
    = if (F == F' and ESL == nil) and-then eSameComponent(M, ES, S)
      then (termMap(EVDS, {F'}S, T), 
            getRightOpMapSet(F, ESL, ES, VMAPS, M))
      else getRightOpMapSet(F, ESL, ES, VMAPS, M) 
      fi .
  eq getRightOpMapSet(F, ESL, ES, none, M) = none .

  op varListSort : EVarDeclSet TermList -> ESortList .
  eq varListSort(((var V : ES .) EVDS), (V, TL))
    = (ES varListSort(((var V : ES .) EVDS), TL)) .
  eq varListSort(((var V : ES .) EVDS), V) = ES .

  *** Application of a map set to the set of attributes in an object

  eq applyMapSetToObjectAttrSet(VMAPS, VMAPS', C, '_`,_[A[T], TL], M)
    = '_`,_[applyMapSetToAttrNameInTerm(VMAPS', C, A, M)
              [applyMapSetToTerm(VMAPS, VMAPS', T, M)], 
            applyMapSetToObjectAttrSet(VMAPS, VMAPS', C, TL, M)] .
  eq applyMapSetToObjectAttrSet(VMAPS, VMAPS', C, A[T], M)
    = applyMapSetToAttrNameInTerm(VMAPS', C, A, M)
         [applyMapSetToTerm(VMAPS, VMAPS', T, M)] .
  eq applyMapSetToObjectAttrSet(
       VMAPS, VMAPS', C, '_`,_[{'none}'AttributeSet, TL], M)
    = '_`,_[{'none}'AttributeSet, 
            applyMapSetToObjectAttrSet(VMAPS, VMAPS', C, TL, M)] .
  eq applyMapSetToObjectAttrSet(VMAPS, VMAPS', C, {'none}'AttributeSet, M)
    = {'none}'AttributeSet .

  *** Image of a term 

  eq imageOfTerm(VMAPS, VMAPS', {F}S, none, M)
    = { F } applyMapSetToSort(VMAPS, S) .
  eq imageOfTerm(VMAPS, VMAPS', F[TL], none, M)
    = F [ applyMapSetToTerm(VMAPS, VMAPS', TL, M) ] .
  eq imageOfTerm(VMAPS, VMAPS', {F}S, ((op F to F' [AtS]), VMAPS''), M) 
    = { F' } applyMapSetToSort(VMAPS, S) .
  eq imageOfTerm(VMAPS, VMAPS', F[TL], ((op F to F' [AtS]), VMAPS''), M) 
    = F' [ applyMapSetToTerm(VMAPS, VMAPS', TL, M) ] .
  eq imageOfTerm(
       VMAPS, VMAPS', {F}S, ((op F : ESL -> ES to F' [AtS]), VMAPS''), M)
    = { F' } applyMapSetToSort(VMAPS, S) .
  eq imageOfTerm(
       VMAPS, VMAPS', F[TL], ((op F : ESL -> ES to F' [AtS]), VMAPS''), M)
    = F' [ applyMapSetToTerm(VMAPS, VMAPS', TL, M) ] .
  eq imageOfTerm(VMAPS, VMAPS', T, (termMap(EVDS, T', T''), VMAPS''), M) 
    = applySubstitution(T'', 
        applyMapSetToSubstitution(VMAPS, VMAPS', 
          pseudoMatch(T', EVDS, T, M, none), M)) .

  *** Application of a Substitution on a term

  eq applySubstitution(T, none) = T .
  eq applySubstitution(V, ((V' <- T); Subst))
    = if V == V'
      then T
      else applySubstitution(V, Subst)
      fi .
  eq applySubstitution(F[TL], Subst)
    = F[applySubstitution(TL, Subst)] .
  eq applySubstitution({F}S, Subst) = {F}S .
  eq applySubstitution((T, TL), Subst)
    = (applySubstitution(T, Subst), applySubstitution(TL, Subst)) .

  *** PseudoMatch

  eq pseudoMatch(F[TL], EVDS, F'[TL'], M, Subst) 
    = if F == F'
      then pseudoMatch(TL, EVDS, TL', M, Subst)
      else none 
      fi .
  eq pseudoMatch({F}S, EVDS, {F}S, M, Subst) = none .
  eq pseudoMatch((V, TL), ((var V : ES .) EVDS), (T, TL'), M, Subst) 
    = pseudoMatch(TL, EVDS, TL', M, ((V <- T) ; Subst)) .
  eq pseudoMatch(V, ((var V : ES .) EVDS), T, M, Subst) 
    = ((V <- T) ; Subst) .
  eq pseudoMatch((V, TL), EVDS, (T, TL'), M, ((V <- T') ; Subst)) 
    = if T == T' 
      then pseudoMatch(TL, EVDS, TL', M, ((V <- T') ; Subst)) 
      else none
      fi .
  eq pseudoMatch(V, EVDS, T, M, ((V <- T') ; Subst)) 
    = if T == T' 
      then ((V <- T') ; Subst)
      else none
      fi .

  *** Application of a set of maps to a substitution

  eq applyMapSetToSubstitution(VMAPS, VMAPS', ((V <- T) ; Subst), M)
    = ((V <- applyMapSetToTerm(VMAPS, VMAPS', T, M)) ; 
       applyMapSetToSubstitution(VMAPS, VMAPS', Subst, M)) .
  eq applyMapSetToSubstitution(VMAPS, VMAPS', none, M)
    = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

We do not include here the equations defining the semantics of the function
\texttt{applyMapSetToTerm}. Instead, we present an example illustrating the
meaning of the function. Renaming maps and view maps were already discussed in
Sections~\ref{Views} and~\ref{module-expressions}.

Let us consider the following configuration in the module
\texttt{STACK2[Accnt]} presented in Section~\ref{module-expressions}. In this
configuration we have objects in the class \texttt{Accnt} which represent the
accounts of different clients of a bank, which is represented as an object
\texttt{'bank} of class \texttt{Stack[Accnt]}. The object \texttt{'bank} in
the example configuration below keeps a stack with the accounts of the bank
represented as a linked list of nodes, each of which corresponds to the
account of one of the clients.

\small
\begin{verbatim}
  ('bank push 'john) 
  ('peter elt 2000) 
  < 'bank : Stack[Accnt] | first : o ('bank, 1) > 
  < 'paul : Accnt | bal : 5000 > 
  < 'peter : Accnt | bal : 2000 > 
  < 'mary : Accnt | bal : 7200 > 
  < 'john : Accnt | bal : 100 > 
  < o('bank, 0) : Node[Accnt] | node : 'peter, next : null > 
  < o('bank, 1) : Node[Accnt] | node : 'mary, next : o('bank, 0) > .
\end{verbatim}
\normalsize

Let us apply the following renaming to the previous term. 

\small
\begin{verbatim}
  (op o to id, 
   class Stack[Accnt] to Bank,
   msg _push_ : Oid Oid -> Msg to open`account`in_to_,
   msg _pop to close`account`of_,
   msg _elt_ to _owns_dollars,
   attr node . Node[Accnt] to client,
   attr bal . Accnt to balance)
\end{verbatim}
\normalsize

The resulting term is as follows.

\small
\begin{verbatim}
  (open account in 'bank to 'john) 
  ('peter owns 2000 dollars) 
  < 'bank : Bank | first : id('bank, 1) > 
  < 'paul : Accnt | balance : 5000 > 
  < 'peter : Accnt | balance : 2000 > 
  < 'mary : Accnt | balance : 7200 > 
  < 'john : Accnt | balance : 100 > 
  < id('bank, 0) : Node[Accnt] | client : 'peter, next : null > 
  < id('bank, 1) : Node[Accnt] | client : 'mary, next : id('bank, 0) >
\end{verbatim}
\normalsize

The function \texttt{applyMapSetToTerm} treats the object constructor
\verb~<_:_|_>~ in a special way. It cannot be renamed, and, when an
occurrence of such a constructor is found, class and attribute maps require a
particular handling. Inside terms these maps are only triggered when this
constructor is found, and they are applied in a very restricted way, according
to the general pattern for objects.
\begin{comment}
(functions \texttt{applyMapSetToClassName},
\texttt{applyMapSetToclassSort}, and \texttt{applyMapSetToObjectAttrSet} are
responsible for that). 
\end{comment}
We assume that the operator \verb~<_:_|_>~ is only used
for objects and that objects constructed using it are well-formed.


\subsubsection{Map Sets on Units}
\label{applyMapSetToUnit}

The application of view maps to modules and theories of the different types is
defined in the following module \texttt{VIEW-MAP-SET-APPL-ON-UNIT}. The
function \texttt{applyMapSetToUnit} is defined recursively by applying it to
the different components of a unit. When the terms in the different
declarations are reached, the function \texttt{applyMapSetToTerm} is
called. This call is made with the set of maps split conveniently, as explained
above.

\small
\begin{verbatim}
%)

fmod VIEW-MAP-SET-APPL-ON-UNIT is
  pr VIEW-MAP-SET-APPL-ON-TERM .

  op applyMapSetToUnit : ViewMapSet Unit Module -> Unit .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op applyMapSetToUnit2 : ViewMapSet ViewMapSet ViewMapSet Unit Module 
        -> Unit .
  op applyMapSetToUnit3 : ViewMapSet ViewMapSet Unit Module -> Unit .

  op applyMapSetToSortSet : ViewMapSet ESortSet -> ESortSet .
  op applyMapSetToSortList : ViewMapSet ESortList -> ESortList .
  op applyMapSetToSubsortDeclSet : 
        ViewMapSet ESubsortDeclSet -> ESubsortDeclSet .
  op applyMapSetToOpDeclSet : 
        ViewMapSet ViewMapSet EOpDeclSet Module -> EOpDeclSet .
  op applyMapSetToOpDecl : 
        ViewMapSet ViewMapSet ViewMapSet EOpDecl Module -> EOpDecl .
  op applyMapSetToAttrSet : ViewMapSet ViewMapSet AttrSet Unit -> AttrSet .
  op applyMapToAttrSet : ViewMap AttrSet -> AttrSet .
  op applyMapToAttrSetAux : AttrSet AttrSet AttrSet -> AttrSet .
  op applyMapSetToHookList : 
        ViewMapSet ViewMapSet HookList Module -> HookList .
  op applyMapSetToHookListAux : ViewMapSet ViewMapSet Hook Module -> Hook .
  op applyMapSetToVarDeclSet : ViewMapSet EVarDeclSet -> EVarDeclSet .
  op applyMapSetToMembAxSet : 
        ViewMapSet ViewMapSet EMembAxSet Unit -> EMembAxSet .
  op applyMapSetToEquationSet : 
        ViewMapSet ViewMapSet EquationSet Unit -> EquationSet .
  op applyMapSetToRuleSet : ViewMapSet ViewMapSet RuleSet Unit -> RuleSet .
  op applyMapSetToLabel : ViewMapSet Qid -> Qid .
  op applyMapSetToClassDeclSet : 
        ViewMapSet ViewMapSet ClassDeclSet -> ClassDeclSet .
  op applyMapSetToSubclassDeclSet : 
        ViewMapSet SubclassDeclSet -> SubclassDeclSet .
  op applyMapSetToMsgDeclSet : 
        ViewMapSet ViewMapSet MsgDeclSet Module -> MsgDeclSet .
  op applyMapSetToMsgDecl : ViewMapSet ViewMapSet MsgDecl Module -> MsgDecl .
  op applyMapSetToAttrName : ViewMapSet ESort Qid -> Qid .
  op applyMapSetToAttrDeclSet : 
        ViewMapSet ViewMapSet ESort AttrDeclSet -> AttrDeclSet .

  var M : Module .
  var U : Unit .
  vars QI QI' QI'' S S' V V' L L' L'' F F' F'' A A' A'' : Qid .
  vars QIL QIL' : QidList .
  var VE : ViewExp .
  var MN : ModName .
  var PL : ParameterList .
  var EIL : EImportList .
  vars ES ES' ES'' C C' C'' : ESort .
  vars ESL ESL' : ESortList .
  var ESS : ESortSet .
  var SD : SortDecl .
  var ESD : ESortDecl .
  var SSDS : SubsortDeclSet .
  var ESSDS : ESubsortDeclSet .
  var ODS : OpDeclSet .
  var EODS : EOpDeclSet .
  var VDS : VarDeclSet .
  var EVDS : EVarDeclSet .
  var MAS : MembAxSet .
  var EMAS : EMembAxSet .
  var EqS : EquationSet .
  var RlS : RuleSet .
  var CDS : ClassDeclSet .
  var SCDS : SubclassDeclSet .
  var MDS : MsgDeclSet .
  var ADS : AttrDeclSet .
  vars T T' T'' T''' O : Term .
  vars TL TL' : TermList .
  var At : Attr .
  vars AtS AtS' AtS'' : AttrSet . 
  vars I I' : MachineInt .
  vars MIL MIL' : MachineIntList .
  var H : Hook .
  var HL : HookList .
  var VMAP : ViewMap .
  vars VMAPS VMAPS' VMAPS'' : ViewMapSet .
  var Subst : Substitution .

  eq applyMapSetToUnit(VMAPS, U, M)
    = applyMapSetToUnit2(VMAPS, none, none, U, M) .

***(%
\end{verbatim}
\normalsize

To avoid the interference between the sort maps with other maps, the map set
is divided in two sets by \texttt{applyMapSetToUnit2}. When
\texttt{applyMapSetToUnit3} is called, its first argument contains the sort
maps, and the second one contains the others.

\small
\begin{verbatim}
%)

  eq applyMapSetToUnit2((VMAP, VMAPS), VMAPS', VMAPS'', U, M)
    = if VMAP : SortMap
      then applyMapSetToUnit2(VMAPS, (VMAP, VMAPS'), VMAPS'', U, M)
      else applyMapSetToUnit2(VMAPS, VMAPS', (VMAP, VMAPS''), U, M)
      fi .
  eq applyMapSetToUnit2(none, VMAPS, VMAPS', U, M)
    = applyMapSetToUnit3(VMAPS, VMAPS', U, M) .

  eq applyMapSetToUnit3(VMAPS, VMAPS', 
        mod MN is PL EIL (sorts ESS .) ESSDS EODS EVDS EMAS EqS RlS endm, 
        M)
    = mod MN is
          PL  EIL (sorts applyMapSetToSortSet(VMAPS, ESS) .) 
          applyMapSetToSubsortDeclSet(VMAPS, ESSDS)
          applyMapSetToOpDeclSet(VMAPS, VMAPS', EODS, M)
          applyMapSetToVarDeclSet(VMAPS, EVDS)
          applyMapSetToMembAxSet(VMAPS, VMAPS', EMAS, M)
          applyMapSetToEquationSet(VMAPS, VMAPS', EqS, M)
          applyMapSetToRuleSet(VMAPS, VMAPS', RlS, M)
      endm .
  eq applyMapSetToUnit3(VMAPS, VMAPS', 
        th MN is PL EIL (sorts ESS .) ESSDS EODS EVDS EMAS EqS RlS endth, 
        M)
    = th MN is
          PL  EIL (sorts applyMapSetToSortSet(VMAPS, ESS) .) 
          applyMapSetToSubsortDeclSet(VMAPS, ESSDS)
          applyMapSetToOpDeclSet(VMAPS, VMAPS', EODS, M)
          applyMapSetToVarDeclSet(VMAPS, EVDS)
          applyMapSetToMembAxSet(VMAPS, VMAPS', EMAS, M)
          applyMapSetToEquationSet(VMAPS, VMAPS', EqS, M)
          applyMapSetToRuleSet(VMAPS, VMAPS', RlS, M)
      endth .
  eq applyMapSetToUnit3(VMAPS, VMAPS', 
        fmod MN is PL EIL (sorts ESS .) ESSDS EODS EVDS EMAS EqS endfm, 
        M)
    = fmod MN is
          PL  EIL (sorts applyMapSetToSortSet(VMAPS, ESS) .) 
          applyMapSetToSubsortDeclSet(VMAPS, ESSDS)
          applyMapSetToOpDeclSet(VMAPS, VMAPS', EODS, M)
          applyMapSetToVarDeclSet(VMAPS, EVDS)
          applyMapSetToMembAxSet(VMAPS, VMAPS', EMAS, M)
          applyMapSetToEquationSet(VMAPS, VMAPS', EqS, M)
      endfm .
  eq applyMapSetToUnit3(VMAPS, VMAPS', 
        fth MN is PL EIL (sorts ESS .) ESSDS EODS EVDS EMAS EqS endfth, 
        M)
    = fth MN is 
          PL  EIL (sorts applyMapSetToSortSet(VMAPS, ESS) .) 
          applyMapSetToSubsortDeclSet(VMAPS, ESSDS)
          applyMapSetToOpDeclSet(VMAPS, VMAPS', EODS, M)
          applyMapSetToVarDeclSet(VMAPS, EVDS)
          applyMapSetToMembAxSet(VMAPS, VMAPS', EMAS, M)
          applyMapSetToEquationSet(VMAPS, VMAPS', EqS, M)
      endfth .
  eq applyMapSetToUnit3(VMAPS, VMAPS', 
        omod MN is 
           PL EIL (sorts ESS .) ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS
        endom, 
        M)
    = omod MN is 
           PL EIL (sorts applyMapSetToSortSet(VMAPS, ESS) .) 
           applyMapSetToSubsortDeclSet(VMAPS, ESSDS)
           applyMapSetToClassDeclSet(VMAPS, VMAPS', CDS)
           applyMapSetToSubclassDeclSet(VMAPS', SCDS)
           applyMapSetToOpDeclSet(VMAPS, VMAPS', EODS, M)
           applyMapSetToMsgDeclSet(VMAPS, VMAPS', MDS, M)
           applyMapSetToVarDeclSet(VMAPS, EVDS) 
           applyMapSetToMembAxSet(VMAPS, VMAPS', EMAS, M)
           applyMapSetToEquationSet(VMAPS, VMAPS', EqS, M)
           applyMapSetToRuleSet(VMAPS, VMAPS', RlS, M)
      endom .
  eq applyMapSetToUnit3(VMAPS, VMAPS', 
        oth MN is 
           PL EIL (sorts ESS .) ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS
        endoth, 
        M)
    = oth MN is 
           PL EIL (sorts applyMapSetToSortSet(VMAPS, ESS) .) 
           applyMapSetToSubsortDeclSet(VMAPS, ESSDS)
           applyMapSetToClassDeclSet(VMAPS, VMAPS', CDS)
           applyMapSetToSubclassDeclSet(VMAPS', SCDS)
           applyMapSetToOpDeclSet(VMAPS, VMAPS', EODS, M)
           applyMapSetToMsgDeclSet(VMAPS, VMAPS', MDS, M)
           applyMapSetToVarDeclSet(VMAPS, EVDS) 
           applyMapSetToMembAxSet(VMAPS, VMAPS', EMAS, M)
           applyMapSetToEquationSet(VMAPS, VMAPS', EqS, M)
           applyMapSetToRuleSet(VMAPS, VMAPS', RlS, M)
      endoth .

  eq applyMapSetToOpDeclSet(VMAPS, VMAPS', 
        ((op F : ESL -> ES [AtS] .) EODS), M)
    = (applyMapSetToOpDecl(VMAPS, getRightOpMapSet(F, ESL, ES, VMAPS', M), 
          VMAPS', (op F : ESL -> ES [AtS] .), M)
       applyMapSetToOpDeclSet(VMAPS, VMAPS', EODS, M)) .
  eq applyMapSetToOpDeclSet(VMAPS, VMAPS', none, M) = none .

  eq applyMapSetToOpDecl(
        VMAPS, (VMAP, VMAPS'), VMAPS'', (op F : ESL -> ES [AtS] .), M)
    *** In case of ambiguous mappings we are arbitrarily taking one of them
    = (op applyOpMapSetToOpId(F, VMAP) : applyMapSetToSortList(VMAPS, ESL)
           -> applyMapSetToESort(VMAPS, ES) 
        [applyMapSetToAttrSet(VMAPS, VMAPS'', 
            applyMapToAttrSet(VMAP, AtS), M)] .) .
  eq applyMapSetToOpDecl(VMAPS, none, VMAPS', (op F : ESL -> ES [AtS] .), M)
    *** No map for this declaration
    = (op F : applyMapSetToSortList(VMAPS, ESL)
           -> applyMapSetToESort(VMAPS, ES) 
        [applyMapSetToAttrSet(VMAPS, VMAPS', AtS, M)] .) .

  eq applyMapSetToMsgDeclSet(VMAPS, VMAPS', ((msg F : ESL -> ES .) MDS), M)
    = (applyMapSetToMsgDecl(VMAPS, getRightOpMapSet(F, ESL, ES, VMAPS', M), 
          (msg F : ESL -> ES .), M)
       applyMapSetToMsgDeclSet(VMAPS, VMAPS', MDS, M)) .
  eq applyMapSetToMsgDeclSet(VMAPS, VMAPS', none, M) = none .

  eq applyMapSetToMsgDecl(VMAPS, (VMAP, VMAPS'), (msg F : ESL -> ES .), M)
    *** In case of ambiguous mappings we are arbitrarily taking one of them
    = (msg applyOpMapSetToOpId(F, VMAP) : applyMapSetToSortList(VMAPS, ESL)
           -> applyMapSetToESort(VMAPS, ES) .) .
  eq applyMapSetToMsgDecl(VMAPS, none, (msg F : ESL -> ES .), M)
    *** No map for this declaration
    = (msg F : applyMapSetToSortList(VMAPS, ESL)
           -> applyMapSetToESort(VMAPS, ES) .) .

***(%
\end{verbatim}
\normalsize

The function \texttt{applyMapToAttrSet} just takes care of changing the
attributes of the operators as indicated in the renamings. The renamings
properly said is accomplished by the function \texttt{applyMapSetToAttrSet}.

\small
\begin{verbatim}
%)

  eq applyMapToAttrSet((msg F to F'), AtS) = AtS .
  eq applyMapToAttrSet((msg F : ESL -> ES to F'), AtS) = AtS .
  eq applyMapToAttrSet(termMap(EVDS, T, T'), AtS) = AtS .
  eq applyMapToAttrSet((op F to F' [AtS]), AtS')
    = if AtS == none
      then AtS'
      else applyMapToAttrSetAux(AtS, AtS', none)
      fi .
  eq applyMapToAttrSet((op F : ESL -> ES to F' [AtS]), AtS')
    = if AtS == none
      then AtS'
      else applyMapToAttrSetAux(AtS, AtS', none)
      fi .

  eq applyMapToAttrSetAux((gather(QIL) AtS), (gather(QIL') AtS'), AtS'')
    = applyMapToAttrSetAux(AtS, (gather(QIL) AtS' AtS''), none) .
  eq applyMapToAttrSetAux((gather(QIL) AtS), (prec(I) AtS'), AtS'')
    = applyMapToAttrSetAux((gather(QIL) AtS), AtS', (prec(I) AtS'')) .
  eq applyMapToAttrSetAux((gather(QIL) AtS), (strat(MIL) AtS'), AtS'')
    = applyMapToAttrSetAux((gather(QIL) AtS), AtS', (strat(MIL) AtS'')) .

  eq applyMapToAttrSetAux((prec(I) AtS), (prec(I') AtS'), AtS'')
    = applyMapToAttrSetAux(AtS, (prec(I) AtS' AtS''), none) .
  eq applyMapToAttrSetAux((prec(I) AtS), (gather(QIL) AtS'), AtS'')
    = applyMapToAttrSetAux((prec(I) AtS), AtS', (gather(QIL) AtS'')) .
  eq applyMapToAttrSetAux((prec(I) AtS), (strat(MIL) AtS'), AtS'')
    = applyMapToAttrSetAux((prec(I) AtS), AtS', (strat(MIL) AtS'')) .

  eq applyMapToAttrSetAux((strat(MIL) AtS), (strat(MIL') AtS'), AtS'')
    = applyMapToAttrSetAux(AtS, (strat(MIL) AtS' AtS''), none) .
  eq applyMapToAttrSetAux((strat(MIL) AtS), (gather(QIL) AtS'), AtS'')
    = applyMapToAttrSetAux((strat(MIL) AtS), AtS', (gather(QIL) AtS'')) .
  eq applyMapToAttrSetAux((strat(MIL) AtS), (prec(I) AtS'), AtS'')
    = applyMapToAttrSetAux((strat(MIL) AtS), AtS', (prec(I) AtS'')) .

  eq applyMapToAttrSetAux((At AtS), (assoc AtS'), AtS'')
    = applyMapToAttrSetAux((At AtS), AtS', (assoc AtS'')) .
  eq applyMapToAttrSetAux((At AtS), (comm AtS'), AtS'')
    = applyMapToAttrSetAux((At AtS), AtS', (comm AtS'')) .
  eq applyMapToAttrSetAux((At AtS), (idem AtS'), AtS'')
    = applyMapToAttrSetAux((At AtS), AtS', (idem AtS'')) .
  eq applyMapToAttrSetAux((At AtS), (id(T) AtS'), AtS'')
    = applyMapToAttrSetAux((At AtS), AtS', (id(T) AtS'')) .
  eq applyMapToAttrSetAux((At AtS), (left-id(T) AtS'), AtS'')
    = applyMapToAttrSetAux((At AtS), AtS', (left-id(T) AtS'')) .
  eq applyMapToAttrSetAux((At AtS), (right-id(T) AtS'), AtS'')
    = applyMapToAttrSetAux((At AtS), AtS', (right-id(T) AtS'')) .
  eq applyMapToAttrSetAux((At AtS), (memo AtS'), AtS'')
    = applyMapToAttrSetAux((At AtS), AtS', (memo AtS'')) .
  eq applyMapToAttrSetAux((At AtS), (ctor AtS'), AtS'')
    = applyMapToAttrSetAux((At AtS), AtS', (ctor AtS'')) .
  eq applyMapToAttrSetAux((At AtS), (special(HL) AtS'), AtS'')
    = applyMapToAttrSetAux((At AtS), AtS', (special(HL) AtS'')) .

  eq applyMapToAttrSetAux((At AtS), none, AtS')
    = applyMapToAttrSetAux(AtS, (At AtS'), none) .
  eq applyMapToAttrSetAux(none, AtS, none) = AtS .

  eq applyMapSetToSortSet(VMAPS, (ES ; ESS)) 
    = (applyMapSetToESort(VMAPS, ES) ; applyMapSetToSortSet(VMAPS, ESS)) .
  eq applyMapSetToSortSet(VMAPS, none) = none .

  eq applyMapSetToSortList(VMAPS, (ES ESL)) 
    = (applyMapSetToESort(VMAPS, ES) applyMapSetToSortList(VMAPS, ESL)) .
  eq applyMapSetToSortList(VMAPS, nil) = nil .

  eq applyMapSetToSubsortDeclSet(VMAPS, ((subsort ES < ES' .) ESSDS))
    = ((subsort applyMapSetToESort(VMAPS, ES) 
           < applyMapSetToESort(VMAPS, ES') .)
       applyMapSetToSubsortDeclSet(VMAPS, ESSDS)) .
  eq applyMapSetToSubsortDeclSet(VMAPS, none) = none .

  ceq applyMapSetToAttrSet(VMAPS, VMAPS', (At AtS), M)
    = (At applyMapSetToAttrSet(VMAPS, VMAPS', AtS, M))
      if (At == comm) or (At == assoc) or (At == idem) 
         or (At == memo) or (At == ctor) .
  eq applyMapSetToAttrSet(VMAPS, VMAPS', (strat(MIL) AtS), M)
    = (strat(MIL) applyMapSetToAttrSet(VMAPS, VMAPS', AtS, M)) .
  eq applyMapSetToAttrSet(VMAPS, VMAPS', (id(T) AtS), M)
    = (id(applyMapSetToTerm(VMAPS, VMAPS', T, M))
       applyMapSetToAttrSet(VMAPS, VMAPS', AtS, M)) .
  eq applyMapSetToAttrSet(VMAPS, VMAPS', (left-id(T) AtS), M)
    = (left-id(applyMapSetToTerm(VMAPS, VMAPS', T, M))
       applyMapSetToAttrSet(VMAPS, VMAPS', AtS, M)) .
  eq applyMapSetToAttrSet(VMAPS, VMAPS', (right-id(T) AtS), M)
    = (right-id(applyMapSetToTerm(VMAPS, VMAPS', T, M))
       applyMapSetToAttrSet(VMAPS, VMAPS', AtS, M)) .
  eq applyMapSetToAttrSet(VMAPS, VMAPS', (prec(I) AtS), M)
    = (prec(I) applyMapSetToAttrSet(VMAPS, VMAPS', AtS, M)) .
  eq applyMapSetToAttrSet(VMAPS, VMAPS', (gather(QIL) AtS), M)
    = (gather(QIL) applyMapSetToAttrSet(VMAPS, VMAPS', AtS, M)) .
  eq applyMapSetToAttrSet(VMAPS, VMAPS', (special(HL) AtS), M)
    = (special(applyMapSetToHookList(VMAPS, VMAPS', HL, M))
       applyMapSetToAttrSet(VMAPS, VMAPS', AtS, M)) .
  eq applyMapSetToAttrSet(VMAPS, VMAPS', none, M) = none .

  eq applyMapSetToHookList(VMAPS, VMAPS', (H HL), M)
    = (applyMapSetToHookList(VMAPS, VMAPS', H, M) 
       applyMapSetToHookList(VMAPS, VMAPS', HL, M)) .
  eq applyMapSetToHookList(VMAPS, VMAPS', id-hook(QI, QIL), M)
    = id-hook(QI, QIL) .
  eq applyMapSetToHookList(VMAPS, VMAPS', op-hook(QI, QI', QIL, QI''), M)
    = applyMapSetToHookListAux(VMAPS, 
         getRightOpMapSet(QI', QIL, QI'', VMAPS', M), 
         op-hook(QI, QI', QIL, QI''), M) .
  eq applyMapSetToHookList(VMAPS, VMAPS', term-hook(QI, T), M)
    = term-hook(QI, applyMapSetToTerm(VMAPS, VMAPS', T, M)) .

  eq applyMapSetToHookListAux(VMAPS, (VMAP, VMAPS'), 
        op-hook(QI, F, ESL, ES), M)
    *** In case of ambiguous mappings we arbitrarily take any of them 
    = op-hook(QI, applyOpMapSetToOpId(F, VMAP),
         applyMapSetToSortList(VMAPS, ESL), applyMapSetToESort(VMAPS, ES)) .
  eq applyMapSetToHookListAux(VMAPS, none, op-hook(QI, F, ESL, ES), M)
    = op-hook(QI, F, applyMapSetToSortList(VMAPS, ESL),
         applyMapSetToESort(VMAPS, ES)) .

  eq applyMapSetToVarDeclSet(VMAPS, ((var V : ES .) EVDS))
    = ((var V : applyMapSetToESort(VMAPS, ES) .) 
       applyMapSetToVarDeclSet(VMAPS, EVDS)) .
  eq applyMapSetToVarDeclSet(VMAPS, none) = none .

  eq applyMapSetToMembAxSet(VMAPS, VMAPS', ((mb T : ES .) EMAS), M)
    = ((mb applyMapSetToTerm(VMAPS, VMAPS', T, M) 
            : applyMapSetToESort(VMAPS, ES) .)
       applyMapSetToMembAxSet(VMAPS, VMAPS', EMAS, M)) .
  eq applyMapSetToMembAxSet(VMAPS, VMAPS', 
        ((cmb T : ES if T' = T'' .) EMAS), M)
    = ((cmb applyMapSetToTerm(VMAPS, VMAPS', T, M)
            : applyMapSetToESort(VMAPS, ES)
              if applyMapSetToTerm(VMAPS, VMAPS', T', M)
                 = applyMapSetToTerm(VMAPS, VMAPS', T'', M) .)
       applyMapSetToMembAxSet(VMAPS, VMAPS', EMAS, M)) .
  eq applyMapSetToMembAxSet(VMAPS, VMAPS', none, M) = none .

  eq applyMapSetToEquationSet(
        VMAPS, VMAPS', ((ceq T = T' if T'' =  T''' .) EqS), M) 
    = ((ceq applyMapSetToTerm(VMAPS, VMAPS', T, M) 
           = applyMapSetToTerm(VMAPS, VMAPS', T', M)
             if applyMapSetToTerm(VMAPS, VMAPS', T'', M) 
                   = applyMapSetToTerm(VMAPS, VMAPS', T''', M) .)
       applyMapSetToEquationSet(VMAPS, VMAPS', EqS, M)) .
  eq applyMapSetToEquationSet(VMAPS, VMAPS', ((eq T = T' .) EqS), M) 
    = ((eq applyMapSetToTerm(VMAPS, VMAPS', T, M) 
          = applyMapSetToTerm(VMAPS, VMAPS', T', M) .)
       applyMapSetToEquationSet(VMAPS, VMAPS', EqS, M)) .
  eq applyMapSetToEquationSet(VMAPS, VMAPS', none, M) = none .

  eq applyMapSetToRuleSet(
        VMAPS, VMAPS', ((crl [L]: T => T' if T'' = T''' .) RlS), M) 
    = ((crl [applyMapSetToLabel(VMAPS', L)] :
           applyMapSetToTerm(VMAPS, VMAPS', T, M)
           => applyMapSetToTerm(VMAPS, VMAPS', T', M)
              if applyMapSetToTerm(VMAPS, VMAPS', T'', M)
                 = applyMapSetToTerm(VMAPS, VMAPS', T''', M) .)
       applyMapSetToRuleSet(VMAPS, VMAPS', RlS, M)) .
  eq applyMapSetToRuleSet(VMAPS, VMAPS', ((rl [L] : T => T' .) RlS), M) 
    = ((rl [applyMapSetToLabel(VMAPS', L)] :
          applyMapSetToTerm(VMAPS, VMAPS', T, M)
          => applyMapSetToTerm(VMAPS, VMAPS', T', M) .)
       applyMapSetToRuleSet(VMAPS, VMAPS', RlS, M)) .
  eq applyMapSetToRuleSet(VMAPS, VMAPS', none, M) = none .

  eq applyMapSetToLabel(((label L to L'), VMAPS), L'')
    = if L == L'' 
      then L'
      else applyMapSetToLabel(VMAPS, L'')
      fi .
  ceq applyMapSetToLabel((VMAP, VMAPS), L)
    = applyMapSetToLabel(VMAPS, L)
      if not (VMAP : LabelMap) .
  eq applyMapSetToLabel(none, L) = L .

  eq applyMapSetToClassDeclSet(VMAPS, VMAPS', ((class C | ADS .) CDS))
    = ((class applyMapSetToClassName(VMAPS', C) |
              applyMapSetToAttrDeclSet(VMAPS, VMAPS', C, ADS) .)
       applyMapSetToClassDeclSet(VMAPS, VMAPS', CDS)) .
  eq applyMapSetToClassDeclSet(VMAPS, VMAPS', none) = none .

  eq applyMapSetToAttrDeclSet(VMAPS, VMAPS', C, ((attr A : ES), ADS))
    = ((attr applyMapSetToAttrName(VMAPS', C, A) :
                applyMapSetToESort(VMAPS, ES)),
       applyMapSetToAttrDeclSet(VMAPS, VMAPS', C, ADS)) .
  eq applyMapSetToAttrDeclSet(VMAPS, VMAPS', C, none) = none .

  eq applyMapSetToAttrName(((attr A . C to A'), VMAPS), C', A'')
    = if (C == C') and (A == A'')
      then A'
      else applyMapSetToAttrName(VMAPS, C', A'')
      fi .
  ceq applyMapSetToAttrName((VMAP, VMAPS), C, A)
    = applyMapSetToAttrName(VMAPS, C, A)
      if not (VMAP : AttrMap) .
  eq applyMapSetToAttrName(none, C, A) = A .

  eq applyMapSetToSubclassDeclSet(VMAPS, ((subclass C < C' .) SCDS))
    = ((subclass applyMapSetToClassName(VMAPS, C) <
                 applyMapSetToClassName(VMAPS, C') .)
       applyMapSetToSubclassDeclSet(VMAPS, SCDS)) .
  eq applyMapSetToSubclassDeclSet(VMAPS, none) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Instantiation of Parameterized Modules and the \\
\texttt{META-LEVEL} Module Expression} 
\label{instantiation}

A parameterized module 
$\texttt{M[L}_1\texttt{\ ::\ T}_1\texttt{,\ }
           \ldots\texttt{,\ L}_n\texttt{\ ::\ T}_n\texttt{]}$, 
with \mbox{$\texttt{L}_1\ldots\texttt{L}_n$} labels and
\mbox{$\texttt{T}_1\ldots\texttt{T}_n$} theory identifiers, is represented as
a module with name \texttt{M} which contains parameter declarations
\mbox{$\texttt{par\ L}_i\texttt{\ ::\ T}_i$} for $1\leq i\leq n$, and an
importation declaration 
\mbox{$\texttt{including\ par\ L}_i\texttt{\ ::\ T}_i\texttt{\ .}$} for each
parameter \mbox{$\texttt{L}_i\texttt{\ ::\ T}_i$} in its interface.  Note that
all modules are handled in a uniform way: nonparameterized modules and
theories have their list of parameters set to \texttt{nilParameterList}.

The instantiation of the formal parameters of a parameterized module with
actual modules or theories requires a view from each formal parameter theory
to its corresponding actual unit. The process of instantiation results in the
replacement of each interface theory by its corresponding actual parameter,
using the views to bind actual names to formal names.

\begin{comment}
Given a parameter \mbox{$\texttt{L}_i\texttt{\ ::\ T}_i$} and a view
$\texttt{V}_i$ from $\texttt{T}_i$ to some unit $\texttt{U}_i$, the
instantiation has a different effect on the parameterized module depending on
the kind of view that $\texttt{V}_i$ is. 
\end{comment}

The naming conventions for sorts have to be taken into account in the
instantiation process: every occurrence of a sort coming from a theory in the
interface of a module must be qualified by its theory's label, and sorts
defined in the body of a parameterized module can be parameterized by the
labels in the interface of the module (see
Section~\ref{parameterized-modules}).

The labeling convention for theories and for the sorts coming from
them is very useful to avoid collisions of sort names coming from the
parameter theories, and also to allow different uses of the same
theory several times in the interface of a module. We assume that all
sorts coming from the theory part of the parameter theories are used
in their qualified form to manipulate the maps defined in the views
before being applied to the body of the module being instantiated. If
the target of a view is a theory, the sorts from the theory part of
the target theory appearing in the targets of the maps in the view
will be qualified as well, following the same convention.

When a parameterized module
$\texttt{M[L}_1\texttt{\ ::\ T}_1\texttt{,\ }
           \ldots\texttt{,\ L}_n\texttt{\ ::\ T}_n\texttt{]}$
is instantiated with views $\texttt{V}_1\ldots\texttt{V}_n$,
each parameterized sort
$\texttt{S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]}$ in the body of the
parameterized module is renamed to
$\texttt{S[V}_1\texttt{,}\ldots\texttt{,V}_n\texttt{]}$.

The discussion on the qualification of sorts in views before being used in the
instantiation process applies in a completely similar way to class names in
parameterized object-oriented modules.

As we saw in Section~\ref{module-expressions}, it is possible to import a
module expression in which a parameterized module is instantiated by some of
the formal parameters of the parameterized module in which it is
imported. This is done by using the label of some of the parameters in the
interface of a module, say \mbox{$\texttt{L}_k\texttt{\ ::\ T}_k$}, in a
module expression in which some parameterized module \texttt{N} with formal
parameter $\texttt{T}_k$ is instantiated with $\texttt{L}_k$, that is, we have
the module expression $\texttt{N[}\ldots\texttt{L}_k\ldots\texttt{]}$. In this
case, $\texttt{L}_k$ is considered as the identity view for the theory
$\texttt{T}_k$ with $\texttt{L}_k$ as name. Note that to be able to check
whether a label in the interface of a module is used in an instantiation of
this form, in the evaluation of a module expression the list of parameters of
the module in which the module expression appears must be available. This is
the reason why the \texttt{evalModExp} function was defined with
\texttt{ParameterList} as one of the sorts in its arity (see
Section~\ref{evalModExp}). For module expressions appearing outside of any
module, that is, in commands, etc., this list will be set to
\texttt{nilParameterList}.

Note that this kind of instantiation may produce a `cascade' effect. The
module being instantiated may itself import module expressions in which labels
of some of its parameter theories are used in the instantiation of some module
expression in its body. This is handled by `preparing' the module expressions
appearing in the importation declarations of the module
(\texttt{prepareImportList}). This process consists in changing the labels of
the interface of the module being instantiated which are used in the
importations of module expressions by the corresponding view names
(\texttt{prepareModName}). After completing the generation of the module
resulting from the evaluation of the module expression, this module will be
evaluated with the \texttt{evalUnit} function, producing the evaluation of
these new module expressions. In any extension of the language, new equations
for the function \texttt{prepareModName} will have to be added for each new
kind of module expression being defined.

In Sections~\ref{renaming} and~\ref{extension} we shall see how new equations
completing the semantics of \texttt{prepareModName} are added for each
new module expression being defined. In the case of the renaming module
expression, the renaming maps will have to be prepared as well, to adjust the
sort names being renamed to the conventions discussed above.

As for any other module expression being defined, in addition to the operator
declaration for the constructor of the instantiation module expression,
equations completing the semantics of operators \texttt{evalModExp},
\texttt{modNameToQidList}, and \texttt{setUpModExpDependencies} have to be
given.

\small
\begin{verbatim}
%)

fmod INST-EXPR is
  pr EVALUATION .
  pr VIEW-MAP-SET-APPL-ON-UNIT .
  inc MOD-EXPR .
  inc MOD-NAME .

***(%
\end{verbatim}
\normalsize

We start by giving the new constructor for sort \texttt{ModExp}. Note that the
modules \texttt{MOD-EXPR} and \texttt{MOD-NAME} have been imported in
\texttt{including} mode.

\small
\begin{verbatim}
%)

  op _<_> : ModExp ViewExp -> ModExp .

  vars QI X Y W Z : Qid .
  var QIL : QidList .
  vars M M' : Module .
  vars U U' : Unit .
  vars ME ME' : ModExp .
  var MN : ModName .
  vars MNS MNS' : ModNameSet .
  vars VE VE' VE'' : ViewExp .
  vars VES VES' : ViewExpSet .
  var IS : InfoSet .
  var DB : Database . 
  vars PL PL' PL'' : ParameterList .
  vars EIL EIL' EIL'' : EImportList .
  var VMAPS : ViewMapSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  vars QI' F F' S S' A A' L L' V : Qid .
  var SL : QidList .
  var SS : QidSet .
  vars ES ES' : ESort .
  var ESL : ESortList .
  vars ESS ESS' ESS'' : ESortSet .
  vars T T' : Term .
  var TL : TermList .
  var EVDS : EVarDeclSet .
  var CDS : ClassDeclSet .
  var ADS : AttrDeclSet .
  var B : Bool .
  var AtS : AttrSet .
  var VMAP : ViewMap .
  var N : MachineInt .
  var VI : View .

***(%
\end{verbatim}
\normalsize

\end{comment}

In the input given by the user, the operator \verb~_[_]~ is used both
for the instantiation of module expressions, and for expressions
parameterizing the module \texttt{META-LEVEL} with a list of module
names. The function \texttt{evalModExp} distinguishes these two cases,
calling the function \texttt{instantiation} in the former and the
function \texttt{prepareMetalevel} in the latter.

\small
\begin{verbatim}
%)

  op instantiation : ModName ViewExp ParameterList Database -> Database .
  op prepareMetalevel : ViewExp Database -> Database .

  ceq evalModExp(_<_>(ME, VE), PL, DB) 
    = if ME == 'META-LEVEL
      then prepareMetalevel(VE, DB)
      else instantiation(ME, VE, PL, evalModExp(ME, PL, DB))
      fi
      if not unitInDatabase(_<_>(ME, VE), DB) .

***(%
\end{verbatim}
\normalsize

The function \texttt{prepareMetalevel} creates a new module with the module
expression being evaluated as name, which imports the predefined
\texttt{META-LEVEL} module. For each module name \texttt{I} in the list
given as parameter of the expression, the declaration of a constant \texttt{I}
of sort \texttt{Module} and an equation identifying such constant with the
metarepresentation of the module with such name in the database are added to
the module being created.

\small
\begin{verbatim}
%)

  op prepareMetalevelAux : ViewExp Unit Database -> Database .

  eq prepareMetalevel(VE, DB)
    = prepareMetalevelAux(VE, 
        addImportList((including 'META-LEVEL .),
          setName(emptyStrFModule, _<_>('META-LEVEL, VE))), DB) .

  eq prepareMetalevelAux(_|_(QI, VE), U, DB)
    = if QI inModNameSet builtIns
      then prepareMetalevelAux(VE, U,
             warning(DB, 
               ('WARNING: 'META-LEVEL '`[ QI '`] 'not 'supported)))
      else prepareMetalevelAux(VE,
             addOpDeclSet((op QI : nil -> 'Module [none] .), 
               addEquationSet(
                 (eq {QI}'Module = up(getFlatUnit(QI, DB)) .), U)),
             DB) 
      fi .
  eq prepareMetalevelAux(nullViewExp, U, DB) = evalUnit(U, DB) .

***(%
\end{verbatim}
\normalsize

The function \texttt{labelInParameterList} checks whether the quoted
identifier given as first argument is used as a label in the list of
parameters given as second argument.

\small
\begin{verbatim}
%)

  op labelInParameterList : Qid ParameterList -> Bool .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq labelInParameterList(QI, parameterList((par QI' :: ME), PL))
    = (QI == QI') or-else labelInParameterList(QI, PL) .
  eq labelInParameterList(QI, nilParameterList) = false .

***(%
\end{verbatim}
\normalsize

\end{comment}

The function \texttt{classDeclSetESortSet} returns the set of the names of the
classes in a set of class declarations.

\small
\begin{verbatim}
%)

  op classDeclSetESortSet : ClassDeclSet -> ESortSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq classDeclSetESortSet(((class ES | ADS .) CDS))
    = (ES ; classDeclSetESortSet(CDS)) .
  eq classDeclSetESortSet(none) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

The following `getTheory' functions return the corresponding elements in the
theory part of the structure of the given unit. For example, the function
\texttt{getTheorySortSet} returns the set of sorts declared in the ``loose
part'' of the structure of the unit in the database having the name indicated
as first argument.

\small
\begin{verbatim}
%)

  op getTheorySortSet : ModName Database -> ESortSet .
  op getTheoryClassSet : ModName Database -> ESortSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op getTheorySortSetAux : EImportList Database -> ESortSet .
  op getTheoryClassSetAux : EImportList Database -> ESortSet .

  eq getTheorySortSet(MN, DB)
    = if getTopUnit(MN, DB) : StrTheory
      then (getTheorySortSetAux(importList(getTopUnit(MN, DB)), DB) ;
            sortSet(sortDecl(getTopUnit(MN, DB))))
      else none
      fi .

  eq getTheorySortSetAux(((including MN .) EIL), DB)
    = (getTheorySortSet(MN, DB) ; getTheorySortSetAux(EIL, DB)) .
  eq getTheorySortSetAux(nil, DB) = none .

  eq getTheoryClassSet(MN, DB)
    = if getTopUnit(MN, DB) : StrOTheory 
            and not getTopUnit(MN, DB) : StrSTheory
      then (getTheoryClassSetAux(importList(getTopUnit(MN, DB)), DB) ;
            classDeclSetESortSet(classDeclSet(getTopUnit(MN, DB))))
      else none
      fi .

  eq getTheoryClassSetAux(((including MN .) EIL), DB)
    = (getTheoryClassSet(MN, DB) ; getTheoryClassSetAux(EIL, DB)) .
  eq getTheoryClassSetAux(nil, DB) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

The `get' functions return the corresponding elements in the structure of the
given unit. For example, \texttt{getSortSet} returns all the sorts declared
in the structure of the unit in the database having the name given as first
argument.

\small
\begin{verbatim}
%)

  op getSortSet : ModName Database -> ESortSet .
  op getClassSet : ModName Database -> ESortSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op getSortSetAux : EImportList Database -> ESortSet .
  op getClassSetAux : EImportList Database -> ESortSet .

  eq getSortSet(MN, DB)
    = (getSortSetAux(importList(getTopUnit(MN, DB)), DB) ;
       sortSet(sortDecl(getTopUnit(MN, DB)))) .

  eq getSortSetAux(((including MN .) EIL), DB)
    = (getSortSet(MN, DB) ; getSortSetAux(EIL, DB)) .
  eq getSortSetAux(nil, DB) = none .

  eq getClassSet(MN, DB)
    = (getClassSetAux(importList(getTopUnit(MN, DB)), DB) ;
       classDeclSetESortSet(classDeclSet(getTopUnit(MN, DB)))) .

  eq getClassSetAux(((including MN .) EIL), DB)
    = (getClassSet(MN, DB) ; getClassSetAux(EIL, DB)) .
  eq getClassSetAux(nil, DB) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

As pointed out in Section~\ref{parameterized-modules}, in a parameterized
module all occurrences of sorts or classes coming from the parameter theories
have to be qualified. \texttt{createCopy} is the function used for
creating these renamed copies of the parameters. As also explained in
Section~\ref{parameterized-modules}, if a parameter theory is structured, the
renaming is carried out not only at the top level, but for the entire
``theory part'' in the structure.

The function \texttt{createCopy} calls an auxiliary function,
\texttt{prepareParameter}, which recursively proceeds through all the
subtheories of the given theory. For each theory in the structure, the
required set of maps is generated and applied to such a theory using
the \texttt{applyMapSetToUnit} function discussed in
Section~\ref{applyMapSetToUnit}, which is then evaluated and entered
into the database. Note that the renamings to which a theory is
subjected must also be applied to the theories importing it. The new
database and the renaming maps applied to the theory will have to be
returned by the function.

\begin{comment}
To be able to iterate on the list of importations of a theory, the
function \texttt{prepareParameter3} also takes as argument a list of
importations. The function returns a tuple composed by the set of maps
applied, the database resulting from the evaluation of such theory, the list
of importation declarations after having gone through all the subunits, and a
`flag' indicating whether the considered subunit is a theory or not. The
function returns this boolean value to avoid checking whether a particular
subunit is a theory or a module and then changing its importation declaration
accordingly.
\end{comment}

The function \texttt{prepareParameter} makes a copy of the theory specified by
the name given as first argument and of all its subtheories (only theories, no
modules), and qualifies all the sorts appearing in it with the label given in
the declaration of the parameter, which is given as second argument.

\begin{comment}

\small
\begin{verbatim}
%)

  sort ViewMapSetDatabaseTheoryFlagImportList4Tuple  .
  op <_;_;_;_> : ViewMapSet Database Bool EImportList 
        -> ViewMapSetDatabaseTheoryFlagImportList4Tuple .
  op mapSet : 
        ViewMapSetDatabaseTheoryFlagImportList4Tuple -> ViewMapSet .
  op database : 
        ViewMapSetDatabaseTheoryFlagImportList4Tuple -> Database .
  op theoryFlag : 
        ViewMapSetDatabaseTheoryFlagImportList4Tuple -> Bool .
  op importList : 
        ViewMapSetDatabaseTheoryFlagImportList4Tuple -> EImportList .
  eq mapSet(< VMAPS ; DB ; B ; EIL >) = VMAPS .
  eq database(< VMAPS ; DB ; B ; EIL >) = DB .
  eq theoryFlag(< VMAPS ; DB ; B ; EIL >) = B .
  eq importList(< VMAPS ; DB ; B ; EIL >) = EIL .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op createCopy : ModExp Parameter Database -> Database .
  op prepareParameter : ModName Qid Database -> Database .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op prepareParameter2 : ModName Qid Database 
        -> ViewMapSetDatabaseTheoryFlagImportList4Tuple .
  op prepareParameter3 : EImportList EImportList Qid ViewMapSet Database 
        -> ViewMapSetDatabaseTheoryFlagImportList4Tuple .

  op sortMapSetParameter : Qid ESortSet -> MapSet .
  op classMapSetParameter : Qid ESortSet -> MapSet .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq createCopy(ME, (par X :: ME'), DB)
    = if ME =/= ME' or-else unitInDatabase((par X :: ME), DB)
      then DB
      else prepareParameter(ME, X, DB)
      fi .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq prepareParameter(ME, X, DB)
    = database(prepareParameter2(ME, X, DB)) .

  eq prepareParameter2(ME, X, DB)
    = if getTopUnit(ME, DB) : StrTheory
      then < (mapSet(
                prepareParameter3(
                  importList(getTopUnit(ME, DB)), nil, X, none, DB)),
              sortMapSetParameter(X,
                sortSet(sortDecl(getTopUnit(ME, DB)))),
              classMapSetParameter(X,
                classSet(classDeclSet(getTopUnit(ME, DB))))) ;
              *** non-parameterized theories by the moment
             (if unitInDatabase((par X :: ME), DB)
              then DB
              else evalUnit(
                     setImportList(
                       setName(
                         applyMapSetToUnit(
                           (mapSet(
                              prepareParameter3(
                                importList(getTopUnit(ME, DB)), 
                                nil, X, none, DB)),
                            sortMapSetParameter(X,
                              sortSet(sortDecl(getTopUnit(ME, DB)))),
                            classMapSetParameter(X,
                              classSet(classDeclSet(getTopUnit(ME, DB))))),
                           getTopUnit(ME, DB),
                           getSignature(ME, DB)),
                         (par X :: ME)),
                       importList(
                         prepareParameter3(
                           importList(getTopUnit(ME, DB)), nil, X, none, DB))),
                     database(
                       prepareParameter3(
                          importList(getTopUnit(ME, DB)), nil, X, none, DB)))
              fi) ;
             true ;
             nil >
      else < none ; DB ; false ; nil >
      fi .

  eq prepareParameter3(((including ME .) EIL), EIL', X, VMAPS, DB)
    = if theoryFlag(prepareParameter2(ME, X, DB)) == true
      then prepareParameter3(
             EIL, (EIL' (including (par X :: ME) .)), X, 
             (VMAPS, mapSet(prepareParameter2(ME, X, DB))),
             database(prepareParameter2(ME, X, DB)))
      else prepareParameter3(EIL, (EIL' (including ME .)), X, VMAPS, DB)
      fi .
  eq prepareParameter3(nil, EIL, X, VMAPS, DB)
    = < VMAPS ; DB ; false ; EIL > .
            
  eq sortMapSetParameter(X, (S ; SS))
    = ((sort S to conc(S, conc('., X))), sortMapSetParameter(X, SS)) .
  eq sortMapSetParameter(X, none) = none .

  eq classMapSetParameter(X, (S ; SS))
    = ((class S to conc(S, conc('., X))), classMapSetParameter(X, SS)) .
  eq classMapSetParameter(X, none) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

When one of the labels of the interface of a module is being used in a module
expression to instantiate some formal parameter of a module, then, in the
evaluation of such module expression the qualification of all sorts and class
names coming from the theory part of the parameter theory have to be changed
according to such a label. In the evaluation of an instantiation module
expression this is done by generating the corresponding renaming maps, which
are then applied to the module being instantiated. Given labels \texttt{L} and
\texttt{L'}, for each sort or class name \texttt{S} in the set given as
argument, a map of the form \verb~S.L to S.L'~ is generated.

Since for the time being we do not handle parameterized theories, we
assume that there can only be non-qualified sorts and classes in
theories.

\small
\begin{verbatim}
%)

  op generateMapSetQualifiedSortSet : Qid Qid QidSet -> MapSet .
  op generateMapSetQualifiedClassSet : Qid Qid QidSet -> MapSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq generateMapSetQualifiedSortSet(X, Y, (S ; SS))
    = ((sort conc(S, conc('., X)) to conc(S, conc('., Y))),
       generateMapSetQualifiedSortSet(X, Y, SS)) .
  eq generateMapSetQualifiedSortSet(X, Y, none) = none .

  eq generateMapSetQualifiedClassSet(X, Y, (S ; SS))
    = ((class conc(S, conc('., X)) to conc(S, conc('., Y))),
       generateMapSetQualifiedClassSet(X, Y, SS)) .
  eq generateMapSetQualifiedClassSet(X, Y, none) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

The function \texttt{prepareViewMapSet} takes the map set of a view and
prepares it to be used in an instantiation by transforming sort and class
names into their qualified form, if required (sorts and class names in a view
have to be qualified only if they were defined in a theory).

The \texttt{prepareViewMapSet} function takes five arguments: The set of maps
to be prepared, the label with which the sorts to be renamed have to be
qualified, the set of sorts in the theory part of the source of the view, and
the set of sorts and class names in the theory part of the target of the view.

Note that we assume that there is a sort map and a class map for each sort and
class in the theory part of the source of the view. Therefore, sorts and
class names appearing as sources of sort and class maps are systematically
qualified. The sorts or class names used in the targets of the maps will be
qualified only if they were declared in a theory. In maps for operators in
which the arity and coarity are specified, or for those going to derived terms,
the sorts appearing in the arity or coarity of an operator and those used to
qualify terms, or in sort tests in terms, must also be qualified. However, in
these cases the qualification cannot be done on all sorts, but only on those
defined in the theory parts. This is the reason why the sets of sorts in the
theory parts of the source and target and the set of class names in the target
of the view are given when calling \texttt{prepareViewMapSet}.

\begin{comment}
Since we assume that parameterized sorts of the form \verb~eSort(ES, VE)~ only
occur in parameterized modules, and that a theory cannot parameterized, if the
target of a map is a parameterized sort or class name then the target of the
view cannot be a theory. This assumption is used in the the following
equations defining the preparation of sets of view maps.
\end{comment}

\small
\begin{verbatim}
%)

  op prepareViewMapSet : 
        ViewMapSet Qid ESortSet ESortSet ESortSet -> ViewMapSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op prepareESortList : ESortList Qid ESortSet -> ESortList .
  op prepareVarDeclSet : EVarDeclSet Qid ESortSet -> EVarDeclSet .
  op prepareTerm : TermList Qid ESortSet -> TermList .

  eq prepareViewMapSet(((sort S to S'), VMAPS), X, ESS, ESS', ESS'')
    = ((if S' inSortSet ESS'
        then (sort conc(S, conc('., X)) to conc(S', conc('., X)))
        else (sort conc(S, conc('., X)) to S')
        fi),
       prepareViewMapSet(VMAPS, X, ESS, ESS', ESS'')) .
  eq prepareViewMapSet(((sort S to eSort(S', VE)), VMAPS), X, ESS, ESS', ESS'')
    = ((if eSort(S', VE) inSortSet ESS'
        then (sort conc(S, conc('., X)) to eSort(conc(S', conc('., X)), VE))
        else (sort conc(S, conc('., X)) to eSort(S', VE))
        fi),
       prepareViewMapSet(VMAPS, X, ESS, ESS', ESS'')) .
  eq prepareViewMapSet(((sort eSort(S, VE) to ES), VMAPS), X, ESS, ESS', ESS'')
    = ((sort eSort(conc(S, conc('., X)), VE) to ES), 
       prepareViewMapSet(VMAPS, X, ESS, ESS', ESS'')) .
  eq prepareViewMapSet(((op F : ESL -> ES to F' [AtS]), VMAPS), 
       X, ESS, ESS', ESS'')
    = ((op F : prepareESortList(ESL, X, ESS) 
        -> prepareESortList(ES, X, ESS) to F' [AtS]), 
       prepareViewMapSet(VMAPS, X, ESS, ESS', ESS'')) .
  eq prepareViewMapSet(((op F to F' [AtS]), VMAPS), X, ESS, ESS', ESS'')
    = ((op F to F' [AtS]), prepareViewMapSet(VMAPS, X, ESS, ESS', ESS'')) .
  eq prepareViewMapSet((termMap(EVDS, T, T'), VMAPS), X, ESS, ESS', ESS'')
    = (termMap(prepareVarDeclSet(EVDS, X, ESS), 
          prepareTerm(T, X, ESS), prepareTerm(T', X, ESS')), 
       prepareViewMapSet(VMAPS, X, ESS, ESS', ESS'')) .
  eq prepareViewMapSet(((msg F : ESL -> ES to F'), VMAPS), X, ESS, ESS', ESS'')
    = ((msg F : prepareESortList(ESL, X, ESS) 
        -> prepareESortList(ES, X, ESS) to F'), 
       prepareViewMapSet(VMAPS, X, ESS, ESS', ESS'')) .
  eq prepareViewMapSet(((msg F to F'), VMAPS), X, ESS, ESS', ESS'')
    = ((msg F to F'), prepareViewMapSet(VMAPS, X, ESS, ESS', ESS'')) .
  eq prepareViewMapSet(((class S to S'), VMAPS), X, ESS, ESS', ESS'')
    = ((if S' inSortSet ESS''
        then (class conc(S, conc('., X)) to conc(S', conc('., X)))
        else (class conc(S, conc('., X)) to S')
        fi),
       prepareViewMapSet(VMAPS, X, ESS, ESS', ESS'')) .
  eq prepareViewMapSet(((class S to eSort(ES, VE)), VMAPS), 
       X, ESS, none, ESS'')
    = ((class conc(S, conc('., X)) to eSort(ES, VE)), 
       prepareViewMapSet(VMAPS, X, ESS, none, ESS'')) .
  eq prepareViewMapSet(((attr A . S to A'), VMAPS), X, ESS, ESS', ESS'')
    = ((attr A . conc(S, conc('., X)) to A'),
       prepareViewMapSet(VMAPS, X, ESS, ESS', ESS'')) .
  eq prepareViewMapSet(((label L to L'), VMAPS), X, ESS, ESS', ESS'')
    = ((label L to L'), prepareViewMapSet(VMAPS, X, ESS, ESS', ESS'')) .
  eq prepareViewMapSet(none, X, ESS, ESS', ESS'') = none .

  eq prepareESortList((S SL), X, (S ; SS))
    = (conc(S, conc('., X)) prepareESortList(SL, X, (S ; SS))) .
  ceq prepareESortList((S SL), X, SS)
    = (S prepareESortList(SL, X, SS))
      if not (S inSortSet SS) .
  eq prepareESortList(nil, X, SS) = nil .

  eq prepareVarDeclSet(((var V : S .) EVDS), X, (S ; ESS))
    = ((var V : conc(S, conc('., X)) .) 
       prepareVarDeclSet(EVDS, X, (S ; ESS))) .
  ceq prepareVarDeclSet(((var V : ES .) EVDS), X, ESS)
    = ((var V : ES .) prepareVarDeclSet(EVDS, X, ESS))
      if not (ES inSortSet ESS) .
  eq prepareVarDeclSet(none, X, ESS) = none .

  eq prepareTerm(F[TL], X, ESS) = F[prepareTerm(TL, X, ESS)] .
  eq prepareTerm((T : ES), X, ESS)
  *** Since there cannot be parameterized theories, if ES is in ESS 
  *** then it is not a parameterized sort.
    = prepareTerm(T, X, ESS) : 
         (if ES inSortSet ESS then conc(ES, conc('., X)) else ES fi) .
  eq prepareTerm((T :: ES), X, ESS)
  *** Since there cannot be parameterized theories, if ES is in ESS 
  *** then it is not a parameterized sort.
    = prepareTerm(T, X, ESS) :: 
         (if ES inSortSet ESS then conc(ES, conc('., X)) else ES fi) .
  eq prepareTerm(V, X, ESS) = V .
  eq prepareTerm({F}S, X, ESS)
  *** Since there cannot be parameterized theories, if S is in ESS 
  *** then it is not a parameterized sort. If it was a parameterized
  *** sort then it would be in its single token form.
    = {F}(if S inSortSet ESS then conc(S, conc('., X)) else S fi) .
  eq prepareTerm((T, TL), X, ESS)
    = (prepareTerm(T, X, ESS), prepareTerm(TL, X, ESS)) .
  eq prepareTerm(error*, X, ESS) = error* .

***(%
\end{verbatim}
\normalsize

\end{comment}

For each parameterized sort
$\texttt{S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]}$ in the body of a
parameterized module with $\texttt{L}_1\ldots\texttt{L}_n$ the labels of the
parameters in the interface of the module, a map of the form 
$\texttt{sort\ S[L}_1\texttt{,}\ldots\texttt{,L}_n\texttt{]\ 
     to\ S[V}_1\texttt{,}\ldots\texttt{,V}_n\texttt{]}$
is generated, where $\texttt{V}_i$ is the name of the view associated to the
label $\texttt{L}_i$ in the set of pairs given as argument.

As we shall see below, in the instantiation process a set of pairs is created.
Each of these pairs is composed of the label of a parameter theory and the
view expression with which it is being instantiated. The sorts
\texttt{QidViewExp}, \texttt{QidViewExpPair}, and \texttt{QidViewExpPairSet}
are defined with their respective constructors. This set of pairs is used by
the functions \texttt{generateMapSetSortSet} and
\texttt{generateMapSetClassSet} to generate the maps mentioned above.

\small
\begin{verbatim}
%)

  sort QidViewExpPair .
  op <_,_> : Qid ViewExp -> QidViewExpPair .
  op qid : QidViewExpPair -> Qid .
  op viewExp : QidViewExpPair -> ViewExp .
  eq qid(< QI , VE >) = QI .
  eq viewExp(< QI , VE >) = VE .

  sort QidViewExpPairSet .
  subsort QidViewExpPair < QidViewExpPairSet .
  op none : -> QidViewExpPairSet .
  op __ : QidViewExpPairSet QidViewExpPairSet -> QidViewExpPairSet
         [assoc comm id: none] .

  vars QIVEPS QIVEPS' : QidViewExpPairSet .

  op generateMapSetSortSet : ESortSet QidViewExpPairSet -> MapSet .
  op generateMapSetClassSet : ESortSet QidViewExpPairSet -> MapSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op generateMapSetSort : ESort ViewExp QidViewExpPairSet -> MapSet .
  op generateMapSetClass : ESort ViewExp QidViewExpPairSet -> MapSet .
  op prepareESort : ESort QidViewExpPairSet -> ESort .
  op prepareESort : ESort ViewExp ViewExp ViewExp QidViewExpPairSet 
        QidViewExpPairSet -> ESort .

  eq generateMapSetSortSet((S ; ESS), QIVEPS)
    = generateMapSetSortSet(ESS, QIVEPS) .
  eq generateMapSetSortSet((eSort(ES, VE) ; ESS), QIVEPS)
    = (generateMapSetSort(ES, VE, QIVEPS), 
       generateMapSetSortSet(ESS, QIVEPS)) .
  eq generateMapSetSortSet(none, QIVEPS) = none .

  eq generateMapSetClassSet((S ; ESS), QIVEPS)
    = generateMapSetClassSet(ESS, QIVEPS) .
  eq generateMapSetClassSet((eSort(ES, VE) ; ESS), QIVEPS)
    = (generateMapSetClass(ES, VE, QIVEPS), 
       generateMapSetClassSet(ESS, QIVEPS)) .
  eq generateMapSetClassSet(none, QIVEPS) = none .

  eq generateMapSetSort(ES, VE, QIVEPS)
    = (sort eSort(ES, VE) to 
         prepareESort(ES, VE, nullViewExp, nullViewExp, QIVEPS, QIVEPS)) .

  eq generateMapSetClass(ES, VE, QIVEPS)
    = (class eSort(ES, VE) to
         prepareESort(ES, VE, nullViewExp, nullViewExp, QIVEPS, QIVEPS)) .

  eq prepareESort(S, QIVEPS) = S .
  eq prepareESort(eSort(ES, VE), QIVEPS)
    = prepareESort(ES, VE, nullViewExp, nullViewExp, QIVEPS, QIVEPS) .

  eq prepareESort(ES, _|_(X, VE), VE', VE'', (< Y , Z > QIVEPS), QIVEPS')
    = if X == Y
      then prepareESort(ES, VE, _|_(VE', Z), VE'', QIVEPS', QIVEPS')
      else prepareESort(ES, _|_(X, VE), VE', VE'', QIVEPS, QIVEPS')
      fi .
  eq prepareESort(
        ES, _|_(X, VE), VE', VE'', (< Y , _;;_(W, Z) > QIVEPS), QIVEPS')
    = if X == Y
      then prepareESort(ES, VE, _|_(VE', W), _|_(VE'', Z), QIVEPS', QIVEPS')
      else prepareESort(ES, _|_(X, VE), VE', VE'', QIVEPS, QIVEPS')
      fi .
  eq prepareESort(ES, _|_(X, VE), VE', VE'', none, QIVEPS')
    = prepareESort(ES, VE, _|_(VE', X), VE'', QIVEPS', QIVEPS') .
  eq prepareESort(ES, nullViewExp, VE, VE', QIVEPS, QIVEPS')
    = if VE' == nullViewExp
      then eSort(ES, VE)
      else eSort(eSort(ES, VE), VE')
      fi .

***(%
\end{verbatim}
\normalsize

\end{comment}

The function \texttt{prepareImportList} takes a list of importation
declarations and a set of pairs composed of a label and a view name, and
returns the list of importations resulting from changing in each of the module
expressions the occurrences of the labels of the interface of the module being
instantiated by the names of the views associated to them in the list of
pairs.

\small
\begin{verbatim}
%)

  op prepareImportList : EImportList QidViewExpPairSet -> EImportList .
  op prepareModName : ModName QidViewExpPairSet -> ModName .
  op prepareModNameAux : ModName ViewExp ViewExp ViewExp 
        QidViewExpPairSet QidViewExpPairSet -> ModName .

  eq prepareImportList(((including MN .) EIL), QIVEPS)
    = ((including prepareModName(MN, QIVEPS) .)
       prepareImportList(EIL, QIVEPS)) .
  eq prepareImportList(nil, QIVEPS) = nil .

  eq prepareModName(_<_>(ME, VE), QIVEPS)
    = prepareModNameAux(ME, VE, nullViewExp, nullViewExp, QIVEPS, QIVEPS) .
  eq prepareModName(QI, QIVEPS) = QI .
  eq prepareModName((par X :: ME), QIVEPS) = (par X :: ME) .

  eq prepareModNameAux(
       ME, _|_(X, VE), VE', VE'', (< Y , Z > QIVEPS), QIVEPS')
    = if X == Y
      then prepareModNameAux(ME, VE, _|_(VE', Z), VE'', QIVEPS', QIVEPS')
      else prepareModNameAux(ME, _|_(X, VE), VE', VE'', QIVEPS, QIVEPS')
      fi .
  eq prepareModNameAux(
        ME, _|_(X, VE), VE', VE'', (< Y , _;;_(W, Z) > QIVEPS), QIVEPS')
    = if X == Y
      then prepareModNameAux(
             ME, VE, _|_(VE', W), _|_(VE'', Z), QIVEPS', QIVEPS')
      else prepareModNameAux(ME, _|_(X, VE), VE', VE'', QIVEPS, QIVEPS')
      fi .
  eq prepareModNameAux(ME, _|_(X, VE), VE', VE'', none, QIVEPS')
    = prepareModNameAux(ME, VE, _|_(VE', X), VE'', QIVEPS', QIVEPS') .
  eq prepareModNameAux(ME, nullViewExp, VE, VE', QIVEPS, QIVEPS')
    = if VE' == nullViewExp
      then _<_>(ME, VE)
      else _<_>(_<_>(ME, VE), VE')
      fi .

***(%
\end{verbatim}
\normalsize

The function \texttt{instantiation} calls the auxiliary function
\texttt{instantiationAux}, which proceeds recursively on each of the
parameters in the interface of the module being instantiated. For each
view, a set of maps to be applied to the module is generated, which
are accumulated in the third argument of the function.

In the base case, when there are no more parameters and no more views, the
maps for the parameterized sorts are also generated, and all maps are then
applied. 

\texttt{instantiationAux} proceeds accumulating also the list of parameters
being modified, the list of importations, and a list of label-view pairs
(\texttt{QidViewExpPair}) associating each label in the interface to the view
used in the instantiation of the theory with such label. This list of pairs is
used to generate the set of maps of the parameterized sorts and to `prepare'
the list of importations as indicated above.

\small
\begin{verbatim}
%)

  op instantiationAux : Unit Unit ViewMapSet ParameterList ParameterList 
        EImportList EImportList ViewExp QidViewExpPairSet ParameterList 
        Database -> Database .

  eq instantiation(ME, VE, PL, DB)
    = instantiationAux(setName(getTopUnit(ME, DB), _<_>(ME, VE)),
        getSignature(ME, DB), none,
        parameterList(getTopUnit(ME, DB)), nilParameterList,
        importList(getTopUnit(ME, DB)), nil, VE, none, PL, DB) .

  eq instantiationAux(U, M, VMAPS,
       parameterList((par X :: ME), PL), PL',
       (EIL (including (par X :: ME) .) EIL'), EIL'',
       _|_(QI, VE), QIVEPS, PL'', DB)
    = if labelInParameterList(QI, PL'')
      then instantiationAux(U, M, 
             (VMAPS,
              generateMapSetQualifiedSortSet(X, QI, 
                getTheorySortSet(ME, DB)),
              generateMapSetQualifiedClassSet(X, QI, 
                getTheoryClassSet(ME, DB))), 
             PL, parameterList(PL', (par QI :: ME)), (EIL EIL'), 
             (EIL'' (including (par QI :: ME) .)),
             VE, (< X , QI > QIVEPS), PL'',
             createCopy(ME, (par QI :: ME), DB))
      else if viewInDatabase(QI, DB)
           then if getTopUnit(target(getView(QI, DB)), DB) : StrTheory
                then instantiationAux(U, M,
                       (VMAPS,
                        prepareViewMapSet(
                          mapSet(getView(QI, DB)), X, 
                          getTheorySortSet(ME, DB), 
                          getTheorySortSet(target(getView(QI, DB)), DB), 
                          getTheoryClassSet(target(getView(QI, DB)), DB))), 
                       PL, 
                       parameterList(PL', (par X :: target(getView(QI, DB)))),
                       (EIL EIL'), 
                       (EIL'' 
                        (including (par X :: target(getView(QI, DB))) .)),
                       VE, 
                       (< X , _;;_(QI, X) > QIVEPS),
                       PL'',
                       createCopy(target(getView(QI, DB)), 
                         (par X :: target(getView(QI, DB))), DB))
                else instantiationAux(U, M, 
                       (VMAPS,
                        prepareViewMapSet(
                          mapSet(getView(QI, DB)), X, 
                          getTheorySortSet(ME, DB), none, none)), 
                       PL, 
                       parameterList(
                         parameterList(
                           getTopUnit(target(getView(QI, DB)), DB)), 
                         PL'),
                       (EIL EIL'), 
                       (EIL'' (including target(getView(QI, DB)) .)),
                       VE, (< X , QI > QIVEPS),
                       PL'', DB)
                fi
           else warning(DB, ('\n 'ERROR: 'view QI 'not 'in 'database))
           fi
      fi .
  eq instantiationAux(U, M, VMAPS, nilParameterList, PL, EIL, EIL', 
       nullViewExp, QIVEPS, PL', DB)
    = evalUnit(
        setImportList(
          setParameterList(
            applyMapSetToUnit(
              (VMAPS, 
               generateMapSetSortSet(
                 (sortSet(sortDecl(U)) ;
                  getSortSetAux(importList(U), DB)), QIVEPS),
               generateMapSetClassSet(
                 (classDeclSetESortSet(classDeclSet(U)) ;
                  getClassSetAux(importList(U), DB)), QIVEPS)),
              U, M),
            PL),
          (prepareImportList(EIL, QIVEPS) EIL')), 
        DB) .
  eq instantiationAux(
       unitError(QIL), U, VMAPS, PL, PL', EIL, EIL', VE, QIVEPS, PL'', DB)
    = warning(DB, QIL) .
  eq instantiationAux(U, M, VMAPS, parameterList((par X :: ME), PL), 
       PL', EIL, EIL', nullViewExp, QIVEPS, PL'', DB)
  = warning(DB, ('\n 'ERROR: 'incorrect 'module modNameToQidList(name(U)))) .
  eq instantiationAux(U, M, VMAPS, nilParameterList, PL, EIL, EIL',
       _|_(QI, VE), QIVEPS, PL', DB)
  = warning(DB, ('\n 'ERROR: 'incorrect 'module modNameToQidList(name(U)))) .

***(%
\end{verbatim}
\normalsize

As pointed out in Section~\ref{module-names}, for each new module
expression constructor being introduced, we need to add equations for the
operator \texttt{modNameToQid}. Since the function to transform view
expressions into lists of quoted identifiers was already defined in
Section~\ref{VIEW-EXPR}, we just need to add the following equation.

\small
\begin{verbatim}
%)

  eq modNameToQidList(_<_>(ME, VE))
    = (modNameToQidList(ME) '`[ viewExpToQidList(VE) '`]) .

***(%
\end{verbatim}
\normalsize

Similarly, we need to give equations for the \texttt{setUpModExpDependencies}
function, presented in Section~\ref{databaseADT}, on the instantiation module
expression. Given a module expression of the form \verb~ME < VE >~ such that
\texttt{ME} is in the database, we need to add \verb~ME < VE >~ to the set of
names of the modules depending on \texttt{ME} and on
\texttt{VE}. Since \texttt{VE} may be a composed view expression, we have to
add the name of the module to each of the views in it. In this way, if
\texttt{ME} or any of the views in \texttt{VE} is redefined or removed from
the database, \verb~ME < VE >~ will be removed as well.

\small
\begin{verbatim}
%)

  eq setUpModExpDependencies(_<_>(ME, VE), 
       database(
         (< ME ; U ; U' ; M ; M' ; MNS ; VES > IS), MNS', VES', QIL))
    = viewExpDependencies(_<_>(ME, VE), VE,
        database(
          (< ME ; U ; U' ; M ; M' ; MNS & _<_>(ME, VE) ; VES > IS),
          MNS', VES', QIL)) .
  eq setUpModExpDependencies(_<_>('META-LEVEL, QI), 
       database(
         (< QI ; U ; U' ; M ; M' ; MNS ; VES > IS), MNS', VES', QIL))
    = database(
        (< QI ; U ; U' ; M ; M' ; MNS & _<_>('META-LEVEL, QI) ; VES > IS), 
        MNS', VES', QIL) .
  ceq setUpModExpDependencies(_<_>(ME, VE), DB)
    = warning(DB, 
         ('\n 'ERROR:
          'module modNameToQidList(ME) 'not 'in 'database '.))
      if (ME =/= 'META-LEVEL) and-then (not unitInDatabase(ME, DB)) .

  op viewExpDependencies : ModName ViewExp Database -> Database .

  ceq viewExpDependencies(MN, _|_(QI, VE), 
        database((< QI ; VI ; MNS > IS), MNS', VES, QIL))
    = viewExpDependencies(MN, VE, 
         database((< QI ; VI ; MNS & MN > IS), MNS', VES, QIL))
      if QI =/= nullViewExp .
  ceq viewExpDependencies(MN, _|_(QI, VE), DB)
    = DB
      if not viewInDatabase(QI, DB) .
  eq viewExpDependencies(MN, nullViewExp, DB) 
    = DB .

***(%
\end{verbatim}
\normalsize

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Renaming of Units} 
\label{renaming}

In addition to the declaration of the constructor for renaming module
expressions, the following module \texttt{RENAMING-EXPR} introduces equations
to treat this new case in the definition of functions \texttt{evalModExp},
\texttt{modNameToQidList}, \texttt{prepareModName}, and
\texttt{setUpUnitDependencies}.

A renaming expression is evaluated by applying the renaming
maps, not only to the top unit, but also to the part of the structure
\emph{affected} by the maps. The renaming process propagates downwards in the
unit hierarchy while the units in the structure are affected by the
renamings. We say that a unit is affected by a set of maps (checked by the
\texttt{moduleAffected} function) when any of the maps is applicable to any of
the declarations in the unit, or in any of its subunits. The application of a
set of maps to a single unit is accomplished by the \texttt{applyMapSetToUnit}
function, discussed in Section~\ref{applyMapSetToUnit}.

\small
\begin{verbatim}
%)

fmod RENAMING-EXPR is
  pr DATABASE .
  pr VIEW-MAP-SET-APPL-ON-UNIT .
  pr EVALUATION .
  inc MOD-EXPR .
  pr MOD-EXPR-EVAL .
  pr INST-EXPR .
  pr MAP .
  pr DECL-EXT-SORT-TO-QID .

  op _*<_> : ModExp MapSet -> ModExp .

  vars ME ME' : ModExp .
  var MNS MNS' : ModNameSet .
  vars M M' : Module .
  vars U U' : Unit .
  var DB : Database .
  vars ES ES' : ESort .
  var QIL : QidList .
  vars VES VES' : ViewExpSet .
  var IS : InfoSet .
  var PL : ParameterList .
  vars EIL EIL' : EImportList .
  var VMAP : ViewMap .
  var VMAPS : ViewMapSet .
  var QIVEPS : QidViewExpPairSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var MN : ModName .
  vars QI QI' QI'' S F F' F'' L L' L'' A A' A'' : Qid .
  vars ES'' C C' C'' : ESort .
  vars ESS : ESortSet .
  var ESL ESL' : ESortList .
  vars T T' T'' T''' : Term .
  var TL : TermList .
  var EOD : EOpDeclSet .
  var EODS : EOpDeclSet .
  vars AtS AtS' : AttrSet .
  var Rl : Rule .
  var RlS : RuleSet .
  var CD : ClassDecl .
  var CDS : ClassDeclSet .
  var ADS : AttrDeclSet .
  var MD : MsgDecl .
  var MDS : MsgDeclSet .
  var MAP : Map .
  var MAPS : MapSet .
  var I : MachineInt .
  var MIL : MachineIntList .
  var H : Hook .
  var HL : HookList .

***(%
\end{verbatim}
\normalsize

\end{comment}

The function \texttt{createCopyRenaming} creates a copy of the part of the
structure of the specified module which is affected by the renaming, applying
to each of the generated modules in the new structure the subset of maps
affecting each one of them. The equation extending the \texttt{evalModExp}
function to the renaming module expression is then reduced to a call to
\texttt{createCopyRenaming} with the appropriate arguments.

\small
\begin{verbatim}
%)

  op createCopyRenaming : ModExp ModExp Unit Database -> Database .

  ceq evalModExp(_*<_>(ME, VMAPS), PL, DB) 
    = createCopyRenaming(ME, _*<_>(ME, VMAPS), 
        getSignature(ME, evalModExp(ME, PL, DB)), 
        evalModExp(ME, PL, DB))
      if not unitInDatabase(_*<_>(ME, VMAPS), DB) .

***(%
\end{verbatim}
\normalsize

The predicate \texttt{moduleAffected} checks whether the module with the name
given as first argument in the database is affected by the set of maps given as
second argument. A module is affected by a map set if any of the maps is
applicable to the module or to any of its submodules.

\small
\begin{verbatim}
%)

  op moduleAffected : ModName ViewMapSet Module Database -> Bool .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op moduleAffectedAux : Unit ViewMapSet Module Database -> Bool .
  op opDeclSetAffected : EOpDeclSet ViewMapSet Module -> Bool .
  op sortSetAffected : ESortSet ViewMapSet -> Bool .
  op ruleSetAffected : RuleSet ViewMapSet -> Bool .
  op importListAffected : EImportList ViewMapSet Module Database -> Bool .
  op classDeclSetAffected : ClassDeclSet ViewMapSet -> Bool .
  op msgDeclSetAffected : MsgDeclSet ViewMapSet Module -> Bool .

  eq moduleAffected(MN, VMAPS, M, DB) 
    = moduleAffectedAux(getTopUnit(MN, DB), VMAPS, M, DB) .

  eq moduleAffectedAux(U, VMAPS, M, DB) 
    = sortSetAffected(sortSet(sortDecl(U)), VMAPS) or-else 
       (opDeclSetAffected(opDeclSet(U), VMAPS, M) or-else 
          ((if U : FUnit
            then false
            else ruleSetAffected(ruleSet(U), VMAPS) or-else 
                 (if U : SUnit
                  then false
                  else classDeclSetAffected(classDeclSet(U), VMAPS) or-else
                       msgDeclSetAffected(msgDeclSet(U), VMAPS, M)
                  fi)
            fi) or-else
            importListAffected(importList(U), VMAPS, M, DB))) .

  eq importListAffected(((including MN .) EIL), VMAPS, M, DB)
    = if (MN inModNameSet builtIns)
      then importListAffected(EIL, VMAPS, M, DB)
      else (moduleAffected(MN, VMAPS, M, DB)
            or-else importListAffected(EIL, VMAPS, M, DB))
      fi .
  eq importListAffected(nil, VMAPS, M, DB) = false .

  eq opDeclSetAffected(
        ((op F : ESL -> ES [AtS] .) EODS), ((op F' to F'' [AtS']), VMAPS), M)
    = (F == F') or-else
      (opDeclSetAffected((op F : ESL -> ES [AtS] .), VMAPS, M) or-else
       opDeclSetAffected(EODS, ((op F' to F'' [AtS']), VMAPS), M)) .
  eq opDeclSetAffected(((op F : ESL -> ES [AtS] .) EODS), 
        ((op F' : ESL' -> ES' to F'' [AtS']), VMAPS), M) 
    = ((F == F') and-then eSameComponent(M, (ESL ES), (ESL' ES'))) 
      or-else 
       (opDeclSetAffected((op F : ESL -> ES [AtS] .), VMAPS, M) or-else
        opDeclSetAffected(EODS, 
           ((op F' : ESL' -> ES' to F'' [AtS']), VMAPS), M)) .
  ceq opDeclSetAffected((EOD EODS), (VMAP, VMAPS), M) 
    = opDeclSetAffected((EOD EODS), VMAPS, M)
      if not (VMAP : OpMap) .
  eq opDeclSetAffected(EODS, none, M) = false .
  eq opDeclSetAffected(none, VMAPS, M) = false .

  eq sortSetAffected((ES ; ESS), ((sort ES' to ES''), VMAPS)) 
    = (ES == ES') or-else
      (sortSetAffected(ES, VMAPS) or-else
       sortSetAffected(ESS, ((sort ES' to ES''), VMAPS))) .
  ceq sortSetAffected((ES ; ESS), (VMAP, VMAPS)) 
    = sortSetAffected((ES ; ESS), VMAPS)
      if not (VMAP : SortMap) .
  eq sortSetAffected(ESS, none) = false .
  eq sortSetAffected(none, VMAPS) = false .

  eq ruleSetAffected(((rl [L] : T => T' .) RlS), ((label L' to L''), VMAPS)) 
    = (L == L') or-else
      (ruleSetAffected((rl [L] : T => T' .), VMAPS) or-else
       ruleSetAffected(RlS, ((label L' to L''), VMAPS))) .
  eq ruleSetAffected(((crl [L]: T => T' if T'' = T''' .) RlS), 
        ((label L' to L''), VMAPS))
    = (L == L') or-else
      (ruleSetAffected((crl [L]: T => T' if T'' = T''' .), VMAPS) or-else
       ruleSetAffected(RlS, ((label L' to L''), VMAPS))) .
  ceq ruleSetAffected((Rl RlS), (VMAP, VMAPS)) 
    = ruleSetAffected((Rl RlS), VMAPS)
      if not (VMAP : LabelMap) .
  eq ruleSetAffected(RlS, none) = false .
  eq ruleSetAffected(none, VMAPS) = false .

  eq classDeclSetAffected(((class C | ADS .) CDS), ((class C' to C''), VMAPS))
    = (C == C') or-else
      (classDeclSetAffected((class C | ADS .), VMAPS) or-else
       classDeclSetAffected(CDS, ((class C' to C''), VMAPS))) .
  eq classDeclSetAffected(((class C | ((attr A : ES), ADS) .) CDS), 
        ((attr A' . C' to A''), VMAPS))
    = if C == C'
      then (A == A') or-else
           (classDeclSetAffected(
              ((class C | ADS .) CDS), ((attr A' . C' to A''), VMAPS))
            or-else
            classDeclSetAffected(CDS, VMAPS))
      else classDeclSetAffected((class C | ((attr A : ES), ADS) .), VMAPS)
           or-else
           classDeclSetAffected(CDS, ((attr A' . C' to A''), VMAPS))
      fi .
  ceq classDeclSetAffected((CD CDS), (VMAP, VMAPS)) 
    = classDeclSetAffected((CD CDS), VMAPS)
      if not (VMAP : ClassMap or VMAP : AttrMap) .
  eq classDeclSetAffected(CDS, none) = false .
  eq classDeclSetAffected(none, VMAPS) = false .

  eq msgDeclSetAffected(((msg F : ESL -> ES .) MDS), 
        ((msg F' to F''), VMAPS), M)
    = (F == F') or-else
      (msgDeclSetAffected((msg F : ESL -> ES .), VMAPS, M) or-else
       msgDeclSetAffected(MDS, ((msg F' to F''), VMAPS), M)) .
  eq msgDeclSetAffected(((msg F : ESL -> ES .) MDS), 
        ((msg F' : ESL' -> ES' to F''), VMAPS), M)
    = ((F == F') and-then eSameComponent(M, (ESL ES), (ESL' ES'))) 
      or-else
      (msgDeclSetAffected((msg F : ESL -> ES .), VMAPS, M) or-else
       msgDeclSetAffected(MDS, ((msg F' : ESL' -> ES' to F''), VMAPS), M)) .
  ceq msgDeclSetAffected((MD MDS), (VMAP, VMAPS), M) 
    = msgDeclSetAffected((MD MDS), VMAPS, M)
      if not (VMAP : MsgMap) .
  eq msgDeclSetAffected(MDS, none, M) = false .
  eq msgDeclSetAffected(none, VMAPS, M) = false .

***(%
\end{verbatim}
\normalsize

\end{comment}

The function \texttt{mapSetRestriction} returns the subset of the view maps
given as second argument that affect the given module.

\small
\begin{verbatim}
%)

  op mapSetRestriction : Unit ViewMapSet Module Database -> ViewMapSet .

  eq mapSetRestriction(U, (VMAP, VMAPS), M, DB)
    = if moduleAffectedAux(U, VMAP, M, DB)
      then (VMAP, mapSetRestriction(U, VMAPS, M, DB))
      else mapSetRestriction(U, VMAPS, M, DB)
      fi .
  eq mapSetRestriction(U, none, M, DB) = none .

***(%
\end{verbatim}
\normalsize

\begin{comment}
Since in the evaluation process we have to go downwards in the structure, and
since we may have maps of operations with the domain given by sorts that are
not in the submodules but which have other sorts in the submodules in the same
connected components, we have to carry along the signature of the module at
the top to make all the calls to the engine.
\end{comment}

We proceed downwards while the set of maps affects the module, but we
do so restricting the set of maps to the subset affecting the
module. Since operator and message maps in which arity and coarity are
specified must be applied to the whole subsort-overloaded family of
operators or messages, we have to carry along the signature of the
module at the top to make all the calls to the engine. Note that we
may have maps of operations or messages with the domain given by sorts
that are not in the submodules but which have other sorts in the
submodules in the same connected components.

\small
\begin{verbatim}
%)

  op applyMapSetRecursively : 
        MapSet EImportList EImportList Unit Module Database -> Database .

  eq createCopyRenaming(ME, _*<_>(ME, VMAPS), M, DB)
    = if not unitInDatabase(_*<_>(ME, VMAPS), DB)
      then applyMapSetRecursively(
             VMAPS, importList(getTopUnit(ME, DB)), nil,
             setName(applyMapSetToUnit(VMAPS, getTopUnit(ME, DB), M), 
               _*<_>(ME, VMAPS)), 
             M, DB)
      else DB
      fi .
  eq createCopyRenaming(ME, ME', unitError(QIL), DB) = warning(DB, QIL) .

  eq applyMapSetRecursively(
       VMAPS, ((including MN .) EIL), EIL', U, M, DB) 
   = if MN inModNameSet builtIns or-else 
        not moduleAffectedAux(getTopUnit(MN, DB), VMAPS, 
              setVarDeclSet(M, 
                eSortToQid(varDeclSet(getTopUnit(MN, DB)))),
              DB) 
     then applyMapSetRecursively(
            VMAPS, EIL, ((including MN .) EIL'), U, M, DB)
     else applyMapSetRecursively(
            VMAPS, EIL, 
            ((including
                (MN *< mapSetRestriction(getTopUnit(MN, DB), VMAPS, 
                         setVarDeclSet(M, 
                           eSortToQid(
                             varDeclSet(getTopUnit(MN, DB)))), DB) >) .)
             EIL'), U, M, 
            createCopyRenaming(MN, 
              (MN *< mapSetRestriction(getTopUnit(MN, DB), VMAPS, 
                       setVarDeclSet(M, 
                         eSortToQid(
                           varDeclSet(getTopUnit(MN, DB)))), DB) >), 
              setVarDeclSet(M, 
                eSortToQid(varDeclSet(getTopUnit(MN, DB)))),
              DB))
      fi .
  eq applyMapSetRecursively(VMAPS, nil, EIL, U, M, DB) 
    = evalUnit(setImportList(U, EIL), DB) .
  eq applyMapSetRecursively(VMAPS, EIL, EIL', unitError(QIL), M, DB) 
    = warning(DB, QIL) .

***(%
\end{verbatim}
\normalsize

The definition of the function \texttt{modNameToQidList} on the renaming
module expression has to take care of transforming into a quoted identifier
list the set of view maps given in the module expression.

\small
\begin{verbatim}
%)

  op mapSetToQidList : MapSet -> QidList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op attrSetToQidList : AttrSet -> QidList .
  op hookListToQidList : HookList -> QidList .
  op termListToQidList : TermList -> QidList .
  op machineIntListToQidList : MachineIntList -> QidList .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq modNameToQidList(_*<_>(ME, MAPS))
    = ((modNameToQidList(ME) '* '`( mapSetToQidList(MAPS) '`))) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  ceq mapSetToQidList(((op F to F' [AtS]), MAPS))
    = if AtS == none 
      then ('op F 'to F' '`, mapSetToQidList(MAPS))
      else ('op F 'to F' '`[ attrSetToQidList(AtS) '`] '`, 
            mapSetToQidList(MAPS))
      fi
      if MAPS =/= none .
  eq mapSetToQidList((op F to F' [AtS]))
    = if AtS == none 
      then ('op F 'to F')  
      else ('op F 'to F' '`[ attrSetToQidList(AtS) '`]) 
      fi .
  ceq mapSetToQidList(((op F : ESL -> ES to F' [AtS]), MAPS))
    = if AtS == none 
      then ('op F ': eSortToQidList(ESL) '-> eSortToQidList(ES) 'to F' '`, 
            mapSetToQidList(MAPS))
      else ('op F ': eSortToQidList(ESL) '-> eSortToQidList(ES) 'to F' 
            '`[ attrSetToQidList(AtS) '`] '`, mapSetToQidList(MAPS))
      fi 
      if MAPS =/= none .
  eq mapSetToQidList((op F : ESL -> ES to F' [AtS]))
    = if AtS == none 
      then ('op F ': eSortToQidList(ESL) '-> eSortToQidList(ES) 'to F')
      else ('op F ': eSortToQidList(ESL) '-> eSortToQidList(ES) 'to F' 
            '`[ attrSetToQidList(AtS) '`]) 
      fi .
  ceq mapSetToQidList(((sort ES to ES'), MAPS))
    = ('sort eSortToQidList(ES) 'to eSortToQidList(ES') '`, 
       mapSetToQidList(MAPS))
      if MAPS =/= none .
  eq mapSetToQidList((sort ES to ES'))
    = ('sort eSortToQidList(ES) 'to eSortToQidList(ES')) .
  ceq mapSetToQidList(((label L to L'), MAPS))
    = ('label L 'to L' '`, mapSetToQidList(MAPS))
      if MAPS =/= none .
  eq mapSetToQidList((label L to L')) = ('label L 'to L') .
  ceq mapSetToQidList(((msg F to F'), MAPS))
    = ('msg F 'to F' '`, mapSetToQidList(MAPS))
      if MAPS =/= none .
  eq mapSetToQidList((msg F to F')) = ('msg F 'to F') .
  ceq mapSetToQidList(((msg F : ESL  -> ES to F'), MAPS))
    = ('msg F ': eSortToQidList(ESL) '-> eSortToQidList(ES) 'to F' '`, 
         mapSetToQidList(MAPS))
      if MAPS =/= none .
  eq mapSetToQidList((msg F : ESL -> ES to F'))
    = ('msg F ': eSortToQidList(ESL) '-> eSortToQidList(ES) 'to F') .
  ceq mapSetToQidList(((class ES to ES'), MAPS))
    = ('class eSortToQidList(ES) 'to eSortToQidList(ES') '`, 
       mapSetToQidList(MAPS))
      if MAPS =/= none .
  eq mapSetToQidList((class ES to ES'))
    = ('class eSortToQidList(ES) 'to eSortToQidList(ES')) .
  ceq mapSetToQidList(((attr QI . ES to QI'), MAPS))
    = ('attr QI '. eSortToQidList(ES) 'to QI' '`, mapSetToQidList(MAPS))
      if MAPS =/= none .
  eq mapSetToQidList((attr QI . ES to QI'))
    = ('attribute QI 'in eSortToQidList(ES) 'to QI') .
  eq mapSetToQidList(none) = nil .

  eq attrSetToQidList(none) = nil .
  eq attrSetToQidList((assoc AtS)) = ('assoc attrSetToQidList(AtS)) .
  eq attrSetToQidList((comm AtS)) = ('comm attrSetToQidList(AtS)) .
  eq attrSetToQidList((ctor AtS)) = ('ctor attrSetToQidList(AtS)) .
  eq attrSetToQidList((memo AtS)) = ('memo attrSetToQidList(AtS)) .
  eq attrSetToQidList((special(HL) AtS))
    = ('special '`( hookListToQidList(HL) '`) attrSetToQidList(AtS)) .
  eq attrSetToQidList((id(T) AtS))
    = ('id: termListToQidList(T) attrSetToQidList(AtS)) .
  eq attrSetToQidList((right-id(T) AtS))
    = ('right-id: termListToQidList(T) attrSetToQidList(AtS)) .
  eq attrSetToQidList((left-id(T) AtS))
    = ('left-id: termListToQidList(T) attrSetToQidList(AtS)) .
  eq attrSetToQidList((prec(I) AtS))
    = ('prec machineIntListToQidList(I) attrSetToQidList(AtS)) .
  eq attrSetToQidList((strat(MIL) AtS))
    = ('strat '`( machineIntListToQidList(MIL) '`) attrSetToQidList(AtS)) .
  eq attrSetToQidList((gather(QIL) AtS))
    = ('gather QIL attrSetToQidList(AtS)) .
  eq attrSetToQidList((none).AttrSet) = nil .

  eq hookListToQidList((id-hook(QI, QIL) HL))
    = ('id-hook QI '`, '`( QIL '`) hookListToQidList(HL)) .
  eq hookListToQidList((op-hook(QI, QI', QIL, QI'') HL))
    = ('op-hook QI '`( QI' ': QIL '-> QI'' '`) hookListToQidList(HL)) .
  eq hookListToQidList((term-hook(QI, T) HL))
    = ('term-hook '`( QI '`, termListToQidList(T) '`) hookListToQidList(HL)) .

  eq termListToQidList(QI) = QI .
  eq termListToQidList({F}S) = ('`{ F '`} S) .
  eq termListToQidList(F[TL]) = (F '`( termListToQidList(TL) '`)) .
  eq termListToQidList(T : ES)
    = (termListToQidList(T) ': eSortToQidList(ES)) .
  eq termListToQidList(T :: ES)
    = (termListToQidList(T) ':: eSortToQidList(ES)) .
  eq termListToQidList((T, TL))
    = (termListToQidList(T) '`, termListToQidList(TL)) .

  eq machineIntListToQidList((I MIL))
    = (index(', I) machineIntListToQidList(MIL)) .
  eq machineIntListToQidList(nil) = nil .

***(%
\end{verbatim}
\normalsize

\end{comment}

Let us now give the equations for \texttt{setUpModExpDependencies} on the
renaming module expression.  Given a module expression of the form 
\verb~ME *< VMAPS >~ such that \texttt{ME} is in the database, we just need to
add \verb~ME *< VMAPS >~ to the set of names of the modules depending on
\texttt{ME}. In this way, if \texttt{ME} is redefined or removed from the
database, \verb~ME *< VMAPS >~ will be removed as well.

\small
\begin{verbatim}
%)

  eq setUpModExpDependencies(_*<_>(ME, VMAPS), 
       database((< ME ; U ; U' ; M ; M' ; MNS ; VES > IS), MNS', VES', QIL))
    = database(
        (< ME ; U ; U' ; M ; M' ; MNS & _*<_>(ME, VMAPS) ; VES > IS), 
        MNS', VES', QIL) .
  ceq setUpModExpDependencies(_*<_>(ME, VMAPS), DB)
    = warning(DB, 
        ('\n 'ERROR: 'module modNameToQidList(ME) 'not 'in 'database '.))
      if not unitInDatabase(ME, DB) .

***(%
\end{verbatim}
\normalsize

The definition of the \texttt{prepareModName} function on a renaming module
expression must take into account the possibility of having parameterized
sorts or parameterized class names in the maps of a renaming module
expression.  The preparation of a renaming module expression must take into
account this fact and prepare accordingly all parameterized sorts and classes
appearing in it.

\small
\begin{verbatim}
%)

  op prepareMapSet : ViewMapSet QidViewExpPairSet -> ViewMapSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op prepareESortList : ESortList QidViewExpPairSet -> ESortList .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq prepareModName(_*<_>(ME, VMAPS), QIVEPS)
    = _*<_>(prepareModName(ME, QIVEPS), prepareMapSet(VMAPS, QIVEPS)) .

***(%
\end{verbatim}
\normalsize

\noindent For example, for sort maps the equation is as follows.

\small
\begin{verbatim}
%)

  eq prepareMapSet(((sort ES to ES'), VMAPS), QIVEPS)
    = ((sort prepareESort(ES, QIVEPS) to prepareESort(ES', QIVEPS)),
       prepareMapSet(VMAPS, QIVEPS)) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq prepareMapSet(((class ES to ES'), VMAPS), QIVEPS)
    = ((class prepareESort(ES, QIVEPS) to prepareESort(ES', QIVEPS)),
       prepareMapSet(VMAPS, QIVEPS)) .
  eq prepareMapSet(((attr QI . ES to QI'), VMAPS), QIVEPS)
    = ((attr QI . prepareESort(ES, QIVEPS) to QI'),
       prepareMapSet(VMAPS, QIVEPS)) .
  eq prepareMapSet(((op F to F' [AtS]), VMAPS), QIVEPS)
    = ((op F to F' [AtS]),
       prepareMapSet(VMAPS, QIVEPS)) .
  eq prepareMapSet(((op F : ESL -> ES to F' [AtS]), VMAPS), QIVEPS)
    = ((op F : prepareESortList(ESL, QIVEPS) -> prepareESort(ES, QIVEPS) 
          to F' [AtS]),
       prepareMapSet(VMAPS, QIVEPS)) .
  eq prepareMapSet(((label L to L'), VMAPS), QIVEPS)
    = ((label L to L'),
       prepareMapSet(VMAPS, QIVEPS)) .
  eq prepareMapSet(((msg F to F'), VMAPS), QIVEPS)
    = ((msg F to F'),
       prepareMapSet(VMAPS, QIVEPS)) .
  eq prepareMapSet(((msg F : ESL -> ES to F'), VMAPS), QIVEPS)
    = ((msg F : prepareESortList(ESL, QIVEPS) -> prepareESort(ES, QIVEPS) 
          to F'),
       prepareMapSet(VMAPS, QIVEPS)) .
  eq prepareMapSet(none, QIVEPS) = none .

  eq prepareESortList((ES ESL), QIVEPS)
    = (prepareESortList(ES, QIVEPS) prepareESortList(ESL, QIVEPS)) .
  eq prepareESortList(nil, QIVEPS)
    = nil .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\section{The Evaluation of Views}
\label{evaluation-views}

Before being entered into the database, besides containing bubbles, views have
a somewhat different structure from that of the views given in
Section~\ref{viewADT}. We introduce in the following module a sort
\texttt{PreView} with constructor \texttt{view}, which is declared as the
constructor for views of sort \texttt{View}, but with an additional argument,
namely, a set of variable declarations to hold the declarations of variables
in the view. During the processing of views (see
Section~\ref{view-processing}), which takes place once the parsing process has
concluded, these variables are associated with the corresponding maps where
they are used, generating a term of sort \texttt{View}.

\begin{comment}
As for sorts \texttt{MapSet} and \texttt{ViewMapSet}, the function
\texttt{sortMapSet} is defined on the \texttt{PreViewMapSet}. In this case it
returns the set of sort maps in a set of preview maps.
\end{comment}

We start by introducing in the following module \texttt{PRE-VIEW-MAP} the
sorts \texttt{TermPreMap}, \texttt{PreViewMap}, and \texttt{PreViewMapSet}. A
preview map is a view map with bubbles. Note that the bubbles can only appear
in term maps. Elements of sort \texttt{TermPreMap} are built with the
constructor \texttt{preTermMap}, which takes two terms of sort \texttt{Term},
that is, two bubbles. In the processing of views (see
Section~\ref{view-processing}), elements of sort \texttt{PreTermMap} will be
converted into elements of sort \texttt{TermMap} by parsing the bubbles in
them, and by associating to them the variables in them defined in the view in
which the maps appear.

\small
\begin{verbatim}
%)

fmod PRE-VIEW-MAP is
  pr VIEW-MAP .

  sort TermPreMap .
  op preTermMap : Term Term -> TermPreMap .

  sorts PreViewMap PreViewMapSet .
  subsorts Map TermPreMap < PreViewMap .
  subsorts PreViewMap ViewMapSet < PreViewMapSet .
  op _,_ : PreViewMapSet PreViewMapSet -> PreViewMapSet 
        [assoc comm id: none] .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var PVMAP : PreViewMap .
  var PVMAPS : PreViewMapSet .

***(%
\end{verbatim}
\normalsize

\end{comment}

Given a set of maps, the function \texttt{sortMapSet} returns the subset of
sort maps in it.

\small
\begin{verbatim}
%)

  op sortMapSet : PreViewMapSet -> MapSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq sortMapSet((PVMAP, PVMAPS))
    = if PVMAP : SortMap
      then (PVMAP, sortMapSet(PVMAPS))
      else sortMapSet(PVMAPS)
      fi .
  eq sortMapSet(none) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

\small
\begin{verbatim}
%)

fmod PRE-VIEW is
  pr UNIT .
  pr PRE-VIEW-MAP .

  sort PreView .
  op view : ViewExp ParameterList ModExp ModExp EVarDeclSet PreViewMapSet 
          -> PreView .

  op name : PreView -> ViewExp .
  op source : PreView -> ModExp .
  op target : PreView -> ModExp .
  op varDeclSet : PreView -> EVarDeclSet .
  op mapSet : PreView -> PreViewMapSet .

  var QI : Qid .
  vars ME ME' : ModExp .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var VE : ViewExp .
  var PL : ParameterList .
  vars EVDS EVDS' : EVarDeclSet .
  vars PVMAPS PVMAPS' : PreViewMapSet .

  eq name(view(VE, PL, ME, ME', EVDS, PVMAPS)) = VE .
  eq target(view(VE, PL, ME, ME', EVDS, PVMAPS)) = ME' .
  eq source(view(VE, PL, ME, ME', EVDS, PVMAPS)) = ME .
  eq varDeclSet(view(VE, PL, ME, ME', EVDS, PVMAPS)) = EVDS .
  eq mapSet(view(VE, PL, ME, ME', EVDS, PVMAPS)) = PVMAPS .

***(%
\end{verbatim}
\normalsize

\end{comment}

The following functions can be used to add new declarations to the set of
declarations already in a preview.

\small
\begin{verbatim}
%)

  op addMapSet : PreViewMapSet PreView -> PreView .
  op addVarDeclSet : EVarDeclSet PreView -> PreView .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq addMapSet(PVMAPS, view(VE, PL, ME, ME', EVDS, PVMAPS'))
    = view(VE, PL, ME, ME', EVDS, (PVMAPS, PVMAPS')) .
  eq addVarDeclSet(EVDS, view(VE, PL, ME, ME', EVDS', PVMAPS))
    = view(VE, PL, ME, ME', (EVDS EVDS'), PVMAPS) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op emptyPreView : Qid ModExp ModExp -> PreView .
  eq emptyPreView(QI, ME, ME')
    = view(QI, nilParameterList, ME, ME', none, none) .

***(%
\end{verbatim}
\normalsize

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

The function \texttt{solveBubbles} defined in the following
\texttt{VIEW-BUBBLE-PARSING} module parses the bubbles in a set of preview
maps. It takes two modules, the signature of the view's source theory, with
the variables declared in the view, to parse the source term in the term maps,
and the target theory, with the mappings of the variable declarations in the
view, to parse the target terms.

\small
\begin{verbatim}
%)

fmod VIEW-BUBBLE-PARSING is
  pr BUBBLE-PARSING .
  pr PRE-VIEW .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var PVMAPS : PreViewMapSet .
  var VMAP : ViewMap .
  vars T T' : Term .
  var EVDS : EVarDeclSet .
  vars M M' : Module .
  var U : Unit .
  var QIL : QidList .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op solveBubbles : PreViewMapSet EVarDeclSet Unit Unit -> ViewMapSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq solveBubbles(PVMAPS, EVDS, U, unitError(QIL)) = none .
  eq solveBubbles(PVMAPS, EVDS, unitError(QIL), U) = none .
  ceq solveBubbles((VMAP, PVMAPS), EVDS, M, M')
    = (VMAP, solveBubbles(PVMAPS, EVDS, M, M')) 
      if not (VMAP : TermMap) .
  eq solveBubbles((preTermMap(T, T'), PVMAPS), EVDS, M, M')
    = (termMap(
         varDeclSetInTerm(EVDS, solveBubbles(T, M, false, emptyDatabase)),
         solveBubbles(T, M, false, emptyDatabase),
         solveBubbles(T', M', false, emptyDatabase)),
      solveBubbles(PVMAPS, EVDS, M, M')) .
  eq solveBubbles(none, EVDS, M, M') = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\section{Input/Output Processing}
\label{input-output-processing}

In this section we discuss how the preterm resulting from the call to
the function \texttt{meta-parse} with the input and the top-level
signature of Full Maude is transformed into a term of sort \texttt{Unit},
representing a preunit or a term of sort \texttt{PreView}. In the case of
commands, they are evaluated giving the corresponding results in the
appropriate form.

\subsection{Input Parsing}
\label{input-parsing}

Let us recall here the example presented in
Section~\ref{bubbles}. Calling \texttt{meta-parse} with the
module \texttt{NAT3} given there and the signature of Full Maude presented in
Section~\ref{sec:signature}, we obtain the following term.

\small
\begin{verbatim}
   'fmod_is_endfm[
      'token[{''NAT3}'Qid], 
      '__['sort_.['token[{''Nat3}'Qid]], 
          '__['op_:_->_.['token[{''s_}'Qid], 
                         'neTokenList[{''Nat3}'Qid], 
                         'token[{''Nat3}'Qid]], 
              '__['op_:`->_.['token[{''0}'Qid], 
                             'token[{''Nat3}'Qid]], 
                  'eq_=_.['bubble['__[{''s}'Qid, {''s}'Qid,  
                                      {''s}'Qid, {''0}'Qid]], 
                          'bubble[{''0}'Qid]]]]]]
\end{verbatim}
\normalsize

Given each one of the subterms representing declarations in terms
representing modules as the previous one, the function
\texttt{parseDecl} generates the corresponding declaration, with no
bubbles in it, and the corresponding predeclaration, with the bubbles
appearing in the term. For example, for the term

\small
\begin{verbatim}
  'op_:_->_.['token[{''s_}'Qid], 
             'neTokenList[{''Nat3}'Qid], 
             'token[{''Nat3}'Qid]]
\end{verbatim}
\normalsize
the following operator declaration is generated:

\small
\begin{verbatim}
  op 's_ : 'Nat3 -> 'Nat3 [none] .
\end{verbatim}
\normalsize
Note that in this case, since the operator is declared without identity
element (the only place a bubble might appear), the declaration and the
predeclaration generated by \texttt{parseDecl} coincide.

In the following sections we shall see how this approach is followed for
declarations appearing in units and in views.


\subsubsection{Parsing of Unit Declarations}
\label{parsing-unit-declarations}

The \texttt{parseDecl} function takes a term (which corresponds to a
declaration that has to be parsed), a preunit (to which the parsed declaration
with its bubbles in it will be added), and a unit (to which the parsed
declaration without bubbles will be added to build up the signature). For
example, a term corresponding to an unconditional equation, that is, a term of
the form \verb~'eq_=_.[T, T']~ will be added to the set of equations of the
preunit as \verb~eq T = T' .~, but nothing will be added to the unit. Note
that according to the signature used in the call to \texttt{meta-parse} (see
Sections~\ref{sec:signature} and~\ref{main-module}), \texttt{T} and
\texttt{T'} are bubbles. Declarations of sorts, subsort relations, operators,
classes, subclass relations, messages, and variables will be added to both of
them. In the case of operator declarations, identity element attributes, which
in general can be terms, are not included in the added declaration.  As in
Core Maude, declarations in a module can be given in any order, and therefore
we follow a two-step approach consisting in first building the signature to
parse the bubbles, and then generating the unit without bubbles in it. It
could be different for other languages. For example, in some languages we may
be able to assume that each operator and sort has been defined before being
used, allowing then an incremental processing of the input.

\begin{comment}
\footnote{In the case of Maude, since the unit generated containing
the declarations without bubbles in it will be part of the signature in which
the bubbles are parsed, in case of existing operators overloaded with
operators in other modules, messages warning about the existence of operators
with different attributes will be given.}.
\end{comment}

\small
\begin{verbatim}
%)

fmod UNIT-DECL-PARSING is
  pr DATABASE .
  pr MOVE-DOWN .
  pr INST-EXPR .
  pr RENAMING-EXPR .

  vars PU U : Unit .
  vars T T' : Term .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  vars QI QI' L F : Qid .
  var QIL : QidList .
  vars ES ES' : ESort .
  vars ESL ESL' : ESortList .
  var ESLL : ESortListList .
  var AtS : AttrSet .
  vars T'' T''' T'''' : Term .
  var TL : TermList .

***(%
\end{verbatim}
\normalsize

\end{comment}

Before introducing the \texttt{parseDecl} function, we present some auxiliary
functions. For example, the following functions \texttt{parseSort},
\texttt{parseSortSet}, and \texttt{parseSortList} return, respectively, the
sort, set of sorts, and list of sorts represented by the term given as
argument. Note that these functions, as most of the functions in this
module, are partial functions. We assume that the term given as argument is in
fact the representation of, for example, a valid sort, or set of sorts,
etc. In the case of \texttt{parseDecl} we assume that the term is the
representation of a predeclaration.

\small
\begin{verbatim}
%)

  op parseSort : Term -> ESort .
  op parseSortSet : Term -> ESortSet .
  op parseSortList : Term -> ESortList .
  op parseViewExp : Term -> ViewExp .

  eq parseSort('sortToken[T]) = downQid(T) .
  eq parseSort('_`[_`][T, T'])
    = eSort(parseSort(T), parseViewExp(T')) .

  eq parseSortSet('__[T, T'])
    = (parseSortSet(T) ; parseSortSet(T')) .
  eq parseSortSet('sortToken[T]) = parseSort('sortToken[T]) .
  eq parseSortSet('_`[_`][T, T']) = parseSort('_`[_`][T, T']) .

  eq parseSortList('__[T, T'])
    = (parseSortList(T) parseSortList(T')) .
  eq parseSortList('sortToken[T]) = parseSort('sortToken[T]) .
  eq parseSortList('_`[_`][T, T']) = parseSort('_`[_`][T, T']) .

  eq parseViewExp('viewToken[T]) = downQid(T) .
  eq parseViewExp('_`,_[T, T'])
    = _|_(parseViewExp(T), parseViewExp(T')) .

***(%
\end{verbatim}
\normalsize

The function \texttt{parseModExp} takes a term representing a module
expression and returns the corresponding term in sort \texttt{ModExp}. In case
of adding new constructors for module expressions, as it will be done in
Section~\ref{extension}, new equations defining the semantics of the function
on them will have to be given.

\small
\begin{verbatim}
%)

  op parseModExp : Term -> ModExp .
  op parseMapSet : Term -> MapSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op parseAttrSet : Term -> AttrSet .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq parseModExp('token[T]) = downQid(T) .
  eq parseModExp('`(_`)[T]) = parseModExp(T) .
  eq parseModExp('_`[_`][T, T'])
    = _<_>(parseModExp(T), parseViewExp(T')) .
  eq parseModExp('_*`(_`)[T, T'])
    = _*<_>(parseModExp(T), parseMapSet(T')) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq parseMapSet('_`,_[T, T'])
    = (parseMapSet(T), parseMapSet(T')) .

  eq parseMapSet('sort_to_[T, T'])
    = (sort parseSort(T) to parseSort(T')) .
  eq parseMapSet('label_to_['token[T], 'token[T']])
    = (label downQid(T) to downQid(T')) .
  eq parseMapSet('class_to_[T, T'])
    = (class parseSort(T) to parseSort(T')) .
  eq parseMapSet('attr_._to_['token[T], T', 'token[T'']])
    = (attr downQid(T) . parseSort(T') to downQid(T'')) .
  eq parseMapSet('msg_to_['token[T], 'token[T']])
    = (msg downQid(T) to downQid(T')) .
  eq parseMapSet('msg_:_->_to_['token[T], T', T'', 'token[T''']])
    = (msg downQid(T) : parseSortList(T') -> parseSort(T'') 
                    to downQid(T''')) .
  eq parseMapSet('msg_:`->_to_['token[T], T', 'token[T'']])
    = (msg downQid(T) : nil -> parseSort(T') to downQid(T'')) .
  eq parseMapSet('op_to_`[_`]['token[T], 'token[T'], T''])
    = (op downQid(T) to downQid(T') [parseAttrSet(T'')]) .
  eq parseMapSet('op_:_->_to_`[_`]['token[T], T', T'', 'token[T'''], T''''])
    = (op downQid(T) : parseSortList(T') -> parseSort(T'') to downQid(T''') 
           [parseAttrSet(T'''')]) .
  eq parseMapSet('op_:`->_to_`[_`]['token[T], T', 'token[T''], T'''])
    = (op downQid(T) : nil -> parseSort(T') to downQid(T'') 
           [parseAttrSet(T''')]) .
  eq parseMapSet('op_to_['token[T], 'token[T']])
    = (op downQid(T) to downQid(T') [none]) .
  eq parseMapSet('op_:_->_to_['token[T], T', T'', 'token[T''']])
    = (op downQid(T) : parseSortList(T') -> parseSort(T'') to downQid(T''') 
          [none]) .
  eq parseMapSet('op_:`->_to_['token[T], T', 'token[T'']])
    = (op downQid(T) : nil -> parseSort(T') to downQid(T'') [none]) .

  eq parseAttrSet('__[T, T']) = (parseAttrSet(T) parseAttrSet(T')) .
  eq parseAttrSet({'assoc}'Attr) = assoc .
  eq parseAttrSet({'associative}'Attr) = assoc .
  eq parseAttrSet({'comm}'Attr) = comm .
  eq parseAttrSet({'commutative}'Attr) = comm .
  eq parseAttrSet({'idem}'Attr) = idem .
  eq parseAttrSet({'idempotent}'Attr) = idem .
  eq parseAttrSet('id:_[T]) = none .
  eq parseAttrSet('identity:_[T]) = none .
  eq parseAttrSet('left`id:_[T]) = none .
  eq parseAttrSet('left`identity:_[T]) = none .
  eq parseAttrSet('right`id:_[T]) = none .
  eq parseAttrSet('right`identity:_[T]) = none .
  eq parseAttrSet({'memo}'Attr) = memo .
  eq parseAttrSet({'memoization}'Attr) = memo .
  eq parseAttrSet({'ctor}'Attr) = ctor .
  eq parseAttrSet({'constructor}'Attr) = ctor .
  eq parseAttrSet('strat`(_`)[T]) = strat(parseMachineInt(T)) .
  eq parseAttrSet('strategy`(_`)[T]) = strat(parseMachineInt(T)) .
  eq parseAttrSet('prec_['token[T]]) = prec(parseMachineInt(T)) .
  eq parseAttrSet('precedence_['token[T]]) = prec(parseMachineInt(T)) .
  eq parseAttrSet('gather`(_`)['neTokenList[T]]) = gather(downQidList(T)) .
  eq parseAttrSet('gathering`(_`)['neTokenList[T]]) = gather(downQidList(T)) .
  eq parseAttrSet('special`(_`)[T]) = none .

***(%
\end{verbatim}
\normalsize

Similarly, auxiliary functions parsing other elements in units are defined.

\small
\begin{verbatim}
%)

  sort ESortListList .
  subsort ESortList < ESortListList .
  op nilQidListList : -> ESortListList .
  op qidListList : ESortListList ESortListList -> ESortListList
        [assoc id: nilQidListList] .

  op parsePreAttrSet : Term -> AttrSet .
  op parseHookList : Term -> HookList .
  op parseVarDeclSet : QidList ESort -> EVarDeclSet .
  op parseSubsortRel : Term -> ESortListList .

***(%
\end{verbatim}
\normalsize

\end{comment}

Given a term representing a machine integer, the function
\texttt{parseMachineInt} returns the corresponding integer.

\small
\begin{verbatim}
%)

  op parseMachineInt : Term -> MachineInt .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op parseMachineInt : TermList -> MachineIntList .

  op parseAttrDeclList : Term -> AttrDeclSet .
  op unfoldMultipleOpDecl : QidList ESortList ESort AttrSet -> EOpDeclSet .
  op unfoldMultipleMsgDecl : QidList ESortList ESort -> MsgDeclSet .
  op unfoldSubsortRel : ESortListList -> ESubsortDeclSet .
  op unfoldSubclassRel : ESortListList -> SubclassDeclSet .

  eq parseSubsortRel('_<_[T, T'])
    = qidListList(parseSortList(T), parseSubsortRel(T')) .
  eq parseSubsortRel('__[T, T'])
    = parseSortList('__[T, T']) .
  eq parseSubsortRel('sortToken[T]) = downQid(T) .
  eq parseSubsortRel('_`[_`]['sortToken[T], T'])
    = eSort(downQid(T), parseViewExp(T')) .
  eq parseSubsortRel('_`[_`]['_`[_`][T, T'], T''])
    = eSort(parseSubsortRel('_`[_`][T, T']), parseViewExp(T'')) .

  eq unfoldMultipleOpDecl((QI QIL), ESL, ES, AtS)
    = ((op QI : ESL -> ES [AtS] .) unfoldMultipleOpDecl(QIL, ESL, ES, AtS)) .
  eq unfoldMultipleOpDecl(nil, ESL, ES, AtS) = none .

  eq unfoldMultipleMsgDecl((QI QIL), ESL, ES)
    = ((msg QI : ESL -> ES .) unfoldMultipleMsgDecl(QIL, ESL, ES)) .
  eq unfoldMultipleMsgDecl(nil, ESL, ES) = none .

  eq unfoldSubsortRel(qidListList((ES ESL), (ES' ESL'), ESLL))
    = ((subsort ES < ES' .)
       unfoldSubsortRel(qidListList(ES, ESL'))
       unfoldSubsortRel(qidListList(ESL, (ES' ESL')))
       unfoldSubsortRel(qidListList((ES' ESL'), ESLL))) .
  eq unfoldSubsortRel(qidListList(ESL, nil)) = none .
  eq unfoldSubsortRel(qidListList(nil, ESL)) = none .
  eq unfoldSubsortRel(ESL) = none .

  eq unfoldSubclassRel(qidListList((ES ESL), (ES' ESL'), ESLL))
    = ((subclass ES < ES' .)
       unfoldSubclassRel(qidListList(ES, ESL'))
       unfoldSubclassRel(qidListList(ESL, (ES' ESL')))
       unfoldSubclassRel(qidListList((ES' ESL'), ESLL))) .
  eq unfoldSubclassRel(qidListList(ESL, nil)) = none .
  eq unfoldSubclassRel(qidListList(nil, ESL)) = none .
  eq unfoldSubclassRel(ESL) = none .

  eq parseVarDeclSet((QI QIL), ES)
    = ((var QI : ES .) parseVarDeclSet(QIL, ES)) .
  eq parseVarDeclSet(nil, ES) = none .

  eq parsePreAttrSet('__[T, T']) = (parsePreAttrSet(T) parsePreAttrSet(T')) .
  eq parsePreAttrSet({'assoc}'Attr) = assoc .
  eq parsePreAttrSet({'associative}'Attr) = assoc .
  eq parsePreAttrSet({'comm}'Attr) = comm .
  eq parsePreAttrSet({'commutative}'Attr) = comm .
  eq parsePreAttrSet({'idem}'Attr) = idem .
  eq parsePreAttrSet({'idempotent}'Attr) = idem .
  eq parsePreAttrSet('id:_[T]) = id(T) .
  eq parsePreAttrSet('identity:_[T]) = id(T) .
  eq parsePreAttrSet('left`id:_[T]) = left-id(T) .
  eq parsePreAttrSet('left`identity:_[T]) = left-id(T) .
  eq parsePreAttrSet('right`id:_[T]) = right-id(T) .
  eq parsePreAttrSet('right`identity:_[T]) = right-id(T) .
  eq parsePreAttrSet('strat`(_`)[T]) = strat(parseMachineInt(T)) .
  eq parsePreAttrSet('strategy`(_`)[T]) = strat(parseMachineInt(T)) .
  eq parsePreAttrSet({'memo}'Attr) = memo .
  eq parsePreAttrSet({'memoization}'Attr) = memo .
  eq parsePreAttrSet({'ctor}'Attr) = ctor .
  eq parsePreAttrSet({'constructor}'Attr) = ctor .
  eq parsePreAttrSet('prec_['token[T]]) = prec(parseMachineInt(T)) .
  eq parsePreAttrSet('gather`(_`)['neTokenList[T]]) = gather(downQidList(T)) .
  eq parsePreAttrSet('special`(_`)[T]) = special(parseHookList(T)) .

  eq parseHookList('__[T, TL])
    = parseHookList(T) parseHookList(TL) .
  eq parseHookList('id-hook_['token[T]])
    = id-hook(downQid(T), nil) .
  eq parseHookList('id-hook_`(_`)['token[T], 'neTokenList[T']])
    = id-hook(downQid(T), downQidList(T')) .
  eq parseHookList(
       'op-hook_`(_:_->_`)[
         'token[T], 'token[T'], 'neTokenList[T''], 'token[T''']])
    = op-hook(downQid(T), downQid(T'), downQidList(T''), downQid(T''')) .
  eq parseHookList('op-hook_`(_:`->_`)['token[T], 'token[T'], 'token[T'']])
    = op-hook(downQid(T), downQid(T'), nil, downQid(T'')) .
  eq parseHookList('term-hook_`(_`)['token[T], T'])
    = term-hook(downQid(T), T') .

  eq parseMachineInt('neTokenList['__[TL]])
    = parseMachineInt(TL) .
  eq parseMachineInt('neTokenList[{QI}QI'])
    = parseMachineInt({QI}QI') .
  eq parseMachineInt((T, TL))
    = (parseMachineInt(T) parseMachineInt(TL)) .

  eq parseMachineInt({QI}'Qid)
    = downMachineInt({strip(QI)}'MachineInt ) .

  eq parseAttrDeclList('_`,_[T, T'])
    = (parseAttrDeclList(T), parseAttrDeclList(T')) .
  eq parseAttrDeclList('_:_['token[T], T'])
    = (attr downQid(T) : parseSort(T')) .

***(%
\end{verbatim}
\normalsize

\end{comment}

Given a term representing a declaration or a predeclaration, the function
\texttt{parseDecl} must generate and update both the unit and the preunit that
it takes as arguments. Note that in the case of rules, for example, only a
prerule is generated.

Since the preunit and the unit may be modified, they have to be returned as a
pair, which will be used to extract the corresponding arguments for the
following calls. Note that the \texttt{parseDecl} functions are in fact
partial functions. Each parsing function assumes that it is possible to
parse the given term.

We include here only some of the equations needed.

\small
\begin{verbatim}
%)

  sort parseDeclResult .
  op <_;_> : Unit Unit -> parseDeclResult .
  op preUnit : parseDeclResult -> Unit .
  op unit : parseDeclResult -> Unit .

  eq preUnit(< PU ; U >) = PU .
  eq unit(< PU ; U >) = U .

  op parseDecl : Term Unit Unit -> parseDeclResult .

***(%
\end{verbatim}
\normalsize

In the case of importation declarations, since internally only the
\texttt{including} mode is handled, all importations are generated in this
mode, independently of the keyword used in the input.

\small
\begin{verbatim}
%)

  eq parseDecl('including_.[T], PU, U)
    = < addImportList((including parseModExp(T) .), PU) ; U > .
  eq parseDecl('protecting_.[T], PU, U)
    = < addImportList((including parseModExp(T) .), PU) ; U > .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq parseDecl('inc_.[T], PU, U)
    = < addImportList((including parseModExp(T) .), PU) ; U > .
  eq parseDecl('pr_.[T], PU, U)
    = < addImportList((including parseModExp(T) .), PU) ; U > .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq parseDecl('sorts_.[T], PU, U)
    = < addSortSet(parseSortSet(T), PU) ;
        addSortSet(parseSortSet(T), U) > .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq parseDecl('sort_.[T], PU, U)
    = < addSortSet(parseSortSet(T), PU) ;
        addSortSet(parseSortSet(T), U) > .

  eq parseDecl('subsort_.[T], PU, U)
    = < addSubsortDeclSet(unfoldSubsortRel(parseSubsortRel(T)), PU) ;
        addSubsortDeclSet(unfoldSubsortRel(parseSubsortRel(T)), U) > .
  eq parseDecl('subsorts_.[T], PU, U)
    = < addSubsortDeclSet(unfoldSubsortRel(parseSubsortRel(T)), PU) ;
        addSubsortDeclSet(unfoldSubsortRel(parseSubsortRel(T)), U) > .

***(%
\end{verbatim}
\normalsize

As pointed out in Section~\ref{SyntacticalRequirementsAndCaveats}, the name of
operators in operator declaration has to be given as a single token identifier
(see Section~\ref{order-sorted}). We assume that when declaring a multitoken
operator, its name is given as a single quoted identifier in which each token
is preceded by a backquote. Thus, the name of an operator \verb~_(_)~, for
example, is given as \verb~_`(_`)~.

\small
\begin{verbatim}
%)

  eq parseDecl('op_:`->_.['token[T], T'], PU, U)
    = < addOpDeclSet((op downQid(T) : nil -> parseSort(T') [none] .), PU) ;
        addOpDeclSet((op downQid(T) : nil -> parseSort(T') [none] .), U) > .
  eq parseDecl('op_:`->_`[_`].['token[T], T', T''], PU, U)
   = < addOpDeclSet(
         (op downQid(T) : nil -> parseSort(T') [parsePreAttrSet(T'')] .), PU) ;
       addOpDeclSet(
         (op downQid(T) : nil -> parseSort(T') [parseAttrSet(T'')] .), U) > .
  eq parseDecl('op_:_->_.['token[T], T', T''], PU, U)
    = < addOpDeclSet(
          (op downQid(T) : parseSortList(T') -> parseSort(T'') 
              [none] .), PU) ;
        addOpDeclSet(
          (op downQid(T) : parseSortList(T') -> parseSort(T'') 
              [none] .), U) > .
  eq parseDecl('op_:_->_`[_`].['token[T], T', T'', T'''], PU, U)
    = < addOpDeclSet(
          (op downQid(T) : parseSortList(T') -> parseSort(T'') 
              [parsePreAttrSet(T''')] .), PU) ;
        addOpDeclSet(
          (op downQid(T) : parseSortList(T') -> parseSort(T'')
              [parseAttrSet(T''')] .), U) > .

  eq parseDecl('ops_:`->_.['neTokenList[T], T'], PU, U)
    = < addOpDeclSet(
          unfoldMultipleOpDecl(downQidList(T), nil, parseSort(T'), none), PU) ;
        addOpDeclSet(
          unfoldMultipleOpDecl(
            downQidList(T), nil, parseSort(T'), none), U) > .
  eq parseDecl('ops_:`->_`[_`].['neTokenList[T], T', T''], PU, U)
    = < addOpDeclSet(
          unfoldMultipleOpDecl(
            downQidList(T), nil, parseSort(T'), parsePreAttrSet(T'')), PU) ;
        addOpDeclSet(
          unfoldMultipleOpDecl(
            downQidList(T), nil, parseSort(T'), parseAttrSet(T'')), U) > .
  eq parseDecl('ops_:_->_.['neTokenList[T], T', T''], PU, U)
    = < addOpDeclSet(
          unfoldMultipleOpDecl(
            downQidList(T), parseSortList(T'), parseSort(T''), none), PU) ;
        addOpDeclSet(
          unfoldMultipleOpDecl(
            downQidList(T), parseSortList(T'), parseSort(T''), none), U) > .
  eq parseDecl('ops_:_->_`[_`].['neTokenList[T], T', T'', T'''], PU, U)
    = < addOpDeclSet(
          unfoldMultipleOpDecl(downQidList(T), 
            parseSortList(T'), parseSort(T''), parsePreAttrSet(T''')), PU) ;
        addOpDeclSet(
          unfoldMultipleOpDecl(downQidList(T), 
            parseSortList(T'), parseSort(T''), parseAttrSet(T''')), U) > .

  eq parseDecl('vars_:_.['neTokenList[T], T'], PU, U)
    = < addVarDeclSet(parseVarDeclSet(downQidList(T), parseSort(T')), PU) ;
        addVarDeclSet(parseVarDeclSet(downQidList(T), parseSort(T')), U) > .
  eq parseDecl('var_:_.['neTokenList[T], T'], PU, U)
    = < addVarDeclSet(parseVarDeclSet(downQidList(T), parseSort(T')), PU) ;
        addVarDeclSet(parseVarDeclSet(downQidList(T), parseSort(T')), U) > .

  eq parseDecl('mb_:_.[T, T'], PU, U)
    = < addMembAxSet((mb T : parseSort(T') .), PU) ; U > .
  eq parseDecl('cmb_:_if_.[T, T', T''], PU, U)
    = < addMembAxSet((cmb T : parseSort(T') if T'' = {'true}'Bool .), PU) ; 
        U > .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq parseDecl('eq_=_.[T, T'], PU, U)
    = < addEquationSet((eq T = T' .), PU) ; U > .
  eq parseDecl('ceq_=_if_.[T, T', T''], PU, U)
    = < addEquationSet((ceq T = T' if T'' = {'true}'Bool .), PU) ; U > .
  eq parseDecl('cq_=_if_.[T, T', T''], PU, U)
    = < addEquationSet((ceq T = T' if T'' = {'true}'Bool .), PU) ; U > .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq parseDecl('rl`[_`]:_=>_.['token[T], T', T''], PU, U)
    = < addRuleSet((rl [downQid(T)] : T' => T'' .), PU) ; U > .
  eq parseDecl('crl`[_`]:_=>_if_.['token[T], T', T'', T'''], PU, U)
    = < addRuleSet(
          (crl [downQid(T)] : T' => T'' if T''' = {'true}'Bool .), PU) ; U > .

  eq parseDecl('class_.[T], PU, U)
    = < addClassDeclSet((class parseSort(T) | none .), PU) ; 
        addClassDeclSet((class parseSort(T) | none .), U) > .
  eq parseDecl('class_|_.[T, T'], PU, U)
    = < addClassDeclSet((class parseSort(T) | parseAttrDeclList(T') .), PU) ; 
        addClassDeclSet((class parseSort(T) | parseAttrDeclList(T') .), U) > .

  eq parseDecl('subclass_.[T], PU, U)
    = < addSubclassDeclSet(unfoldSubclassRel(parseSubsortRel(T)), PU) ;
        addSubclassDeclSet(unfoldSubclassRel(parseSubsortRel(T)), U) > .
  eq parseDecl('subclasses_.[T], PU, U)
    = < addSubclassDeclSet(unfoldSubclassRel(parseSubsortRel(T)), PU) ;
        addSubclassDeclSet(unfoldSubclassRel(parseSubsortRel(T)), U) > .

  eq parseDecl('msg_:_->_.['token[T], T', T''], PU, U)
    = < addMsgDeclSet(
          (msg downQid(T) : parseSortList(T') -> parseSort(T'') .), PU) ;
        addMsgDeclSet(
          (msg downQid(T) : parseSortList(T') -> parseSort(T'') .), U) > .
  eq parseDecl('msg_:`->_.['token[T], T'], PU, U)
    = < addMsgDeclSet((msg downQid(T) : nil -> parseSort(T') .), PU) ;
        addMsgDeclSet((msg downQid(T) : nil -> parseSort(T') .), U) > .
  eq parseDecl('msgs_:_->_.['neTokenList[T], T', T''], PU, U)
    = < addMsgDeclSet(
          unfoldMultipleMsgDecl(
            downQidList(T), parseSortList(T'), parseSort(T'')), PU) ;
        addMsgDeclSet(
          unfoldMultipleMsgDecl(
            downQidList(T), parseSortList(T'), parseSort(T'')), U) > .
  eq parseDecl('msgs_:`->_.['neTokenList[T], T'], PU, U)
    = < addMsgDeclSet(
          unfoldMultipleMsgDecl(
            downQidList(T), nil, parseSort(T')), PU) ;
        addMsgDeclSet(
          unfoldMultipleMsgDecl(
            downQidList(T), nil, parseSort(T')), U) > .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsubsection{Parsing of View Declarations}
\label{view-decl-parsing}

A similar approach is followed for the parsing of declarations in views. 

\small
\begin{verbatim}
%)

fmod VIEW-DECL-PARSING is
  pr PRE-VIEW .
  pr VIEW .
  pr UNIT .
  pr UNIT-DECL-PARSING .

  vars T T' : Term .
  var EODS : EOpDeclSet .
  var MDS : MsgDeclSet .
  var M : Module .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  vars F F' : Qid .
  vars ES ES' : ESort .
  vars ESL ESL' : ESortList .
  vars T'' T''' : Term .
  var PV : PreView .
  var EOD : EOpDecl .
  var EODS' : EOpDeclSet .
  var AtS : AttrSet .
  var MD : MsgDecl .
  var MDS' : MsgDeclSet .

***(%
\end{verbatim}
\normalsize

\end{comment}

Operator and message name maps of the form \verb~F to F'~ are substituted by
an equivalent set of maps of the form \verb~F : ESL -> ES to F'~. One of these
maps is added for each family of subsort-overloaded operators in the source
theory of the view.

The following functions \texttt{generateOpMapSet} and
\texttt{generateMsgMapSet} take, respectively, an operator and a message map
of the form \verb~F to F'~, a set of operator or message declarations, and a
term of sort \texttt{Module}, and return, respectively, a set of operator maps
and a set of message maps, with each of the members of those sets having the
general form \verb~F : ESL -> ES to F'~. One of these maps is generated for
each family of subsort-overloaded operators or messages with name \texttt{F}
in the module given as argument.

\small
\begin{verbatim}
%)

  op generateOpMapSet : Map EOpDeclSet Module -> MapSet .
  op generateMsgMapSet : Map MsgDeclSet Module -> MapSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op generateOpMapSetAux : EOpDeclSet Qid -> MapSet .
  op generateMsgMapSetAux : MsgDeclSet Qid -> MapSet .

  op getOpDeclSet : Qid Unit -> EOpDeclSet .
  op getOpDeclSetAux : Qid EOpDeclSet -> EOpDeclSet .
  *** getOpDeclSet(F, U) returns the set of declarations of 
  *** operators with name F in the unit U
  op getMsgDeclSet : Qid Unit -> MsgDeclSet .
  op getMsgDeclSetAux : Qid MsgDeclSet -> MsgDeclSet .
  *** getMsgDeclSet(F, U) returns the set of declarations of 
  *** messages with name F in the unit U
  op getSubsortOverloadedFamilies : 
        EOpDeclSet EOpDeclSet Module -> EOpDeclSet .
  op getSubsortOverloadedFamilies : 
        MsgDeclSet MsgDeclSet Module -> MsgDeclSet .
  *** getSubsortOverloadedFamilies returns a declaration of 
  *** operator or message for each family of subsort-overloaded 
  *** operators or messages. 
  op selectOpDeclSet : Qid EOpDeclSet -> EOpDeclSet .
  op selectMsgDeclSet : Qid MsgDeclSet -> MsgDeclSet .
  *** selectOpDeclSet and selectMsgDeclSet returns, respectively,
  *** the subset of those declarations of ops and msgs which name 
  *** coincides with the qid given ar argument.
  op operatorFamilyIn : EOpDecl EOpDeclSet Module -> Bool .
  op messageFamilyIn : MsgDecl MsgDeclSet Module -> Bool .
  *** Check whether the family of the subsort-overloaded operator 
  *** given as argument has already a representative in the set of 
  *** declarations given.

  eq generateOpMapSet((op F to F' [none]), EODS, M)
    = generateOpMapSetAux(
        getSubsortOverloadedFamilies(selectOpDeclSet(F, EODS), none, M), F') .

  eq generateMsgMapSet((msg F to F'), MDS, M)
    = generateMsgMapSetAux(
         getSubsortOverloadedFamilies(selectMsgDeclSet(F, MDS), none, M), F') .

  eq selectOpDeclSet(F, ((op F' : ESL -> ES [AtS] .) EODS))
    = ((if F == F' 
        then (op F' : ESL -> ES [AtS] .)
        else none 
        fi)
       selectOpDeclSet(F, EODS)) .
  eq selectOpDeclSet(F, none) = none .

  eq selectMsgDeclSet(F, ((msg F' : ESL -> ES .) MDS))
    = ((if F == F' 
        then (msg F' : ESL -> ES .)
        else none 
        fi)
       selectMsgDeclSet(F, MDS)) .
  eq selectMsgDeclSet(F, none) = none .

  eq generateOpMapSetAux(((op F : ESL -> ES [AtS] .) EODS), F')
    = ((op F : ESL -> ES to F' [none]), generateOpMapSetAux(EODS, F')) .
  eq generateOpMapSetAux(none, F') = none .

  eq generateMsgMapSetAux(((msg F : ESL -> ES .) MDS), F')
    = ((msg F : ESL -> ES to F'), generateMsgMapSetAux(MDS, F')) .
  eq generateMsgMapSetAux(none, F') = none .

  eq getSubsortOverloadedFamilies((EOD EODS), EODS', M)
    = if operatorFamilyIn(EOD, EODS', M)
      then getSubsortOverloadedFamilies(EODS, EODS', M)
      else getSubsortOverloadedFamilies(EODS, (EOD EODS'), M)
      fi .
  eq getSubsortOverloadedFamilies(none, EODS, M) = EODS .

  eq getSubsortOverloadedFamilies((MD MDS), MDS', M)
    = if messageFamilyIn(MD, MDS', M)
      then getSubsortOverloadedFamilies(MDS, MDS', M)
      else getSubsortOverloadedFamilies(MDS, (MD MDS'), M)
      fi .
  eq getSubsortOverloadedFamilies(none, MDS, M) = MDS .

  eq operatorFamilyIn((op F : ESL -> ES [AtS] .), 
       ((op F' : ESL' -> ES' [AtS] .) EODS), M)
    = ((F == F') and-then eSameComponent(M, ESL, ESL')) or-else
      operatorFamilyIn((op F : ESL -> ES [AtS] .), EODS, M) .
  eq operatorFamilyIn((op F : ESL -> ES [AtS] .), none, M) = false .

  eq messageFamilyIn((msg F : ESL -> ES .), ((msg F' : ESL' -> ES' .) MDS), M)
    = ((F == F') and-then eSameComponent(M, ESL, ESL')) or-else
      messageFamilyIn((msg F : ESL -> ES .), MDS, M) .
  eq messageFamilyIn((msg F : ESL -> ES .), none, M) = false .

***(%
\end{verbatim}
\normalsize

\end{comment}

In the case of views, the \texttt{parseDecl} function takes the term
representing the corresponding declaration and a preview in which the
declarations are introduced. Note that in the case of views, the approach
followed in the evaluation is somewhat different. The only predeclarations in
a preview correspond to the term premaps of sort \texttt{PreTermMap}, for
which, in addition to solving the bubbles in them, we have to convert them
into term maps of sort \texttt{TermMap} associating to them the set of
declarations of variables in the view which are used in them (see
Section~\ref{view-processing}).

The function \texttt{parseDecl} for declarations in views takes then the term
representing such declaration and a preview in which the result of adding the
declaration will be returned. To be able to generate the sets of equivalent
operator and message maps as indicated above, the function takes also as
parameters the sets of declarations of operators and messages in the theory
part of the source theory of the view in question, and the signature of such
theory to make the necessary sort comparisons.

\small
\begin{verbatim}
%)

  op parseDecl : Term PreView EOpDeclSet MsgDeclSet Module -> PreView .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq parseDecl('vars_:_.['neTokenList[T], T'], PV, EODS, MDS, M)
    = addVarDeclSet(parseVarDeclSet(downQidList(T), parseSort(T')), PV) .
  eq parseDecl('var_:_.['neTokenList[T], T'], PV, EODS, MDS, M)
    = addVarDeclSet(parseVarDeclSet(downQidList(T), parseSort(T')), PV) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq parseDecl('op_to`term_.[T, T'], PV, EODS, MDS, M)
    = addMapSet(preTermMap(T, T'), PV) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq parseDecl('op_to_.['token[T], 'token[T']], PV, EODS, MDS, M)
    = addMapSet(
        generateOpMapSet((op downQid(T) to downQid(T') [none]), EODS, M),
        PV) .
  eq parseDecl('op_:_->_to_.['token[T], T', T'', 'token[T''']], 
       PV, EODS, MDS, M)
    = addMapSet((op downQid(T) : parseSortList(T') -> parseSort(T'') 
                   to downQid(T''') [none]), PV) .
  eq parseDecl('op_:`->_to_.['token[T], T', 'token[T'']], PV, EODS, MDS, M)
    = addMapSet((op downQid(T) : nil -> parseSort(T') to downQid(T'') [none]), 
        PV) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq parseDecl('sort_to_.[T, T'], PV, EODS, MDS, M)
    = addMapSet((sort parseSort(T) to parseSort(T')), PV) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq parseDecl('label_to_.['token[T], 'token[T']], PV, EODS, MDS, M)
    = addMapSet((label downQid(T) to downQid(T')), PV) .
  eq parseDecl('class_to_.[T, T'], PV, EODS, MDS, M)
    = addMapSet((class parseSort(T) to parseSort(T')), PV) .
  eq parseDecl('attr_._to_.['token[T], T', 'token[T'']], PV, EODS, MDS, M)
    = addMapSet((attr downQid(T) . parseSort(T') to downQid(T'')), PV) .
  eq parseDecl('msg_to_.['token[T], 'token[T']], PV, EODS, MDS, M)
    = addMapSet(
        generateMsgMapSet((msg downQid(T) to downQid(T')), MDS, M), PV) .
  eq parseDecl('msg_:_->_to_.['token[T], T', T'', 'token[T''']], 
       PV, EODS, MDS, M)
    = addMapSet(
        (msg downQid(T) : parseSortList(T') -> parseSort(T'') 
           to downQid(T''')),
        PV) .
  eq parseDecl('msg_:`->_to_.['token[T], T', 'token[T'']], PV, EODS, MDS, M)
    = addMapSet((msg downQid(T) : nil -> parseSort(T') to downQid(T'')), PV) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Meta Pretty Printing}
\label{meta-pretty-print}

To be able to show to the user the modules, theories, views, and terms
resulting from the different commands, the built-in function
\texttt{meta-pretty-print} is extended in the modules in this section to deal
with units and views.

\subsubsection{Meta Pretty Printing of Declarations}

The predefined function \texttt{meta-pretty-print} is extended in the
following module \texttt{DECL-META-PRETTY-PRINT} to handle any declaration
that can appear in a unit. Note that the following
\texttt{meta-pretty-print} functions, as the built-in one, 
return a list of quoted identifiers, although only for the declarations
containing terms---such as equations, rules, operator declarations with an
identity attribute, etc.---they have been defined with a term of sort
\texttt{Module} as argument. In the other cases the module is not necessary.

\small
\begin{verbatim}
%)

fmod DECL-META-PRETTY-PRINT is
  pr EXT-DECL .
  pr O-O-DECL .
  pr EXT-SORT-TO-QID .
  pr UNIT .

  op my-meta-pretty-print : ESort -> QidList .
  op my-meta-pretty-print : ESortSet -> QidList .
  op my-meta-pretty-print : ESortList -> QidList .
  op my-meta-pretty-print : ESubsortDeclSet -> QidList .
  op my-meta-pretty-print : ClassDeclSet -> QidList .
  op my-meta-pretty-print : SubclassDeclSet -> QidList .
  op my-meta-pretty-print : Module EOpDeclSet -> QidList .
  op my-meta-pretty-print : MsgDeclSet -> QidList .
  op my-meta-pretty-print : EVarDeclSet -> QidList .
  op my-meta-pretty-print : Module EMembAxSet -> QidList .
  op my-meta-pretty-print : Module EquationSet -> QidList .
  op my-meta-pretty-print : Module RuleSet -> QidList .
  op my-meta-pretty-print : Unit Term -> QidList .

  eq my-meta-pretty-print(U, T) 
    = if (U : Module) and (U =/= noModule) and (T =/= error*)
      then meta-pretty-print(U, T)
      else 'error* 
      fi .
 
***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op my-meta-pretty-print : Module AttrSet -> QidList .
  op my-meta-pretty-print : MachineIntList -> QidList .
  op my-meta-pretty-print : ViewExp -> QidList .
  op my-meta-pretty-print : AttrDeclSet -> QidList .
  op my-meta-pretty-print : Module HookList -> QidList .

  vars QI QI' QI'' F V L : Qid .
  var QIL : QidList .
  var M : Module .
  var U : Unit .
  vars VE VE' : ViewExp .
  vars SS : QidSet .
  vars ES ES' : ESort .
  var ESS : ESortSet .
  var ESL : ESortList .
  var ESSDS : ESubsortDeclSet .
  var EODS : EOpDeclSet .
  var AtS : AttrSet .
  var EVDS : EVarDeclSet .
  var EMAS : EMembAxSet .
  var EqS : EquationSet .
  var RlS : RuleSet .
  var H : Hook .
  var HL : HookList .
  var I : MachineInt .
  var MIL : MachineIntList .
  vars T T' T'' T''' : Term .
  var CDS : ClassDeclSet .
  var SCDS : SubclassDeclSet .
  var MDS : MsgDeclSet .
  var ADS : AttrDeclSet .

  eq my-meta-pretty-print(VE) = viewExpToQidList(VE) .

  eq my-meta-pretty-print(ES) = eSortToQidList(ES) .

  eq my-meta-pretty-print((ES ; ESS)) 
    = (my-meta-pretty-print(ES) my-meta-pretty-print(ESS)) .
  eq my-meta-pretty-print((none).QidSet) = nil .

  eq my-meta-pretty-print(ESL) = eSortToQidList(ESL) .

  eq my-meta-pretty-print(((subsort ES < ES' .) ESSDS))
    = ('\n '\t 'subsort my-meta-pretty-print(ES) '< my-meta-pretty-print(ES') '. 
       my-meta-pretty-print(ESSDS)) .
  eq my-meta-pretty-print((none).ESubsortDeclSet) = nil .

  ceq my-meta-pretty-print(M, ((op F : ESL -> ES [AtS] .) EODS))
    = ('\n '\t 
       'op F ': my-meta-pretty-print(ESL) '-> my-meta-pretty-print(ES) 
           '`[ my-meta-pretty-print(M, AtS) '`] '. my-meta-pretty-print(M, EODS))
      if AtS =/= none .
  eq my-meta-pretty-print(M, ((op F : ESL -> ES [none] .) EODS))
    = ('\n '\t 'op F ': my-meta-pretty-print(ESL) '-> my-meta-pretty-print(ES) '. 
       my-meta-pretty-print(M, EODS)) .
  eq my-meta-pretty-print(M, (none).EOpDeclSet)  = nil .

  eq my-meta-pretty-print(((var V : ES .) EVDS))
    = ('\n '\t 'var V ': my-meta-pretty-print(ES) '. my-meta-pretty-print(EVDS)) .
  eq my-meta-pretty-print((none).EVarDeclSet) = nil .

  eq my-meta-pretty-print(M, (mb T : ES .) EMAS)
    = ('\n '\t 'mb my-meta-pretty-print(M, T) ': my-meta-pretty-print(ES) '. 
       my-meta-pretty-print(M, EMAS)) .
  ceq my-meta-pretty-print(M, (cmb T : ES if T' = T'' .) EMAS)
    = ('\n '\t 
       'cmb my-meta-pretty-print(M, T) ': my-meta-pretty-print(ES) 
           'if my-meta-pretty-print(M, T') '= my-meta-pretty-print(M, T'') '. 
       my-meta-pretty-print(M, EMAS)) 
       if T'' =/= {'true}'Bool .
  eq my-meta-pretty-print(M, (cmb T : ES if T' = {'true}'Bool .) EMAS)
    = ('\n '\t 
       'cmb my-meta-pretty-print(M, T) ': my-meta-pretty-print(ES) 
           'if my-meta-pretty-print(M, T') '. 
       my-meta-pretty-print(M, EMAS)) .
  eq my-meta-pretty-print(M, (none).EMembAxSet) = nil .

  eq my-meta-pretty-print(M, ((eq T = T' .) EqS))
    = ('\n '\t 
       'eq my-meta-pretty-print(M, T) '= my-meta-pretty-print(M, T') '. 
       my-meta-pretty-print(M, EqS)) .
  ceq my-meta-pretty-print(M, ((ceq T = T' if T'' = T''' .) EqS))
    = ('\n '\t 
       'ceq my-meta-pretty-print(M, T) '= my-meta-pretty-print(M, T')
           'if my-meta-pretty-print(M, T'') '= my-meta-pretty-print(M, T''') '. 
       my-meta-pretty-print(M, EqS))
       if T''' =/= {'true}'Bool .
  eq my-meta-pretty-print(M, ((ceq T = T' if T'' = {'true}'Bool .) EqS))
    = ('\n '\t 
       'ceq my-meta-pretty-print(M, T) '= my-meta-pretty-print(M, T')
           'if my-meta-pretty-print(M, T'') '. 
       my-meta-pretty-print(M, EqS)) .
  eq my-meta-pretty-print(M, (none).EquationSet) = nil .

  eq my-meta-pretty-print(M, ((rl [L] : T => T' .) RlS))
    = ('\n '\t 
       'rl '`[ L '`] ': my-meta-pretty-print(M, T) '=> my-meta-pretty-print(M, T') '.
       my-meta-pretty-print(M, RlS)) .
  ceq my-meta-pretty-print(M, ((crl [L] : T => T' if T'' = T''' .) RlS))
    = ('\n '\t 
       'crl '`[ L '`] ': my-meta-pretty-print(M, T) '=> my-meta-pretty-print(M, T') 
           'if my-meta-pretty-print(M, T'') '= my-meta-pretty-print(M, T''') '. 
       my-meta-pretty-print(M, RlS)) 
       if T''' =/= {'true}'Bool .
  eq my-meta-pretty-print(M, ((crl [L] : T => T' if T'' = {'true}'Bool .) RlS))
    = ('\n '\t 
       'crl '`[ L '`] ': my-meta-pretty-print(M, T) '=> my-meta-pretty-print(M, T') 
           'if my-meta-pretty-print(M, T'') '. 
       my-meta-pretty-print(M, RlS)) .
  eq my-meta-pretty-print(M, (none).RuleSet) = nil .

  eq my-meta-pretty-print(M, (assoc AtS))
    = ('assoc my-meta-pretty-print(M, AtS)) .
  eq my-meta-pretty-print(M, (comm AtS))
    = ('comm my-meta-pretty-print(M, AtS)) .
  eq my-meta-pretty-print(M, (memo AtS))
    = ('memo my-meta-pretty-print(M, AtS)) .
  eq my-meta-pretty-print(M, (ctor AtS))
    = ('ctor my-meta-pretty-print(M, AtS)) .
  eq my-meta-pretty-print(M, (special(HL) AtS))
    = ('special '`( my-meta-pretty-print(M, HL) '`) my-meta-pretty-print(M, AtS)) .
  eq my-meta-pretty-print(M, (id(T) AtS))
    = ('id: my-meta-pretty-print(M, T) my-meta-pretty-print(M, AtS)) .
  eq my-meta-pretty-print(M, (right-id(T) AtS))
    = ('right 'id: my-meta-pretty-print(M, T) my-meta-pretty-print(M, AtS)) .
  eq my-meta-pretty-print(M, (left-id(T) AtS))
    = ('left 'id: my-meta-pretty-print(M, T) my-meta-pretty-print(M, AtS)) .
  eq my-meta-pretty-print(M, (prec(I) AtS))
    = ('prec my-meta-pretty-print(I) my-meta-pretty-print(M, AtS)) .
  eq my-meta-pretty-print(M, (strat(MIL) AtS))
    = ('strat '`( my-meta-pretty-print(MIL) '`) my-meta-pretty-print(M, AtS)) .
  eq my-meta-pretty-print(M, (gather(QIL) AtS))
    = ('gather '`( QIL '`) my-meta-pretty-print(M, AtS)) .
  eq my-meta-pretty-print(M, (none).AttrSet) = nil .

  eq my-meta-pretty-print(M, (H HL))
    = (my-meta-pretty-print(M, H) my-meta-pretty-print(M, HL)) .
  eq my-meta-pretty-print(M, id-hook(QI, nil))
    = ('id-hook QI) .
  ceq my-meta-pretty-print(M, id-hook(QI, QIL))
    = ('id-hook QI '`( QIL '`)) 
      if QIL =/= nil .
  eq my-meta-pretty-print(M, op-hook(QI, QI', nil, QI''))
    = ('op-hook QI '`( QI' ': '-> QI'' '`)) .
  ceq my-meta-pretty-print(M, op-hook(QI, QI', QIL, QI''))
    = ('op-hook QI '`( QI' ': QIL '-> QI'' '`)) 
      if QIL =/= nil .
  eq my-meta-pretty-print(M, term-hook(QI, T))
    = ('term-hook QI '`( my-meta-pretty-print(M, T) '`)) .

  eq my-meta-pretty-print((I MIL))
    = (index(', I) my-meta-pretty-print(MIL)) .
  eq my-meta-pretty-print((nil).MachineIntList) = nil .

  eq my-meta-pretty-print((class ES | ADS .) CDS)
    = ((if ADS == none
        then ('\n '\t 'class my-meta-pretty-print(ES) '.)
        else ('\n '\t 'class my-meta-pretty-print(ES) '| 
              my-meta-pretty-print(ADS) '.)
        fi)
       my-meta-pretty-print(CDS)) .
  eq my-meta-pretty-print((none).ClassDeclSet) = nil .

  eq my-meta-pretty-print((subclass ES < ES' .) SCDS)
    = ('\n '\t 'subclass my-meta-pretty-print(ES) '< my-meta-pretty-print(ES') '.
       my-meta-pretty-print(SCDS)) .
  eq my-meta-pretty-print((none).SubclassDeclSet) = nil .

  eq my-meta-pretty-print((msg F : ESL -> ES .) MDS)
    = ('\n '\t 'msg F ': my-meta-pretty-print(ESL) '-> my-meta-pretty-print(ES) '.
       my-meta-pretty-print(MDS)) .
  eq my-meta-pretty-print((none).MsgDeclSet) = nil .

  ceq my-meta-pretty-print(((attr F : ES), ADS))
    = (F ': my-meta-pretty-print(ES) '`, my-meta-pretty-print(ADS))
      if ADS =/= none .
  eq my-meta-pretty-print((attr F : ES))
    = (F ': my-meta-pretty-print(ES)) .
  eq my-meta-pretty-print((none).AttrDeclSet) = nil .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

\subsubsection{Meta Pretty Printing of Units}

In the following module, the \texttt{meta-pretty-print} function is defined on
sort \texttt{Unit}.

\small
\begin{verbatim}
%)

fmod UNIT-META-PRETTY-PRINT is
  pr UNIT .
  pr DECL-META-PRETTY-PRINT .

  op my-meta-pretty-print : Unit Unit -> QidList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op my-meta-pretty-print : Module Unit -> QidList .
  op my-meta-pretty-print : ModName -> QidList .
  op my-meta-pretty-print : ParameterList -> QidList .
  op my-meta-pretty-print : EImportList -> QidList .

  var M : Module .
  var QI : Qid .
  var QIL : QidList .
  var ME : ModExp .
  var MN : ModName .
  var SS : QidSet .
  var ESS : ESortSet .
  var PL : ParameterList .
  var IL : ImportList .
  var EIL : EImportList .
  var SSDS : SubsortDeclSet .
  var ESSDS : ESubsortDeclSet .
  var ODS : OpDeclSet .
  var EODS : EOpDeclSet .
  var VDS : VarDeclSet .
  var EVDS : EVarDeclSet .
  var MAS : MembAxSet .
  var EMAS : EMembAxSet .
  var EqS : EquationSet .
  var RlS : RuleSet .
  var CDS : ClassDeclSet .
  var SCDS : SubclassDeclSet .
  var MDS : MsgDeclSet .
  var U : Unit .

  eq my-meta-pretty-print(MN) = modNameToQidList(MN) .

  eq my-meta-pretty-print(U, unitError(QIL)) = QIL .
  eq my-meta-pretty-print(M, 
        mod QI is IL (sorts SS .) SSDS ODS VDS MAS EqS RlS endm)
    = ('mod QI 'is 
           my-meta-pretty-print(IL) 
           (if SS == none
            then nil
            else ('\n '\t 'sorts my-meta-pretty-print(SS) '.)
            fi)
           my-meta-pretty-print(SSDS) my-meta-pretty-print(M, ODS)
           my-meta-pretty-print(VDS) my-meta-pretty-print(M, MAS) 
           my-meta-pretty-print(M, EqS) my-meta-pretty-print(M, RlS) 
       '\n
       'endm
       '\n) .
  eq my-meta-pretty-print(M, 
        mod MN is PL EIL (sorts ESS .) ESSDS EODS EVDS EMAS EqS RlS endm)
    = ('mod my-meta-pretty-print(MN) 
           (if PL == nilParameterList 
            then nil
            else '`[ my-meta-pretty-print(PL) '`] 
            fi) 'is 
           my-meta-pretty-print(EIL) 
           (if ESS == none
            then nil
            else ('\n '\t 'sorts my-meta-pretty-print(ESS) '.)
            fi) 
           my-meta-pretty-print(ESSDS) my-meta-pretty-print(M, EODS)
           my-meta-pretty-print(EVDS) my-meta-pretty-print(M, EMAS) 
           my-meta-pretty-print(M, EqS) my-meta-pretty-print(M, RlS) 
       '\n
       'endm
       '\n) .
  eq my-meta-pretty-print(M, 
        th MN is PL EIL (sorts ESS .) ESSDS EODS EVDS EMAS EqS RlS endth)
    = ('th my-meta-pretty-print(MN) 
           (if PL == nilParameterList 
            then nil
            else '`[ my-meta-pretty-print(PL) '`] 
            fi) 'is 
           my-meta-pretty-print(EIL) 
           (if ESS == none
            then nil
            else ('\n '\t 'sorts my-meta-pretty-print(ESS) '.)
            fi) 
           my-meta-pretty-print(ESSDS) my-meta-pretty-print(M, EODS)
           my-meta-pretty-print(EVDS) my-meta-pretty-print(M, EMAS) 
           my-meta-pretty-print(M, EqS) my-meta-pretty-print(M, RlS) 
       '\n
       'endth
       '\n) .
  eq my-meta-pretty-print(M, 
        fmod QI is IL (sorts SS .) SSDS ODS VDS MAS EqS endfm)
    = ('fmod QI 'is my-meta-pretty-print(IL) 
           (if SS == none
            then nil
            else ('\n '\t 'sorts my-meta-pretty-print(SS) '.)
            fi)  
           my-meta-pretty-print(SSDS) my-meta-pretty-print(M, ODS)
           my-meta-pretty-print(VDS) my-meta-pretty-print(M, MAS) 
           my-meta-pretty-print(M, EqS) 
       '\n 
       'endfm
       '\n) .
  eq my-meta-pretty-print(M, 
        fmod MN is PL EIL (sorts ESS .) ESSDS EODS EVDS EMAS EqS endfm)
    = ('fmod my-meta-pretty-print(MN) 
           (if PL == nilParameterList 
            then nil
            else '`[ my-meta-pretty-print(PL) '`] 
            fi) 'is 
           my-meta-pretty-print(EIL) 
           (if ESS == none
            then nil
            else ('\n '\t 'sorts my-meta-pretty-print(ESS) '.)
            fi)  
           my-meta-pretty-print(ESSDS) my-meta-pretty-print(M, EODS)
           my-meta-pretty-print(EVDS) my-meta-pretty-print(M, EMAS) 
           my-meta-pretty-print(M, EqS) 
       '\n 
       'endfm
       '\n) .
  eq my-meta-pretty-print(M, 
        fth MN is PL EIL (sorts ESS .) ESSDS EODS EVDS EMAS EqS endfth)
    = ('fth my-meta-pretty-print(MN) 
           (if PL == nilParameterList 
            then nil
            else '`[ my-meta-pretty-print(PL) '`] 
            fi) 'is 
           my-meta-pretty-print(EIL)
           (if ESS == none
            then nil
            else ('\n '\t 'sorts my-meta-pretty-print(ESS) '.)
            fi)  
           my-meta-pretty-print(ESSDS) my-meta-pretty-print(M, EODS)
           my-meta-pretty-print(EVDS) my-meta-pretty-print(M, EMAS) 
           my-meta-pretty-print(M, EqS) 
       '\n 
       'endfth
       '\n) .
  eq my-meta-pretty-print(M, 
        omod MN is 
           PL EIL (sorts ESS .) ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS 
        endom)
    = ('omod my-meta-pretty-print(MN) 
           (if PL == nilParameterList
            then nil
            else ('`[ my-meta-pretty-print(PL) '`]) 
            fi) 'is 
           my-meta-pretty-print(EIL) 
           (if ESS == none
            then nil
            else ('\n '\t 'sorts my-meta-pretty-print(ESS) '.)
            fi)   
           my-meta-pretty-print(ESSDS) my-meta-pretty-print(CDS) 
           my-meta-pretty-print(SCDS) my-meta-pretty-print(M, EODS) 
           my-meta-pretty-print(MDS) 
           my-meta-pretty-print(EVDS) my-meta-pretty-print(M, EMAS) 
           my-meta-pretty-print(M, EqS) my-meta-pretty-print(M, RlS) 
       '\n
       'endom
       '\n) .
  eq my-meta-pretty-print(M, 
        oth MN is 
           PL EIL (sorts ESS .) ESSDS CDS SCDS EODS MDS EVDS EMAS EqS RlS 
        endoth)
    = ('oth my-meta-pretty-print(MN) 
           (if PL == nilParameterList
            then nil
            else ('`[ my-meta-pretty-print(PL) '`]) 
            fi) 'is 
           my-meta-pretty-print(EIL) 
           (if ESS == none
            then nil
            else ('\n '\t 'sorts my-meta-pretty-print(ESS) '.)
            fi)   
           my-meta-pretty-print(ESSDS) my-meta-pretty-print(CDS) 
           my-meta-pretty-print(SCDS) my-meta-pretty-print(M, EODS) 
           my-meta-pretty-print(MDS) 
           my-meta-pretty-print(EVDS) my-meta-pretty-print(M, EMAS) 
           my-meta-pretty-print(M, EqS) my-meta-pretty-print(M, RlS) 
       '\n
       'endoth
       '\n) .

  eq my-meta-pretty-print((including ME .) EIL)
    = ('\n '\t 'including my-meta-pretty-print(ME) '. my-meta-pretty-print(EIL)) .
  eq my-meta-pretty-print((including (par QI :: ME) .) EIL)
    = my-meta-pretty-print(EIL) .
  eq my-meta-pretty-print((nil).EImportList) = nil .

  ceq my-meta-pretty-print(parameterList((par QI :: ME), PL))
    = (QI '::  my-meta-pretty-print(ME) '`,  my-meta-pretty-print(PL))
      if PL =/= nilParameterList .
  eq my-meta-pretty-print((par QI :: ME))
    = (QI '::  my-meta-pretty-print(ME)) .
  eq my-meta-pretty-print(nilParameterList) = nil .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize

The function \texttt{meta-pretty-print} on units is defined recursively,
calling the \texttt{meta-pretty-print} functions for the different
declarations in the unit defined in module \texttt{DECL-META-PRETTY-PRINT}.


\subsubsection{Meta Pretty Printing of Maps and Views}

We define in the following module the function \texttt{meta-pretty-print} on
maps.

\small
\begin{verbatim}
%)

fmod MAP-SET-META-PRETTY-PRINT is
  pr DECL-META-PRETTY-PRINT .
  pr MAP .
  pr UNIT .

  op my-meta-pretty-print : MapSet -> QidList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var MAP : Map .
  var MAPS : MapSet .
  vars QI QI' F F' L L' : Qid .
  var AtS : AttrSet .
  vars ES ES' : ESort .
  var ESL : ESortList .

  ceq my-meta-pretty-print((MAP, MAPS))
    = (my-meta-pretty-print(MAP) '`, my-meta-pretty-print(MAPS))
      if MAPS =/= none .
  eq my-meta-pretty-print((none).MapSet) = nil .

  eq my-meta-pretty-print(op F to F' [AtS])
    = if AtS == none
      then ('op F 'to F') 
      else ('op F 'to F' '`[ my-meta-pretty-print(noModule, AtS) '`]) 
           *** In a map there should not be attributes requiring a module 
      fi .
  eq my-meta-pretty-print(op F : ESL -> ES to F' [AtS])
    = if AtS == none
      then ('op F ': my-meta-pretty-print(ESL) '-> my-meta-pretty-print(ES) 'to F') 
      else ('op F ': my-meta-pretty-print(ESL) '-> my-meta-pretty-print(ES) 'to F' 
                 '`[ my-meta-pretty-print(noModule, AtS) '`]) 
           *** In a map there should not be attributes requiring a module 
      fi .
  eq my-meta-pretty-print(sort ES to ES')
    = ('sort my-meta-pretty-print(ES) 'to my-meta-pretty-print(ES')) .
  eq my-meta-pretty-print(label L to L')
    = ('label L 'to L') .
  eq my-meta-pretty-print(class ES to ES')
    = ('class my-meta-pretty-print(ES) 'to my-meta-pretty-print(ES')) .
  eq my-meta-pretty-print(attr QI . ES to QI')
    = ('attr QI '. my-meta-pretty-print(ES) 'to QI') .
  eq my-meta-pretty-print(msg F to F')
    = ('msg F 'to F') .
  eq my-meta-pretty-print(msg F : ESL -> ES to F')
    = ('msg F ': my-meta-pretty-print(ESL) '-> my-meta-pretty-print(ES) 'to F') .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


Finally, in the \texttt{VIEW-META-PRETTY-PRINT} module, the
\texttt{meta-pretty-print} function is defined on views.

\small
\begin{verbatim}
%)

fmod VIEW-META-PRETTY-PRINT is
  pr DATABASE .
  pr MAP-SET-META-PRETTY-PRINT .
  pr VIEW-MAP-SET-APPL-ON-UNIT .
  pr DECL-EXT-SORT-TO-QID .

  op my-meta-pretty-print : Database View -> QidList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op my-meta-pretty-print : 
        ModExp ModExp Database ViewMapSet ViewMapSet -> QidList .

  var QI : Qid .
  var DB : Database .
  vars ME ME' : ModExp .
  var MAP : Map .
  var VMAP : ViewMap .
  vars VMAPS VMAPS' : ViewMapSet .
  var EVDS : EVarDeclSet .
  vars T T' : Term .
  
  eq my-meta-pretty-print(DB, view(QI, nilParameterList, ME, ME', VMAPS))
    = ('\n 'view QI 'from my-meta-pretty-print(ME) 'to my-meta-pretty-print(ME') 'is 
       '\n '\t my-meta-pretty-print(ME, ME', DB, VMAPS, VMAPS) 
       '\n 'endv) .

  ceq my-meta-pretty-print(ME, ME', DB, (VMAP, VMAPS), VMAPS')
    = (my-meta-pretty-print(ME, ME', DB, VMAP, VMAPS')
       '\n '\t my-meta-pretty-print(ME, ME', DB, VMAPS, VMAPS'))
      if VMAPS =/= none .     
  eq my-meta-pretty-print(ME, ME', DB, none, VMAPS)
    = nil .

  eq my-meta-pretty-print(ME, ME', DB, MAP, VMAPS)
    = my-meta-pretty-print(MAP) '. .
  eq my-meta-pretty-print(ME, ME', DB, termMap(EVDS, T, T'), VMAPS)
    = ('op 
       my-meta-pretty-print(
          addVarDeclSet(eSortToQid(EVDS), getSignature(ME, DB)), T)
       'to 'term
       my-meta-pretty-print(
          addVarDeclSet(
             eSortToQid(applyMapSetToVarDeclSet(sortMapSet(VMAPS), EVDS)), 
             getSignature(ME', DB)), T') '.) .

  eq my-meta-pretty-print(termMap(EVDS, T, T'))
    = ('`{ my-meta-pretty-print(EVDS) '`} 
       'op my-meta-pretty-print(T) 'to my-meta-pretty-print(T')) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Input Processing}

The processing functions presented in the following modules are in charge of
taking each term generated by the \texttt{meta-parse} function and, after
transforming it into an element of the data types \texttt{Unit} or
\texttt{View}, or generating some output, returning the database resulting
from introducing in it such a term. We shall see in
Section~\ref{database-handling} how the appropriate function is called after
having performed a first analysis of the term, in which it is detected whether
the input corresponds to a unit, view, or command. In the cases of units and
views the processing is quite similar. After a preprocessing of the term, the
function \texttt{parseDecl} is called with each of the subterms representing
declarations, resulting in units or views with the parsed declarations in it.


\subsubsection{Unit Processing}
\label{unit-processing}

The processing of a term resulting from the parsing of some input
corresponding to a unit is accomplished by the \texttt{processUnit} function.
This function takes as arguments a term of sort \texttt{Term}, which
represents some preunit, and a database. The function then enters into the
given database the unit obtained from the transformation of such term into a
term of sort \texttt{Unit}.

\small
\begin{verbatim}
%)

fmod UNIT-PROCESSING is
  pr DATABASE .
  pr UNIT-DECL-PARSING .
  pr EVALUATION .
  pr VIEW-MAP-SET-APPL-ON-UNIT .

  vars F X : Qid .
  vars PU U U' : Unit .
  var DB : Database .
  vars T T' T'' : Term .
  var TL : TermList .
  vars PL PL' : ParameterList .
  var EIL : EImportList .
  var ME : ModExp .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var S : Qid .
  var SS : QidSet .
  var EIL' : EImportList .
  var ME' : ModExp .
  var VMAPS : ViewMapSet .
  var B : Bool .

***(%
\end{verbatim}
\normalsize

\end{comment}

The \texttt{parseParameterList} takes a term representing a list of parameters
and returns the corresponding list.

\small
\begin{verbatim}
%)

  op parseParameterList : Term -> ParameterList .
  eq parseParameterList('_::_['token[T], T'])
    = (par downQid(T) :: parseModExp(T')) .
  eq parseParameterList('_`,_[T, T'])
    = parameterList(parseParameterList(T), parseParameterList(T')) .

***(%
\end{verbatim}
\normalsize

The function \texttt{processParameters} takes a preunit and a database and
returns the resulting premodule and database, after processing each of the
parameters in the parameter list of the preunit. For each of the parameters
an importation declaration is added to the module, and the module expression
used as parameter theory is evaluated in the database. The function returns a
pair composed by a preunit and a database (\texttt{UnitDatabasePair}) as its
result.

The function \texttt{processParametersAux} proceeds recursively on each of the
parameters in the list of parameters of the given module. For each parameter
of the form \verb~par X :: ME~, the module expression \texttt{ME} is evaluated
using the \texttt{evalModExp} function, which was discussed in
Section~\ref{evalModExp}, and then a copy of such a theory is created using the
\texttt{createCopy} function, which applies to the unit the appropriate
transformation, as explained in Section~\ref{instantiation}.

\small
\begin{verbatim}
%)

  sort UnitDatabasePair .
  op <_;_> : Unit Database -> UnitDatabasePair .
  op preUnit : UnitDatabasePair -> Unit .
  op database : UnitDatabasePair -> Database .

  eq database(< PU ; DB >) = DB .
  eq preUnit(< PU ; DB >) = PU .

  op processParameters : Unit Database -> UnitDatabasePair .
  op processParametersAux : Unit ParameterList ParameterList EImportList 
       Database -> UnitDatabasePair .

  eq processParameters(PU, DB)
    = processParametersAux(
        PU, parameterList(PU), parameterList(PU), nil, DB) .

  eq processParametersAux(
       PU, PL, parameterList((par X :: ME), PL'), EIL, DB)
    = processParametersAux(
        PU, PL, PL', ((including (par X :: ME) .) EIL), 
        createCopy(ME, (par X :: ME), evalModExp(ME, PL, DB))) .
  eq processParametersAux(PU, PL, nilParameterList, EIL, DB)
    = < addImportList(EIL, PU) ; DB > .

***(%
\end{verbatim}
\normalsize

All the operators declared as constructors of sort \texttt{PreUnit} in the
signature of Full Maude, given in Appendix~\ref{signature-full-maude}, are
declared with two arguments, namely, the name, or name and interface, of the
unit, and the list of declarations of such units. The function
\texttt{processUnit2} is called with the term corresponding to the name, or
name and interface, of the module as first argument, the term corresponding to
the set of declarations as second argument, and an empty module of the
appropriate type, in which the different declarations will be accumulated, as
third argument.

The task of the function \texttt{processUnit3} is then to make a second level
parsing of the input, building up, simultaneously, the preunit represented in
the term passed as argument, and the unit resulting from the declarations
without bubbles. This unit without bubbles will be used by the
\texttt{evalPreUnit} function to build the signature with which to analyze the
bubbles in the preunit (see Section~\ref{evaluation}).

The case of parameterized modules requires a special treatment of the
parameters. These parameters are evaluated and are added as submodules in the
appropriate way.

\begin{comment}
Since the gathering pattern of the constructor \verb~__~ for the
different lists of declarations in the signature of Full Maude in
which the inputs are parsed is by default \verb~(e E)~, we are
guaranteed that all the terms representing lists of declarations are
of the form \verb~'__[T, T']~, with the term \texttt{T} representing a
single declaration and with \texttt{T'} representing a list of
declarations of the same form, or otherwise a single declaration.
\end{comment}

When the last declaration is parsed, the function \texttt{evalPreUnit} is
called with the preunit (the top module with bubbles) as first argument, the
empty copy of it as second argument, the top module without bubbles as third
argument, and the database.

Note that the \texttt{processUnit} function adds a declaration importing the
module \texttt{CONFIGURATION}, presented in
Section~\ref{non-built-in-predefined}, to the object-oriented modules, and
that \texttt{processUnit3} adds a declaration importing the built-in module
\texttt{BOOL} to all modules.

\small
\begin{verbatim}
%)

  op processUnit : Term Database -> Database .
  op processUnit2 : Term Term Unit Database -> Database .
  op processUnit3 : Term Unit Unit Database -> Database .

  eq processUnit('fmod_is_endfm[T, T'], DB)
    = processUnit2(T, T', emptyStrFModule, DB) .
  eq processUnit('obj_is_endo[T, T'], DB)
    = processUnit2(T, T', emptyStrFModule, DB) .
  eq processUnit('obj_is_jbo[T, T'], DB)
    = processUnit2(T, T', emptyStrFModule, DB) .
  eq processUnit('mod_is_endm[T, T'], DB)
    = processUnit2(T, T', emptyStrSModule, DB) .
  eq processUnit('omod_is_endom[T, T'], DB)
    = processUnit2(T, T', 
        addImportList((including 'CONFIGURATION .), emptyStrOModule), DB) .
  eq processUnit('fth_is_endfth[T, T'], DB)
    = processUnit2(T, T', emptyStrFTheory, DB) .
  eq processUnit('th_is_endth[T, T'], DB)
    = processUnit2(T, T', emptyStrSTheory, DB) .
  eq processUnit('oth_is_endoth[T, T'], DB)
    = processUnit2(T, T', 
        addImportList((including 'CONFIGURATION .), emptyStrOTheory), DB) .

  eq processUnit2('token[T], T', U, DB)
    = if downQid(T) inModNameSet builtIns
      then warning(DB, 
             ('ERROR: 'built-in 'modules 'can 'not 'be 'redefined))
      else processUnit3(T',
             setName(U, downQid(T)), 
             setName(U, modNameToQid(downQid(T))), DB) 
      fi .
  eq processUnit2('_`[_`]['token[T], T'], T'', U, DB)
    = if downQid(T) inModNameSet builtIns
      then warning(DB, 
             ('ERROR: 'built-in 'modules 'can 'not 'be 'redefined))
      else processUnit3(T'',
             preUnit(
               processParameters(
                 setParameterList(setName(U, downQid(T)), 
                   parseParameterList(T')), DB)), 
             setName(U, modNameToQid(downQid(T))),
             database(
               processParameters(
                 setParameterList(setName(U, downQid(T)), 
                   parseParameterList(T')), DB)))
      fi .

  eq processUnit3('__[T, T'], PU, U, DB)
    = processUnit3(T', preUnit(parseDecl(T, PU, U)), 
        unit(parseDecl(T, PU, U)), DB) .
  ceq processUnit3(F[TL], PU, U, DB)
    = evalPreUnit(
        preUnit(
          parseDecl(
            F[TL], addImportList((including 'BOOL .), PU), U)), 
        unit(
          parseDecl(
            F[TL], addImportList((including 'BOOL .), PU), U)),
        DB)
      if F =/= '__ .

endfm

***(%
\end{verbatim}
\normalsize


\subsubsection{View Processing}
\label{view-processing}

A similar process is followed for views. Note that in case of operator
maps going to derived terms we have bubbles, which will have to be 
treated using the signatures of the appropriate modules.

\small
\begin{verbatim}
%)

fmod VIEW-PROCESSING is
  pr UNIT-PROCESSING .
  pr VIEW-DECL-PARSING .
  pr VIEW-BUBBLE-PARSING .

  var F : Qid .
  vars T T' T'' T''' : Term .
  var M : Module .
  var VE : ViewExp .
  var PV : PreView .
  vars ME ME' : ModExp .
  var DB : Database .
  var EODS : EOpDeclSet .
  var MDS : MsgDeclSet .
  var TL : TermList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var IS : InfoSet .
  var MN : ModName .
  var EIL : EImportList .

***(%
\end{verbatim}
\normalsize

\end{comment}

As the functions \texttt{getTheorySortSet} and \texttt{getTheoryClassSet}
presented in Section~\ref{instantiation}, the functions
\texttt{getTheoryOpDeclSet} and \texttt{getTheoryMsgDeclSet} return,
respectively, the set of declarations of operators, and the set of
declarations of messages in the theory part of the structure of the module
given as argument.

\small
\begin{verbatim}
%)

  op getTheoryOpDeclSet : ModName Database -> EOpDeclSet .
  op getTheoryMsgDeclSet : ModName Database -> MsgDeclSet .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  op getTheoryOpDeclSetAux : EImportList Database -> EOpDeclSet .
  op getTheoryMsgDeclSetAux : EImportList Database -> MsgDeclSet .

  eq getTheoryOpDeclSet(MN, DB)
    = if getTopUnit(MN, DB) : StrTheory
      then (getTheoryOpDeclSetAux(importList(getTopUnit(MN, DB)), DB)
            opDeclSet(getTopUnit(MN, DB)))
      else none
      fi .

  eq getTheoryOpDeclSetAux(((including MN .) EIL), DB)
    = (getTheoryOpDeclSet(MN, DB) getTheoryOpDeclSetAux(EIL, DB)) .
  eq getTheoryOpDeclSetAux(nil, DB) = none .

  eq getTheoryMsgDeclSet(MN, DB)
    = if getTopUnit(MN, DB) : StrTheory
      then (getTheoryMsgDeclSetAux(importList(getTopUnit(MN, DB)), DB)
            msgDeclSet(getTopUnit(MN, DB)))
      else none
      fi .

  eq getTheoryMsgDeclSetAux(((including MN .) EIL), DB)
    = (getTheoryMsgDeclSet(MN, DB) getTheoryMsgDeclSetAux(EIL, DB)) .
  eq getTheoryMsgDeclSetAux(nil, DB) = none .

***(%
\end{verbatim}
\normalsize

\end{comment}

The processing of terms representing previews accomplished by the function
\texttt{processView} is quite similar to the one accomplished by
\texttt{processUnit} on terms representing preunits. The algorithms followed
are also quite similar. Both proceed recursively on the list of declarations,
accumulating them in a preunit or in a preview.

The solving of bubbles in views requires the signatures of the source
and target units extended, respectively, with the declarations of
variables in the view and with the mappings of these declarations. As
we shall see in Section~\ref{databaseADT}, the signatures of the
built-in modules are not accesible at the metalevel, and thus built-in
modules cannot be used directly as arguments of built-in
functions. Thus, to be able to use them as targets of views, a `dummy'
module is created importing the corresponding predefined module. The
source and target module expressions of the view are evaluated before
the view processing itself starts.

As we saw in Section~\ref{view-decl-parsing}, parsing of terms
representing operator and message maps requires the set of operator and
message declarations in the theory part of the source theory.

\small
\begin{verbatim}
%)

  op processView : Term Database -> Database .
  op processView : Term ViewExp ModExp ModExp Database -> Database .
  op processViewAux : 
        Term PreView EOpDeclSet MsgDeclSet Module Database -> Database .

  eq processView(
       'view_from_to_is_endv['viewToken[T], T', T'', T'''], DB)
    = processView(
        T''', downQid(T), parseModExp(T'), parseModExp(T''), DB) .

  eq processView(T, VE, ME, ME', DB)
    = processViewAux(T, 
        emptyPreView(VE, ME, ME'), 
        getTheoryOpDeclSet(ME, evalModExp(ME, DB)),
        getTheoryMsgDeclSet(ME, evalModExp(ME, DB)),
        getSignature(ME, evalModExp(ME, DB)),
        evalModExp(ME', evalModExp(ME, DB))) .

  eq processViewAux('__[T, T'], PV, EODS, MDS, M, DB)
  *** - EODS and MDS are, respectively, the set of operation and 
  ***   message declarations in the theory part of the source. 
  *** - M is the signature of the source theory.
    = processViewAux(
        T', parseDecl(T, PV, EODS, MDS, M), EODS, MDS, M, DB) .
  ceq processViewAux(F[TL], PV, EODS, MDS, M, DB)
    = insertView(
        view(name(parseDecl(F[TL], PV, EODS, MDS, M)),
          nilParameterList,
          source(parseDecl(F[TL], PV, EODS, MDS, M)),
          target(parseDecl(F[TL], PV, EODS, MDS, M)),
          solveBubbles(
            mapSet(parseDecl(F[TL], PV, EODS, MDS, M)), 
            varDeclSet(parseDecl(F[TL], PV, EODS, MDS, M)),
               *** this set is used only to check what is a vble
            addVarDeclSet(
              eSortToQid(varDeclSet(parseDecl(F[TL], PV, EODS, MDS, M))), M),
            (if target(parseDecl(F[TL], PV, EODS, MDS, M)) 
                  inModNameSet builtIns
             then (fmod 'DUMMY-2 is
                     including target(parseDecl(F[TL], PV, EODS, MDS, M)) .
                     sorts none .
                     none
                     none
                     eSortToQid(
                       applyMapSetToVarDeclSet( 
                         sortMapSet(
                           mapSet(parseDecl(F[TL], PV, EODS, MDS, M))),
                             varDeclSet(parseDecl(F[TL], PV, EODS, MDS, M))))
                     none
                     none
                   endfm)
             else addVarDeclSet(
                    eSortToQid(
                      applyMapSetToVarDeclSet( 
                        sortMapSet(mapSet(parseDecl(F[TL], PV, EODS, MDS, M))),
                        varDeclSet(parseDecl(F[TL], PV, EODS, MDS, M)))),
                    getSignature(target(parseDecl(F[TL], PV, EODS, MDS, M)),
                      DB))
             fi))),
        DB)
      if F =/= '__ .

***(%
\end{verbatim}
\normalsize

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\subsubsection{Command Processing}

The function \texttt{processCommand} only handles the \texttt{reduce},
\texttt{rewrite}, and \texttt{down} commands. The other commands are directly
evaluated by the rules for the top-level handling of the database (see
Section~\ref{database-handling}). The \texttt{processCommand} function takes a
term, which represents one of these commands, the name of the default module,
and a database. The result is a list of quoted identifiers representing the
result of the evaluation of the command that will be placed in the
read-eval-print loop to be printed in the terminal.

The \texttt{reduce} and \texttt{rewrite} commands are basically evaluated
calling the built-in functions \texttt{meta-reduce} and \texttt{meta-rewrite},
respectively. These functions are called with the appropriate modules. In the
case of commands in which an explicit module is not specified the default
module is used.

The preparation of the output for these functions becomes more complex when
the \texttt{down} command is used. To deal with the \texttt{down} command, an
auxiliary function \texttt{processCommand2} is introduced, returning the term
resulting from the evaluation of the command.

\small
\begin{verbatim}
%)

fmod COMMAND-PROCESSING is
  pr UNIT-PROCESSING .
  pr UNIT-META-PRETTY-PRINT .

  vars T T' T'' : Term .
  var DB : Database .
  var M : Module .
  var MN : ModName .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  var MNS : ModNameSet .
  var VE : ViewExp .
  var VES : ViewExpSet .
  var I : MachineInt .
  var IS : InfoSet .
  var QIL : QidList .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  op processCommand : Term ModExp Database -> QidList .
  op processReduce : ModExp Module Term Database -> QidList .
  op processReduce : ModExp Unit Term Database -> QidList .
  op processRewrite : ModExp Module Term MachineInt Database -> QidList .
  op processRewrite : ModExp Unit Term MachineInt Database -> QidList .
  op processCommand2 : ModExp Term Module Database -> Term .
  op processReduce2 : ModExp Module Term Database -> Term .
  op processRewrite2 : ModExp Module Term MachineInt Database -> Term .

***(%
\end{verbatim}
\normalsize

To illustrate the processing of commands, we give here the equations needed
for the handling of the \verb~red_.~ and \verb~down_:_.~ commands.

\small
\begin{verbatim}
%)

  op DUMMY : ModName -> Module .
  eq DUMMY(MN)
    = (fmod 'DUMMY is
          including MN .
          sorts none .
          none 
          none
          none
          none
          none
       endfm) .

  ceq processCommand('down_:_[T, T'], MN, DB)
    = if processCommand2(MN, T', getFlatUnit(MN, DB), DB) =/= error*
      then ('\n 'result 
            my-meta-pretty-print(
              my-leastSort(if parseModExp(T) inModNameSet builtIns 
                        then DUMMY(parseModExp(T))
                        else getFlatUnit(parseModExp(T), DB)
                        fi, 
                downTerm(processCommand2(MN, T', getFlatUnit(MN, DB), DB))))
            ':
            my-meta-pretty-print(if parseModExp(T) inModNameSet builtIns 
                              then DUMMY(parseModExp(T))
                              else getFlatUnit(parseModExp(T), DB)
                              fi, 
              downTerm(processCommand2(MN, T', getFlatUnit(MN, DB), DB))))
      else ('\n 'ERROR: 'Incorrect 'input '.)
      fi 
      if not MN inModNameSet builtIns .
  ceq processCommand('down_:_[T, T'], MN, DB)
    = if processCommand2(MN, T', DUMMY(MN), DB) =/= error*
      then ('\n 'result 
            my-meta-pretty-print(
              my-leastSort(if parseModExp(T) inModNameSet builtIns 
                        then DUMMY(parseModExp(T))
                        else getFlatUnit(parseModExp(T), DB)
                        fi, 
                downTerm(processCommand2(MN, T', DUMMY(MN), DB))))
            ':
            my-meta-pretty-print(if parseModExp(T) inModNameSet builtIns 
                              then DUMMY(parseModExp(T))
                              else getFlatUnit(parseModExp(T), DB)
                              fi, 
              downTerm(processCommand2(MN, T', DUMMY(MN), DB))))
      else ('\n 'ERROR: 'Incorrect 'input '.)
      fi 
      if MN inModNameSet builtIns .
  ceq processCommand('red_.['bubble[T]], MN, DB)
    = processReduce(MN, getFlatUnit(MN, DB), 'bubble[T], DB)
      if not MN inModNameSet builtIns .
  ceq processCommand('red_.['bubble[T]], MN, DB)
    = processReduce(MN, DUMMY(MN), 'bubble[T], DB) 
      if MN inModNameSet builtIns .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq processCommand('reduce_.['bubble[T]], MN, DB)
    = processCommand('red_.['bubble[T]], MN, DB) .
  eq processCommand('red-in_:_.[T, 'bubble[T']], MN, DB)
    = if parseModExp(T) inModNameSet builtIns 
      then processReduce(parseModExp(T), 
              DUMMY(parseModExp(T)), 'bubble[T'], DB)
      else if unitInDatabase(parseModExp(T), evalModExp(parseModExp(T), DB))
           then processReduce(parseModExp(T), 
                  getFlatUnit(parseModExp(T), evalModExp(parseModExp(T), DB)), 
                  'bubble[T'], DB)
           else ('ERROR:  
                 'module my-meta-pretty-print(parseModExp(T)) 'not 'in 'database)
           fi 
      fi .
  eq processCommand('reduce-in_:_.[T, 'bubble[T']], MN, DB)
    = processCommand('red-in_:_.[T, 'bubble[T']], MN, DB) .

  eq processCommand('rew_.['bubble[T]], MN, DB)
    = if MN inModNameSet builtIns 
      then processRewrite(MN, DUMMY(MN), 'bubble[T], 0, DB) 
      else processRewrite(MN, getFlatUnit(MN, DB), 'bubble[T], 0, DB) 
      fi .
  eq processCommand('rewrite_.['bubble[T]], MN, DB)
    = processCommand('rew_.['bubble[T]], MN, DB) . 

  eq processCommand('rew-`[_`]_.['token[T], 'bubble[T']], MN, DB)
    = if MN inModNameSet builtIns 
      then processRewrite(MN, DUMMY(MN), 'bubble[T'], 
              downMachineInt(downMetaMachineInt(T)), DB)
      else processRewrite(MN, getFlatUnit(MN, DB), 'bubble[T'], 
              downMachineInt(downMetaMachineInt(T)), DB) 
      fi .
  eq processCommand('rewrite-`[_`]_.['token[T], 'bubble[T']], MN, DB)
    = processCommand('rew-`[_`]_.['token[T], 'bubble[T']], MN, DB) .

  eq processCommand('rew-in_:_.[T, 'bubble[T']], MN, DB)
    = if parseModExp(T) inModNameSet builtIns 
      then processRewrite(parseModExp(T), 
               DUMMY(parseModExp(T)), 'bubble[T'], 0, DB)
      else if unitInDatabase(parseModExp(T), evalModExp(parseModExp(T), DB))
           then processRewrite(parseModExp(T), 
                  getFlatUnit(parseModExp(T), evalModExp(parseModExp(T), DB)), 
                  'bubble[T'], 0, DB)
           else ('ERROR:  
                 'module my-meta-pretty-print(parseModExp(T)) 'not 'in 'database)
           fi
      fi .
  eq processCommand('rewrite-in_:_.[T, 'bubble[T']], MN, DB)
    = processCommand('rew-in_:_.[T, 'bubble[T']], MN, DB) .

  ceq processCommand('rew-in-`[_`]_:_.['token[T], T', 'bubble[T'']], MN, DB)
    = if unitInDatabase(parseModExp(T'), evalModExp(parseModExp(T'), DB))
      then processRewrite(parseModExp(T'), 
             getFlatUnit(parseModExp(T'), evalModExp(parseModExp(T'), DB)), 
             'bubble[T''], downMachineInt(downMetaMachineInt(T)), DB)
      else ('ERROR: 
            'module my-meta-pretty-print(parseModExp(T')) 'not 'in 'database)
      fi 
      if not parseModExp(T) inModNameSet builtIns .
  ceq processCommand('rew-in-`[_`]_:_.['token[T], T', 'bubble[T'']], MN, DB)
    = processRewrite(parseModExp(T'), 
         DUMMY(parseModExp(T')), 
         'bubble[T''], downMachineInt(downMetaMachineInt(T)), DB)
      if parseModExp(T) inModNameSet builtIns .
  eq processCommand('rewrite-in-`[_`]_:_.['token[T], T', 'bubble[T'']], MN, DB)
    = processCommand('rew-in-`[_`]_:_.['token[T], T', 'bubble[T'']], MN, DB) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq processCommand2(MN, 'down_:_[T, T'], M, DB)
    = downTerm(processCommand2(MN, T', M, DB)) .

  eq processCommand2(MN, 'red_.['bubble[T]], M, DB)
    = processReduce2(MN, M, 'bubble[T], DB) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq processCommand2(MN, 'reduce_.['bubble[T]], M, DB)
    = processCommand2(MN, 'red_.['bubble[T]], M, DB) .
  eq processCommand2(MN, 'red-in_:_.[T, 'bubble[T']], M, DB)
    = if parseModExp(T) inModNameSet builtIns
      then processReduce2(parseModExp(T), 
              DUMMY(parseModExp(T)), 'bubble[T'], DB)
      else if unitInDatabase(parseModExp(T), evalModExp(parseModExp(T), DB))
           then processReduce2(parseModExp(T), 
                  getFlatUnit(parseModExp(T), evalModExp(parseModExp(T), DB)), 
                  'bubble[T'], DB)
           else error*
           fi
      fi .
  eq processCommand2(MN, 'reduce-in_:_.[T, 'bubble[T']], M, DB)
    = processCommand2(MN, 'red-in_:_.[T, 'bubble[T']], M, DB) .

  eq processCommand2(MN, 'rew_.['bubble[T]], M, DB)
    = processRewrite2(MN, M, 'bubble[T], 0, DB) .
  eq processCommand2(MN, 'rewrite_.['bubble[T]], M, DB)
    = processCommand2(MN, 'rew_.['bubble[T]], M, DB) . 
  eq processCommand2(MN, 'rew-`[_`]_.['token[T], 'bubble[T']], M, DB)
    = processRewrite2(MN, M, 'bubble[T'], 
        downMachineInt(downMetaMachineInt(T)), DB) .
  eq processCommand2(MN, 'rewrite-`[_`]_.['token[T], 'bubble[T']], M, DB)
    = processCommand2(MN, 'rew-`[_`]_.['token[T], 'bubble[T']], M, DB) .
  eq processCommand2(MN, 'rew-in_:_.[T, 'bubble[T']], M, DB)
    = if parseModExp(T) inModNameSet builtIns
      then processRewrite2(parseModExp(T), 
              DUMMY(parseModExp(T)), 'bubble[T'], 0, DB)
      else if unitInDatabase(parseModExp(T), evalModExp(parseModExp(T), DB))
           then processRewrite2(parseModExp(T), 
                  getFlatUnit(parseModExp(T), evalModExp(parseModExp(T), DB)), 
                  'bubble[T'], 0, DB)
           else error*
           fi
      fi .
  eq processCommand2(MN, 'rewrite-in_:_.[T, 'bubble[T']], M, DB)
    = processCommand2(MN, 'rew-in_:_.[T, 'bubble[T']], M, DB) .
  eq processCommand2(MN, 'rew-in-`[_`]_:_.['token[T], T', 'bubble[T'']], M, DB)
    = if parseModExp(T) inModNameSet builtIns
      then processRewrite2(parseModExp(T'), DUMMY(parseModExp(T')), 
             'bubble[T''], downMachineInt(downMetaMachineInt(T)), DB)
      else if unitInDatabase(parseModExp(T'), evalModExp(parseModExp(T'), DB))
           then processRewrite2(parseModExp(T'), 
                  getFlatUnit(parseModExp(T'), 
                     evalModExp(parseModExp(T'), DB)), 
                  'bubble[T''], downMachineInt(downMetaMachineInt(T)), DB)
           else error*
           fi
      fi .
  eq processCommand2(MN, 
       'rewrite-in-`[_`]_:_.['token[T], T', 'bubble[T'']], M, DB)
    = processCommand2(MN, 
        'rew-in-`[_`]_:_.['token[T], T', 'bubble[T'']], M, DB) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq processReduce(MN, M, T, DB)
    = if meta-reduce(M, solveBubbles(T, M, true, DB)) =/= error*
      then ('reduce 'in my-meta-pretty-print(MN) ': 
            my-meta-pretty-print(M, solveBubbles(T, M, true, DB)) '. '\n 
            'result
            my-meta-pretty-print(
              my-leastSort(M, meta-reduce(M, solveBubbles(T, M, true, DB)))) ':
            my-meta-pretty-print(M, 
               meta-reduce(M, solveBubbles(T, M, true, DB)))) '\n 
      else ('ERROR: 'Incorrect 'Command '. '\n)
      fi .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq processReduce(MN, unitError(QIL), T, DB)
    = QIL .

  eq processRewrite(MN, M, T, I, DB)
    = if meta-reduce(M, solveBubbles(T, M, true, DB)) =/= error*
      then ('rewrite 'in my-meta-pretty-print(MN) ':
            my-meta-pretty-print(M, solveBubbles(T, M, true, DB)) '. '\n 
            'result
            my-meta-pretty-print(
              my-leastSort(M, 
                meta-rewrite(M, solveBubbles(T, M, true, DB), I))) ':
            my-meta-pretty-print(M, 
              meta-rewrite(M, solveBubbles(T, M, true, DB), I)) '\n ) 
      else ('ERROR: 'Incorrect 'Command '. '\n)
      fi .
  eq processRewrite(MN, unitError(QIL), T, I, DB) = QIL .

***(%
\end{verbatim}
\normalsize

\end{comment}

\small
\begin{verbatim}
%)

  eq processReduce2(MN, M, T, DB)
    = meta-reduce(M, solveBubbles(T, M, true, DB)) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  eq processRewrite2(MN, M, T, I, DB)
    = meta-rewrite(M, solveBubbles(T, M, true, DB), I) .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endfm

***(%
\end{verbatim}
\normalsize


\section{Interaction with the Persistent Database}
\label{persistent-database}


In the case of Full Maude, the persistent state of the system is given by a
single object which maintains the database of the system. This object has an
attribute \texttt{db}, to keep the actual database in which all the modules
being entered are stored, an attribute \texttt{default}, to keep the
identifier of the current module by default, and attributes \texttt{input} and
\texttt{output} to simplify the communication of the read-eval-print loop
given by the \texttt{LOOP-MODE} module with the database. Using the notation
for classes in object-oriented modules (see
Section~\ref{object-oriented-modules}) we can declare the class
\texttt{database} as follows:

\small
\begin{verbatim}
  class database | db : Database, input : TermList, 
                   output : QidList, default : ModId .
\end{verbatim}
\normalsize
Since we assume that \texttt{database} is the only object class that has been
defined---so that the only objects of sort \texttt{Object} will belong to the
\texttt{database} class---to specify the admissible states in the persistent
state of \texttt{LOOP-MODE} for Full Maude, it is enough to give the subsort
declaration

\small
\begin{alltt}
  subsort Object < State .
\end{alltt}
\normalsize

\begin{comment}

\subsection{The \texttt{CONFIGURATION} Module}

\small
\begin{verbatim}
%)

fmod CONFIGURATION is
  sort Oid Cid Attribute AttributeSet 
       Configuration Object Msg .

  subsort Attribute < AttributeSet .
  subsorts Object Msg < Configuration .

  op none : -> AttributeSet .
  op _,_ : AttributeSet AttributeSet -> AttributeSet [assoc comm id: none] .
  op none : -> Configuration .
  op __ : Configuration Configuration -> Configuration 
        [assoc comm id: none] .
  op <_:_|_> : Oid Cid AttributeSet -> Object .
  op <_:_| > : Oid Cid -> Object .

  var O : Oid .
  var C : Cid .

  eq < O : C | > = < O : C | none > .
endfm

***(%
\end{verbatim}
\normalsize

\end{comment}

\subsection{Top Level Handling of the Persistent Database}
\label{database-handling}

Note that, since the Full Maude specification is given as a system module in
Core Maude, object-oriented declarations cannot be given directly. Instead,
the equivalent declarations desugaring the desired object-oriented
declarations have to be specified. We use also the same conventions discussed
in Section~\ref{omod2mod} regarding the use of variables instead of class
names in the objects and in the addition of variables of sort
\texttt{AttributeSet} to range over the additional attributes. As we shall see
in Chapter~\ref{crc}, this convention will allow us to extend the Full Maude
system in a very simple and clean way.

To allow the use of the object-oriented notation the predefined module
\texttt{CONFIGURATION}, presented in Section~\ref{omod2mod}, is included in
the following module \texttt{DATABASE-HANDLING}.

\small
\begin{verbatim}
%)

mod DATABASE-HANDLING is
  inc META-LEVEL .
  inc CONFIGURATION .
  pr VIEW-META-PRETTY-PRINT .
  pr VIEW-PROCESSING .
  pr COMMAND-PROCESSING .

  var F : Qid .
  var QIL : QidList .
  vars T T' T'' T''' : Term .
  var TL : TermList .
  var DB : Database .
  var MN : ModName .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  vars QIL' QIL'' : QidList .
  var MNS : ModNameSet .
  var VE : ViewExp .
  var VES : ViewExpSet .
  var IS : InfoSet .

***(%
\end{verbatim}
\normalsize

\end{comment}

We start introducing a subsort \texttt{DatabaseClass} of sort \texttt{Cid},
the operator declarations necessary for representing objects in class
\texttt{DatabaseClass} as defined above, and variables to range over
subclasses of class \texttt{DatabaseClass} and over attributes.

\small
\begin{verbatim}
%)

  sort DatabaseClass .
  subsort DatabaseClass < Cid .
  op Database : -> DatabaseClass .
  op db :_ : Database -> Attribute .
  op input :_ : TermList -> Attribute .
  op output :_ : QidList -> Attribute .
  op default :_ : ModName -> Attribute .

  var Atts : AttributeSet .
  var X@Database : DatabaseClass .
  var O : Oid .

***(%
\end{verbatim}
\normalsize

Next, we introduce an auxiliary function \texttt{parseModName} to parse names
of user-defined modules, and a constant \texttt{nilTermList} of sort
\texttt{TermList}. Note that the name of a user-defined module must be a
single identifier (a token) or, for parameterized modules, its name---a single
identifier---and its interface.

\small
\begin{verbatim}
%)

  op parseModName : Term -> Qid .
  eq parseModName('token[T]) = downQid(T) .
  eq parseModName('_`[_`]['token[T], T']) = downQid(T) .

  op nilTermList : -> TermList .

  eq (nilTermList, TL) = TL .
  eq (TL, nilTermList) = TL .

***(%
\end{verbatim}
\normalsize

Finally, we present the rules processing the inputs of the database. These
rules define the behavior of the system for the different commands, modules,
theories, and views entered into the system. For example, the first rule
processes the different types of modules entered to the system. Note that the
operators declared as constructors of sort \texttt{PreUnit} in the signature
of Full Maude, given in Appendix~\ref{signature-full-maude}, are declared with
two arguments, namely the name of the unit, or its name plus its interface,
and the list of declarations of such a unit.

\small
\begin{verbatim}
%)

  crl [module] :
     < O : X@Database | db : DB, input : (F[T, T']), 
        output : nil, default : MN, Atts >
     => < O : X@Database | 
           db : processUnit(F[T, T'], DB), input : nilTermList, 
           output : 
             ('\n 'Introduced 'module: modNameToQid(parseModName(T))),
           default : parseModName(T), Atts > 
        if (F == 'fmod_is_endfm) or (F == 'obj_is_endo) or 
           (F == 'obj_is_jbo) or (F == 'mod_is_endm) 
              or (F == 'omod_is_endom) .

***(%
\end{verbatim}
\normalsize

Notice the message placed in the output channel, and the change in the current
module by default, which is now the new module just processed. Since the name
of the module \texttt{T} can be complex---a parameterized module---some
extra parsing has to be performed by the auxiliary function
\texttt{parseModName}. Similar rules are given for the processing of theories
and views.

\small
\begin{verbatim}
%)

  crl [theory] :
     < O : X@Database | db : DB, input : (F[T, T']), 
        output : nil, default : MN, Atts >
     => < O : X@Database | 
           db : processUnit(F[T, T'], DB), input : nilTermList, 
           output : 
             ('\n 'Introduced 'theory: modNameToQid(parseModName(T))),
           default : parseModName(T), Atts > 
        if (F == 'fth_is_endfth) or (F == 'th_is_endth) 
              or (F == 'oth_is_endoth) .

  rl [view] :
     < O : X@Database | db : DB, 
        input : ('view_from_to_is_endv['viewToken[T], T', T'', T''']), 
        output : nil, default : MN, Atts >
     => < O : X@Database | 
           db : processView(
                  'view_from_to_is_endv['viewToken[T], T', T'', T'''], DB),
           input : nilTermList, 
           output : ('\n 'Introduced 'view: downQid(T)), 
           default : MN, Atts > .

***(%
\end{verbatim}
\normalsize

Commands are handled by rules as well. For example, the \texttt{down},
\texttt{reduce}, and \texttt{rewrite} commands are handled by the following
rules.

\small
\begin{verbatim}
%)

  rl [down] :
     < O : X@Database | db : DB, input : ('down_:_[T, T']), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : processCommand('down_:_[T, T'], MN, DB), 
           default : MN, Atts > .

  crl [red/rew] :
     < O : X@Database | db : DB, input : (F[TL]), 
        output : QIL, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : processCommand(F[TL], MN, DB), 
           default : MN, Atts > 
        if (F == 'red_.) or (F == 'reduce_.) 
            or (F == 'red-in_:_.) or (F == 'reduce-in_:_.) 
            or (F == 'rew_.) or (F == 'rewrite_.) 
            or (F == 'rew-`[_`]_.) or (F == 'rewrite-`[_`]_.) 
            or (F == 'rew-in_:_.) or (F == 'rewrite-in_:_.) 
            or (F == 'rew-in-`[_`]_:_.) 
            or (F == 'rewrite-in-`[_`]_:_.) .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  rl [select] :
     < O : X@Database | db : DB, input : ('select_.[T]), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : nil, default : parseModExp(T), Atts > .

  rl [show-modules] :
     < O : X@Database | db : DB, 
        input : ({'show`modules`.}'PreCommand), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : showUnits(DB), default : MN, Atts > .
  rl [show-views] :
     < O : X@Database | db : DB, 
        input : ({'show`views`.}'PreCommand), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : showViews(DB), default : MN, Atts >  .

***(%
\end{verbatim}
\normalsize

\end{comment}

The \texttt{show module} command, which prints the specified module, or the
current one if no module name is specified, is handled by the following rules.

\small
\begin{verbatim}
%)

  rl [show-module-1] :
     < O : X@Database | db : DB, 
        input : ({'show`module`.}'PreCommand), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getFlatUnit(MN, DB),
                      getTopUnit(MN, DB)),
           default : MN, Atts >  .
  rl [show-module-2] :
     < O : X@Database | db : DB, input : ('show`module_.[T]), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getFlatUnit(parseModExp(T), DB),
                      getTopUnit(parseModExp(T), DB)),
           default : MN, Atts > .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  rl [show-all-1] :
     < O : X@Database | db : DB, input : ({'show`all`.}'PreCommand), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getFlatUnit(MN, DB),
                      getFlatUnit(MN, DB)),
           default : MN, Atts >  .
  rl [show-all-2] :
     < O : X@Database | db : DB, input : ('show`all_.[T]), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getFlatUnit(parseModExp(T), DB),
                      getFlatUnit(parseModExp(T), DB)),
           default : MN, Atts > .

  rl [show-sorts-1] :
     < O : X@Database | db : DB, input : ({'show`sorts`.}'PreCommand), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(
                      sortSet(sortDecl(getSignature(MN, DB)))),
           default : MN, Atts >  .

  rl [show-sorts-2] :
     < O : X@Database | db : DB, input : ('show`sorts_.[T]), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(
                      sortSet(sortDecl(getSignature(parseModExp(T), DB)))),
           default : MN, Atts > .

  rl [show-ops-1] :
     < O : X@Database | db : DB, input : ({'show`ops`.}'PreCommand), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getSignature(MN, DB), 
                      opDeclSet(getSignature(MN, DB))),
           default : MN, Atts >  .

  rl [show-ops-2] :
     < O : X@Database | db : DB, input : ('show`ops_.[T]), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getSignature(parseModExp(T), DB), 
                      opDeclSet(getSignature(parseModExp(T), DB))),
           default : MN, Atts > .

  rl [show-vars-1] :
     < O : X@Database | db : DB, input : ({'show`vars`.}'PreCommand), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(varDeclSet(getSignature(MN, DB))),
           default : MN, Atts >  .

  rl [show-vars-2] :
     < O : X@Database | db : DB, input : ('show`vars_.[T]), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(
                      varDeclSet(getSignature(parseModExp(T), DB))),
           default : MN, Atts > .

  rl [show-mbs-1] :
     < O : X@Database | db : DB, input : ({'show`mbs`.}'PreCommand), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getFlatUnit(MN, DB), 
                      membAxSet(getFlatUnit(MN, DB))),
           default : MN, Atts >  .

  rl [show-mbs-2] :
     < O : X@Database | db : DB, input : ('show`mbs_.[T]), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getFlatUnit(parseModExp(T), DB), 
                      membAxSet(getFlatUnit(parseModExp(T), DB))),
           default : MN, Atts > .

  rl [show-eqns-1] :
     < O : X@Database | db : DB, input : ({'show`eqns`.}'PreCommand), 
        output : nil, default : MN, Atts >
     => < O : X@Database | 
           db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getFlatUnit(MN, DB), 
                      equationSet(getFlatUnit(MN, DB))),
           default : MN, Atts >  .

  rl [show-eqns-2] :
     < O : X@Database | db : DB, input : ('show`eqns_.[T]), 
        output : nil, default : MN, Atts >
     => < O : X@Database | 
           db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getFlatUnit(parseModExp(T), DB), 
                      equationSet(getFlatUnit(parseModExp(T), DB))),
           default : MN, Atts > .

  rl [show-rls-1] :
     < O : X@Database | db : DB, input : ({'show`rls`.}'PreCommand), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getFlatUnit(MN, DB), 
                      ruleSet(getFlatUnit(MN, DB))),
           default : MN, Atts >  .

  rl [show-rls-2] :
     < O : X@Database | db : DB, input : ('show`rls_.[T]), 
        output : nil, default : MN >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : my-meta-pretty-print(getFlatUnit(parseModExp(T), DB), 
                      ruleSet(getFlatUnit(parseModExp(T), DB))),
           default : MN, Atts > .

  rl [show-view] :
     < O : X@Database | db : DB, input : ('show`view_.[T]), 
        output : nil, default : MN, Atts >
     => < O : X@Database | db : DB, input : nilTermList, 
           output : 
             if viewInDatabase(parseViewExp(T), DB)
             then my-meta-pretty-print(DB, getView(parseViewExp(T), DB))
             else ('\n 'ERROR: 'view parseViewExp(T) 'not 'in 'X@Database)
             fi,
           default : MN, Atts > .

  crl [error] :
     < O : X@Database | db : database(IS, MNS, VES, QIL), 
        input : TL, output : nil, default : MN, Atts >
     => < O : X@Database | 
           db : database(IS, MNS, VES, nil), 
           input : TL, output : QIL, default : MN, Atts > 
        if QIL =/= nil .

  *** Auxiliary Functions

  op showViews : Database -> QidList .
  op showUnits : Database -> QidList .

  eq showViews(database(IS, MNS, (VE # VES), QIL))
    = (my-meta-pretty-print(VE) '\n showViews(database(IS, MNS, VES, QIL))) .
  eq showViews(database(IS, MNS, noneViewExpSet, QIL)) = nil .

  eq showUnits(database(IS, (MN & MNS), VES, QIL))
    = (my-meta-pretty-print(MN) '\n showUnits(database(IS, MNS, VES, QIL))) .
  eq showUnits(database(IS, noneModNameSet, VES, QIL)) = nil .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endm

***(%
\end{verbatim}
\normalsize

\subsection{The Full Maude Module}
\label{main-module}

We now give the rules to initialize the loop, and to specify the communication
between the loop---the input/output of the system---and the database.
Depending on the kind of input that the database receives, its state will be
changed, or some output will be generated.

\small
\begin{verbatim}
%)

mod PRE-FULL-MAUDE is
  pr META-PRE-FULL-MAUDE-SIGN .
  pr DATABASE-HANDLING .
  pr PREDEF-UNITS .
  inc LOOP-MODE .

***(%
\end{verbatim}
\normalsize

The state of the persistent system, which is supported by the built-in
module \texttt{LOOP-MODE}, described in Section~\ref{loop}, is
represented as a single object.

\small
\begin{verbatim}
%)

  subsort Object < State .

  op o : -> Oid .
  op init : -> System .

  var Atts : AttributeSet .
  var X@Database : DatabaseClass .
  var O : Oid .
  var DB : Database .
  var MN : ModName .
  vars QIL QIL' QIL'' : QidList .
  var TL : TermList .

***(%
\end{verbatim}
\normalsize

The rule specifying the initial value of the loop is given below. We
initialize the database with the predefined modules introduced in
Section~\ref{non-built-in-predefined}. 

\small
\begin{verbatim}
%)

  rl [init] :
     init
     => [nil,
         < o : Database | 
            db : evalUnit(CONFIGURATION, 
                   evalUnit(TRIV, 
                     evalUnit(UP, emptyDatabase))),
            input : nilTermList, 
            output : nil, 
            default : nullModName >,
         'nil] .

***(%
\end{verbatim}
\normalsize

When some text has been introduced in the loop, the first argument of the
operator \verb~[_,_,_,]~ is different from \texttt{nil}, and we can use this
fact to activate the following rule, that enters an input such as a module or
a command from the user into the database.  The constant \texttt{GRAMMAR}
names the module containing the signature defining the top level syntax of
Full Maude (see Section~\ref{sec:signature} and
Appendix~\ref{signature-full-maude}).  This signature is used by the
\texttt{meta-parse} function to parse the input.  If the input is
syntactically valid\footnote{Of course, the input may be syntactically valid,
but not semantically valid, since further processing---for example, of
bubbles---may reveal a semantic inconsistency.}, the parsed input is
placed in the \texttt{input} attribute of the database object; otherwise, an
error message is placed in the output channel of the loop.

\small
\begin{verbatim}
%)

  crl [in] :
     [QIL, 
      < O : X@Database | db : DB, input : nilTermList, 
         output : nil, default : MN, Atts >, 
      QIL']
     => if meta-parse(GRAMMAR, QIL) == error*
        then [nil, 
              < O : X@Database | db : DB, input : nilTermList, 
                 output : ('ERROR: 'incorrect 'input '.), 
                 default : MN, Atts >, 
              QIL'] 
        else [nil, 
              < O : X@Database | db : DB, 
                 input : meta-parse(GRAMMAR, QIL),
                 output : nil, default : MN, Atts >, 
              QIL'] 
        fi
        if QIL =/= nil .

***(%
\end{verbatim}
\normalsize

When the \texttt{output} attribute of the persistent object contains a
nonempty list of quoted identifiers, the \texttt{out} rule moves it to the
third argument of the loop. Then the Core Maude system displays it in the
terminal.

\small
\begin{verbatim}
%)

  crl [out] :
     [QIL, 
      < O : X@Database | db : DB, input : TL, 
         output : QIL', default : MN, Atts >, 
      QIL'']
     => [QIL, 
         < O : X@Database | db : DB, input : TL, 
            output : nil, default : MN, Atts >, 
         (QIL' QIL'')] 
        if QIL' =/= nil .

endm

***(%
\end{verbatim}
\normalsize


\section{Extending Full Maude}
\label{extension}

We illustrate in this section the way in which the module algebra of Full
Maude can be extended by defining new module expressions and integrating them
with the rest of the system. As an example of module-combining operations we
present the classical sum, or union, of module expressions; and as an example
showing the new possibilities for defining module operations we present a
module expression such that, given any nonzero natural number, it generates a
parameterized module specifying tuples of the corresponding size. The
evaluation of these new module expressions follows the general scheme
for the evaluation of module expressions discussed in
Section~\ref{evalModExp}, that is, a new module with such module expression as
name must be created, giving to the expression the intended semantics.

The syntax used for the union of module expressions is 

\small
\begin{verbatim}
  op _+_ : ModExp ModExp -> ModExp [assoc prec 42] .
\end{verbatim}
\normalsize
Its evaluation consists in generating a unit importing the two module
expressions given as arguments~\cite{Winkler91,OBJ92}.

The syntax used for the $n$-tuple module expression is as follows:

\small
\begin{verbatim}
  op TUPLE(_) : Token -> ModExp .
\end{verbatim}
\normalsize
Its evaluation consists in the generation of a parameterized functional module
with the number of \texttt{TRIV} parameters specified by the argument. A sort
for tuples of such size, and the corresponding constructor and selector
operators, are also defined. Note that the \texttt{TRIV} theory is predefined
in Full Maude (see Sections~\ref{main-module}
and~\ref{non-built-in-predefined}). For example, the module expression
\verb~TUPLE(3)~ produces the following module.

\small
\begin{verbatim}
fmod TUPLE(3)[C1 :: TRIV, C2 :: TRIV, C3 :: TRIV] is 
   sorts 3Tuple . 
   op (_,_,_) : Elt.C1 Elt.C2 Elt.C3 -> 3Tuple . 
   op p1_ : 3Tuple -> Elt.C1 . 
   op p2_ : 3Tuple -> Elt.C2 . 
   op p3_ : 3Tuple -> Elt.C3 . 
   var E1 : Elt.C1 . 
   var E2 : Elt.C2 . 
   var E3 : Elt.C3 . 
   eq p1(E1, E2, E3) = E1 . 
   eq p2(E1, E2, E3) = E2 . 
   eq p3(E1, E2, E3) = E3 . 
endfm
\end{verbatim}
\normalsize


\subsection{Extending the Signature}
\label{signature-extension}

As mentioned in Section~\ref{sec:signature}, in order to add any new
module expressions the first thing we must do is to extend the signature of
Full Maude. In the following module \texttt{FULL-MAUDE-SIGN} we extend the
module \texttt{PRE-FULL-MAUDE-SIGN}, given in Appendix~\ref{signature-full-maude},
which contains the declarations of the signature of Full Maude, with the
declarations for the syntax of the new module expressions.

\small
\begin{verbatim}
%)

fmod FULL-MAUDE-SIGN is
  including PRE-FULL-MAUDE-SIGN .

  op TUPLE(_) : Token -> ModExp .
  op _+_ : ModExp ModExp -> ModExp [assoc prec 42] .
endfm

***(%
\end{verbatim}
\normalsize

In Section~\ref{sec:signature} we saw how a constant \texttt{GRAMMAR} of sort
\texttt{FModule} was declared in the \texttt{META-PRE-FULL-MAUDE-SIGN}
module. Such a constant was then identified with the metarepresentation of a
module \texttt{GRAMMAR}, in which there was a declaration importing the
\texttt{PRE-FULL-MAUDE-SIGN} module and declarations for the constructors of the
bubble sorts. To extend the metarepresentation of the module to be used in the
parsing process, we define a new constant \texttt{EXT-GRAMMAR}, of sort
\texttt{FModule} as well, which extends the module \texttt{GRAMMAR}. We can do
this using the \texttt{addImportList} function presented in
Section~\ref{unitADT} as in the following module. 

\small
\begin{verbatim}
%)

fmod META-FULL-MAUDE-SIGN is
  inc META-LEVEL .
  pr META-PRE-FULL-MAUDE-SIGN .
  pr UNIT .

  op EXT-GRAMMAR : -> FModule .
  eq EXT-GRAMMAR 
    = addImportList((including 'FULL-MAUDE-SIGN .), GRAMMAR) .
endfm

***(%
\end{verbatim}
\normalsize

Now the constant \texttt{EXT-GRAMMAR} is identified with the
metarepresentation of a module which contains the constructors of the bubble
sorts and importation declarations for both \texttt{PRE-FULL-MAUDE-SIGN} and
\texttt{FULL-MAUDE-SIGN}. Since \texttt{FULL-MAUDE-SIGN} imports
\texttt{PRE-FULL-MAUDE-SIGN}, we get the desired result.


\subsection{The Union Module Expression}
\label{union}

As we explained in Sections~\ref{instantiation} and~\ref{renaming} for the
cases of the instantiation and the renaming module expressions, respectively,
the declaration of any new kind of module expression must come together with
the definition of the functions \texttt{evalModExp},
\texttt{modNameToQidList}, and \texttt{setUpModExpDependencies} on the new
module operator. As discussed in Sections~\ref{instantiation}
and~\ref{parsing-unit-declarations}, equations for the \texttt{prepareModName}
and \texttt{parseModExp} functions have to be given as well.

\small
\begin{verbatim}
%)

fmod UNION-EXPR is
  inc MOD-EXPR .
  pr EVALUATION .
  pr UNIT-DECL-PARSING .

***(%
\end{verbatim}
\normalsize

First of all, we declare the new module operator of sort \texttt{ModExp} as
follows.

\small
\begin{verbatim}
%)

  op _+_ : ModExp ModExp -> ModExp [assoc comm] .

  var PL : ParameterList .
  var DB : Database .
  vars T T' : Term .
  var EIL : EImportList .
  var QIVEPS : QidViewExpPairSet .
  vars ME ME' : ModExp .
  vars U U' U'' U''' : Unit .
  vars M M' M'' M''' : Module .
  vars MNS MNS' MNS'' : ModNameSet .
  vars VES VES' VES'' : ViewExpSet .
  var IS : InfoSet .
  var QIL : QidList .

***(%
\end{verbatim}
\normalsize

As mentioned above, the evaluation of a union module expression consists in
the creation of a new unit, with such a module expression as name, which
imports the two module expressions being united. Note, however, that the unit
being created has to be of the right type. The new unit will be generated
having one type or another, depending on the types of the arguments
of the union module expression.

The function \texttt{rightEmptyUnit} generates an empty unit of the
lowest of the sorts of its two arguments. In case of having a
nonstructured module as argument, the corresponding structured one is
considered. If one of the two module expressions corresponds to a
theory, then a theory is generated, and the lowest sort is taken
between the sort of such a theory and the \texttt{Unit} sort
immediately above the sort of the other unit; that is, sorts
\texttt{FUnit},
\texttt{SUnit}, or \texttt{OUnit} are considered to do the comparison.

\small
\begin{verbatim}
%)

  ceq evalModExp(ME + ME', PL, DB)
    = evalUnit(
        addImportList((including ME .) (including ME' .),
          setName(
            rightEmptyUnit(
               getTopUnit(ME, 
                 evalModExp(ME, PL, evalModExp(ME', PL, DB))),
               getTopUnit(ME, 
                 evalModExp(ME', PL, evalModExp(ME', PL, DB)))),
            ME + ME')), 
        evalModExp(ME, PL, evalModExp(ME', PL, DB)))
      if not unitInDatabase(ME + ME', DB) .

  op rightEmptyUnit : Unit Unit -> Unit [comm] .

  ceq rightEmptyUnit(U, U')
    = emptyStrFModule
      if U : StrFModule and U' : StrFModule .
  ceq rightEmptyUnit(U, U')
    = emptyStrFTheory
      if U : StrFTheory and U' : FUnit .
  ceq rightEmptyUnit(U, U')
    = emptyStrSModule
      if U : StrSModule and U' : StrSModule 
         and not (U : StrFModule or U' : StrFModule) .
  ceq rightEmptyUnit(U, U')
    = emptyStrSTheory
      if U : StrSTheory and U' : SUnit 
         and not (U : StrFTheory or U' : StrFTheory) .
  ceq rightEmptyUnit(U, U')
    = emptyStrOModule
      if U : StrOModule and U' : StrOModule 
         and not (U : StrSModule or U' : StrSModule) .
  ceq rightEmptyUnit(U, U')
    = emptyStrOTheory
      if U : StrOTheory and U' : OUnit 
         and not (U : StrSTheory or U' : StrSTheory) .
  eq rightEmptyUnit(unitError(QIL), U) = unitError(QIL) .
  eq rightEmptyUnit(U, unitError(QIL)) = unitError(QIL) .

***(%
\end{verbatim}
\normalsize

As pointed out in Section~\ref{module-names}, for each new module expression
operator being introduced, we need to add equations for the
\texttt{modNameToQid} function. For the union module expression we only need
the following equation:

\small
\begin{verbatim}
%)

  eq modNameToQidList(ME + ME')
    = (modNameToQidList(ME) '+ modNameToQidList(ME')) .

***(%
\end{verbatim}
\normalsize

Similarly, we need to give equations for the \texttt{setUpModExpDependencies}
function, presented in Section~\ref{databaseADT}, on the union module
expression. Given a module expression of the form \verb~ME + ME'~ such that
\texttt{ME} and \texttt{ME'} are in the database, we just need to add 
\verb~ME + ME'~ to the set of names of the modules depending on \texttt{ME}
and \texttt{ME'}. In this way, if \texttt{ME} or \texttt{ME'} are redefined or
removed from the database, \verb~ME + ME'~ will be removed as well.

\small
\begin{verbatim}
%)

  eq setUpModExpDependencies((ME + ME'), 
       database(
         (< ME ; U ; U' ; M ; M' ; MNS ; VES > 
          < ME' ; U'' ; U''' ; M'' ; M''' ; MNS' ; VES' > IS), 
         MNS'', VES'', QIL))
    = database(
        (< ME ; U ; U' ; M ; M' ; MNS & (ME + ME') ; VES > 
         < ME' ; U'' ; U''' ; M'' ; M''' ; MNS' & (ME + ME') ; VES' > IS), 
        MNS'', VES'', QIL) .
  ceq setUpModExpDependencies((ME + ME'), DB)
    = warning(DB, 
        ('\n 'ERROR: 'module modNameToQidList(ME) 'not 'in 'database '.))
      if not unitInDatabase(ME, DB) .
  ceq setUpModExpDependencies((ME + ME'), DB)
    = warning(DB, 
        ('\n 'ERROR: 'module modNameToQidList(ME') 'not 'in 'database '.))
      if not unitInDatabase(ME', DB) .

***(%
\end{verbatim}
\normalsize

The \texttt{prepareModName} function on a union module expression makes
recursive calls with each of the module expressions given as arguments.

\small
\begin{verbatim}
%)

  eq prepareModName(ME + ME', QIVEPS)
    = prepareModName(ME, QIVEPS) + prepareModName(ME', QIVEPS) .

***(%
\end{verbatim}
\normalsize

Finally, the equation for the \texttt{parseModExp} function is as follows:

\small
\begin{verbatim}
%)

  eq parseModExp('_+_[T, T'])
    = parseModExp(T) + parseModExp(T') .

endfm

***(%
\end{verbatim}
\normalsize


\subsection{The $n$-tuple Module Expression}


Even though the $n$-tuple module expression is in principle of a
completely different nature, the way of handling it is the same as the
way of handling any other module expression. Its evaluation produces a
new unit, a parameterized functional module in this case, with the
module expression as name. New equations defining the semantics of
functions \texttt{evalModExp}, \texttt{modNameToQidList},
\texttt{setUpModExpDependencies}, \texttt{prepareModName}, and
\texttt{parseModExp} are given for this module expression.

\small
\begin{verbatim}
%)

fmod N-TUPLE-EXPR is
  inc MOD-EXPR .
  pr EVALUATION .
  pr UNIT-DECL-PARSING .

***(%
\end{verbatim}
\normalsize

We assume that the parameter given to the expression is a nonzero
natural number.

\small
\begin{verbatim}
%)

  sort NzNat .
  subsort NzNat < NzMachineInt .
  var I : NzMachineInt .
  cmb I : NzNat if I > 0 .

***(%
\end{verbatim}
\normalsize

Then, the declaration of the operator for the $n$-tuple module
expression is as follows: 

\small
\begin{verbatim}
%)

  op TUPLE(_) : NzNat -> ModExp .

  vars N N' : NzNat .
  var PL : ParameterList .
  var DB : Database .
  var T : Term .
  var EIL : EImportList .
  var QIVEPS : QidViewExpPairSet .

***(%
\end{verbatim}
\normalsize

The equation for the \texttt{evalModExp} is reduced to the creation of a
module as indicated above. Some auxiliary functions are defined in order to
generate the different declarations in the module.

\small
\begin{verbatim}
%)

  op tupleParameterList : NzNat -> ParameterList .
  op tupleImportList : NzNat -> ImportList .
  op createCopyParameters : NzNat Database -> Database .
  op tupleOpDeclSet : NzNat -> OpDeclSet .
  op tupleOpDeclSetConstructor : NzNat -> OpDecl .
  op tupleOpDeclSetConstructorName : NzNat -> Qid .
  op tupleOpDeclSetConstructorArity : NzNat -> QidList .
  op tupleOpDeclSetSelectors : NzNat NzNat -> OpDeclSet .
  op tupleVarDeclSet : NzNat -> VarDeclSet .
  op tupleEquationSet : NzNat -> EquationSet .
  op tupleEquationSetAux : NzNat Term -> EquationSet .
  op tupleTermArgs : NzNat -> TermList .
  ops tupleSort tupleSortAux : NzNat -> ESort .

  ceq evalModExp(TUPLE(N), PL, DB)
    = evalUnit(
         fmod TUPLE(N) is
            tupleParameterList(N)
            tupleImportList(N)
            sorts tupleSort(N) .
            none
            tupleOpDeclSet(N)
            tupleVarDeclSet(N)
            none
            tupleEquationSet(N)
         endfm, 
         createCopyParameters(N, DB))
      if not unitInDatabase(TUPLE(N), DB) .

  eq createCopyParameters(N, DB)
    = if N == 1
      then createCopy('TRIV, (par index('C, N) :: 'TRIV), DB)
      else createCopyParameters(_-_(N, 1),
             createCopy('TRIV, (par index('C, N) :: 'TRIV), DB))
      fi .

  eq tupleParameterList(N)
    = if N == 1
      then (par index('C, N) :: 'TRIV)
      else parameterList(tupleParameterList(_-_(N, 1)), 
             (par index('C, N) :: 'TRIV))
      fi .

  eq tupleImportList(N)
    = if N == 1
      then (including par index('C, N) :: 'TRIV .)
      else (tupleImportList(_-_(N, 1)) 
            (including par index('C, N) :: 'TRIV .))
      fi .

  eq tupleSort(N)
    = eSort('Tuple, tupleSortAux(N)) .
  eq tupleSortAux(N)
    = if N == 1
      then index('C, N)
      else _|_(tupleSortAux(_-_(N, 1)), index('C, N))
      fi .

  eq tupleOpDeclSet(N)
    = (tupleOpDeclSetConstructor(N) 
       tupleOpDeclSetSelectors(N, N)) .

  eq tupleOpDeclSetConstructor(N)
    = (op conc('`(, conc(tupleOpDeclSetConstructorName(N), '`))) : 
            tupleOpDeclSetConstructorArity(N) 
            -> tupleSort(N) 
            [none] .) .

  eq tupleOpDeclSetConstructorName(N)
    = if N == 1
      then '_
      else conc('_`,, tupleOpDeclSetConstructorName(_-_(N, 1)))
      fi .

  eq tupleOpDeclSetConstructorArity(N)
    = if N == 1
      then index('Elt.C, N)
      else tupleOpDeclSetConstructorArity(_-_(N, 1)) index('Elt.C, N)
      fi .

  eq tupleOpDeclSetSelectors(N, N')
    = if N == 1 
      then (op conc(index('p, N), '_) : tupleSort(N') -> index('Elt.C, N) 
                 [none] .)
      else (tupleOpDeclSetSelectors(_-_(N, 1), N')
            (op conc(index('p, N), '_) : tupleSort(N') -> index('Elt.C, N) 
                  [none] .))
      fi .

  eq tupleVarDeclSet(N)
    = if N == 1 
      then (var index('E, N) : index('Elt.C, N) .)
      else (tupleVarDeclSet(_-_(N, 1))
            (var index('E, N) : index('Elt.C, N) .))
      fi .

  eq tupleEquationSet(N)
    = tupleEquationSetAux(N, 
        (conc('`(, conc(tupleOpDeclSetConstructorName(N), '`)))
           [tupleTermArgs(N)])) .

  eq tupleTermArgs(N)
    = if N == 1  
      then index('E, 1)
      else (tupleTermArgs(_-_(N, 1)), index('E, N))
      fi .

  eq tupleEquationSetAux(N, T)
    = if N == 1 
      then (eq conc(index('p, N), '_)[T] = index('E, N) .)
      else (tupleEquationSetAux(_-_(N, 1), T)
            (eq conc(index('p, N), '_)[T] = index('E, N) .))
      fi .

***(%
\end{verbatim}
\normalsize

The equations for the \texttt{modNameToQidList}, \texttt{parseModExp},
\texttt{prepareModName}, and \texttt{setUpModExpDependencies} functions on the
$n$-tuple module expression are as follows:

\small
\begin{verbatim}
%)

  eq modNameToQidList(TUPLE(N))
    = ('TUPLE '`( index(', N) '`)) .

  eq parseModExp('TUPLE`(_`)['token[T]])
    = TUPLE(parseMachineInt(T)) .

  eq prepareModName(TUPLE(N), QIVEPS) = TUPLE(N) .

  eq setUpModExpDependencies(TUPLE(N), DB) = DB .

endfm

***(%
\end{verbatim}
\normalsize


\subsection{Extended Full Maude}
\label{the-extended-full-maude}

To integrate the specification of Full Maude with the specification dealing
with these two new module expressions, we must redefine the module
\texttt{PRE-FULL-MAUDE} given in Section~\ref{main-module}. For the present
purposes, we only need to redefine the \texttt{in} rule of that module. In
general we may need to change any of the rules in it. We will come back to
this question in Chapter~\ref{crc}, where we shall discuss further
possibilities of extending Full Maude, adding new predefined modules in the
initial database, defining new commands, or adding new attributes to keep some
extra state in the persistent object.  In the present case, however, we only
need to change the module in which the inputs are parsed. This is done by
changing the \texttt{in} rule such that the constant \texttt{EXT-GRAMMAR} is
used instead of \texttt{GRAMMAR}. Notice that we also need to import the
modules \texttt{UNION-EXPR} and \texttt{N-TUPLE-EXPR}. To facilitate
incremental extensions of the system, we define a new module
\texttt{EXT-DATABASE-HANDLING} importing these modules, and then another
module \texttt{FULL-MAUDE} importing it. \texttt{FULL-MAUDE} also
imports \texttt{PREDEF-UNITS}, \texttt{LOOP-MODE}, and
\texttt{META-FULL-MAUDE-SIGN}.

\small
\begin{verbatim}
%)

mod EXT-DATABASE-HANDLING is
  pr DATABASE-HANDLING .
  pr UNION-EXPR .
  pr N-TUPLE-EXPR .
endm

***(%
\end{verbatim}
\normalsize

\small
\begin{verbatim}
%)

mod FULL-MAUDE is
  pr META-FULL-MAUDE-SIGN .
  pr EXT-DATABASE-HANDLING .
  pr PREDEF-UNITS .
  inc LOOP-MODE .

  subsort Object < State .

  op o : -> Oid .
  op init : -> System .

  var Atts : AttributeSet .
  var X@Database : DatabaseClass .
  var O : Oid .
  var DB : Database .
  var MN : ModName .
  vars QIL QIL' QIL'' : QidList .
  var TL : TermList .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  rl [init] :
     init
     => [nil,
         < o : Database | 
            db : evalUnit(CONFIGURATION, 
                   evalUnit(TRIV, 
                     evalUnit(UP, emptyDatabase))),
            input : nilTermList, output : nil, 
            default : 'META-LEVEL >,
         ('\n '\t  'Full 'Maude 'version '1.0.5
          '\n '\t  'Copyright '1999-2000 'SRI 'International 
          '\n)] .

*** banner:
*** 
*** Full Maude version 1.0.5
*** Copyright 1999-2000 SRI International


***(%
\end{verbatim}
\normalsize

\end{comment}

We only give here the new \texttt{in} rule.

\small
\begin{verbatim}
%)

  crl [in] :
     [QIL, 
      < O : X@Database | db : DB, input : nilTermList, 
         output : nil, default : MN, Atts >, 
      QIL']
     => if meta-parse(EXT-GRAMMAR, QIL) == error*
        then [nil, 
              < O : X@Database | db : DB, input : nilTermList, 
                 output : ('ERROR: 'incorrect 'input '.), 
                 default : MN, Atts >, 
              QIL'] 
        else [nil, 
              < O : X@Database | db : DB, 
                 input : meta-parse(EXT-GRAMMAR, QIL),
                 output : nil, default : MN, Atts >, 
              QIL'] 
        fi
        if QIL =/= nil .

***(%
\end{verbatim}
\normalsize

\begin{comment}

\small
\begin{verbatim}
%)

  crl [out] :
     [QIL, 
      < O : X@Database | db : DB, input : TL, 
         output : QIL', default : MN, Atts >, 
      QIL'']
     => [QIL, 
         < O : X@Database | db : DB, input : TL, 
            output : nil, default : MN, Atts >, 
         (QIL' QIL'')] 
        if QIL' =/= nil .

***(%
\end{verbatim}
\normalsize

\end{comment}

\texttt{...}

\small
\begin{verbatim}
%)

endm

***(%
\end{verbatim}
\normalsize


\section{Concluding Remarks}

We have seen in the previous sections how, by using the
metaprogramming capabilities of Maude, we have been able to define a
Core Maude executable specification of Full Maude. With this
specification we have endowed Full Maude with a module algebra in the
Clear/OBJ tradition, including module hierarchies, parameterized
modules, views, and module expressions. In addition, new
module-combining and module-transforming operations have likewise been
provided.  We have seen, for example, how we have integrated the
transformation of object-oriented modules into their corresponding
system modules with the module algebra, and how new kinds of
``parameterized'' modules, such as parameterized extensions of
\texttt{META-LEVEL} and the $\texttt{TUPLE(}n\texttt{)}$ construction
can be easily added.

The module algebra thus obtained becomes easily \emph{extensible}, in the
sense that a user may easily define new module transformations and module
operations; that is, the user can not only do metaprogramming by using the
module operations provided in the module algebra of the language, but can also
do \emph{meta-metaprogramming} by defining new ones. We have illustrated some
of the possibilities for extending the module algebra by defining some new
module expressions. Furthermore, given the reflective design of Maude, it is
even possible to change both the module operations provided in the basic
syntax of the language and that very syntax itself.

The Full Maude specification described here is part of an overall reflective
and extensible design for the Maude system, in which key components of the
system are written in Maude itself and can be modified or extended with
relative ease. In particular, we plan a number of such extensions for the
module algebra, including the addition of parameterized theories and views,
and the development of other module composition and module transformation
operations. Module operations to hide sorts and operators, and operations to
redefine and remove messages in object-oriented modules are among the more
interesting operations we plan to consider in extensions of our module
algebra.

Furthermore, we plan to generalize the module algebra that we have developed
for Maude into a \emph{module algebra generator}, that could endow many other
specification languages with powerful and extensible algebras for combining
and transforming specifications. Module algebra generator uses can be
supported by defining a \emph{parameterized} algebraic data type, say
$\mathit{ModAlg}[X]$, that, given a logic ${\cal L}$ having ``good''
metalogical properties, extends the data type $\texttt{Module}_{\cal L}$ of
${\cal L}$-theories to an algebra of theory-composition operations
$\mathit{ModAlg}[\mathit{Module}_{\cal L}]$.  The module algebra of Maude
provided by the Full Maude specification should then be regarded as a
particular instance of such a generic construction, namely, for the case in
which the underlying logic ${\cal L}$ is rewriting logic.

Another research direction opened up by this approach that we plan to
pursue in the future is formal reasoning about the properties of
module algebra operations based upon their executable specifications.

%)

loop init .

trace exclude FULL-MAUDE .

set show loop stats on .
set show loop timing on .
