***************** NOMBRE *******************
fmod NATURAL is

***************** CONJUNTOS ****************
   protecting BOOL .
   sort N .
   sort NoN .
   subsort NoN < N .

***************** SINTAXIS *****************
   op cero : -> N .
   op sucesor : N -> N .
   op suma : N N -> N .
   op esCero : N -> Bool .
   op esIgual : N N -> Bool .
   op esDistinto : N N -> Bool .
   op producto : N N -> N .
   op potencia : N N -> N .
   op cuadrado : N -> N .
   op factorial : N -> N .
   op predecesor : N -> N .
   op resta : N N -> N .
   op diferencia : N N -> N .
   op difUno : N N -> Bool .
   op esMenor : N N -> Bool .
   op esMenorIgual : N N -> Bool .
   op esMayor : N N -> Bool .
   op esMayorIgual : N N -> Bool .
   op maximo : N N -> N .
   op minimo : N N -> N .

   op NODEFINIDO : -> NoN .
   op INFINITO : -> NoN .
   op NEGATIVO : -> NoN .

***************** SEMANTICA ****************
   var n m : N .

   eq suma(cero, n) = n .
   eq suma(sucesor(m), n) = sucesor(suma(m, n)) .
   eq esCero(cero) = true .
   eq esCero(sucesor(n)) = false .
   eq esIgual(cero, n) = esCero(n) .
   eq esIgual(sucesor(n), cero) = false .
   eq esIgual(sucesor(n), sucesor(m)) = esIgual(n, m) .
   eq esDistinto(n, m) = not esIgual(n, m) .
   eq producto(cero, n) = cero .
   eq producto(sucesor(n), m) = suma(m, producto(n, m)) .
   eq potencia(cero, cero) = NODEFINIDO .
   eq potencia(cero, n) = cero .
   eq potencia(n, cero) = sucesor(cero) .
   eq potencia(n, sucesor(m)) = producto(n, potencia(n, m)) .
   eq cuadrado(cero) = cero .
   eq cuadrado(n) = producto(n, n) .
   eq factorial(cero) = sucesor(cero) .
   eq factorial(sucesor(n)) = producto(sucesor(n), factorial(n)) .
   eq predecesor(cero) = NEGATIVO .
   eq predecesor(sucesor(n)) = n .
   eq resta(cero, cero) = cero .
   eq resta(cero, n) = NEGATIVO .
   eq resta(n, cero) = n .
   eq resta(sucesor(n), sucesor(m)) = resta(n,m) .
   eq diferencia(cero, n) = n .
   eq diferencia(n, cero) = n .
   eq diferencia(sucesor(n), sucesor(m)) = diferencia(n, m) .
   eq difUno(cero, sucesor(cero)) = true .
   eq difUno(cero, cero) = true .
   eq difUno(sucesor(cero), cero) = true .
   eq difUno(n, cero) = esIgual(factorial(cero), factorial(n)) .
   eq difUno(cero, n) = esIgual(factorial(cero), factorial(n)) .
   eq difUno(sucesor(n), sucesor(m)) = difUno(n, m) .
   eq esMenor(cero, cero) = false .
   eq esMenor(cero, sucesor(cero)) = true .
   eq esMenor(sucesor(cero), cero) = false .
   eq esMenor(n, cero) = false .
   eq esMenor(cero, n) = esDistinto(n, cero) .
   eq esMenor(sucesor(n), sucesor(m)) = esMenor(n, m) .
   eq esMenorIgual(cero, cero) = true .
   eq esMenorIgual(cero, sucesor(cero)) = true .
   eq esMenorIgual(sucesor(cero), cero) = false .
   eq esMenorIgual(n, cero) = esIgual(n, cero) .
   eq esMenorIgual(cero, n) = esDistinto(n, cero) .
   eq esMenorIgual(sucesor(n), sucesor(m)) = esMenorIgual(n, m) .
   eq esMayor(cero, cero) = false .
   eq esMayor(sucesor(cero), cero) = true .
   eq esMayor(cero, sucesor(cero)) = false .
   eq esMayor(n, cero) = esDistinto(n, cero) .
   eq esMayor(cero, n) = false .
   eq esMayor(sucesor(n), sucesor(m)) = esMayor(n, m) .
   eq esMayorIgual(cero, cero) = true .
   eq esMayorIgual(sucesor(cero), cero) = true .
   eq esMayorIgual(cero, sucesor(cero)) = false .
   eq esMayorIgual(n, cero) = true .
   eq esMayorIgual(cero, n) = esIgual(n, cero) .
   eq esMayorIgual(sucesor(n), sucesor(m)) = esMayorIgual(n, m) .
   eq maximo(n, m) = if esMayorIgual(n, m) == true then n else m fi .
   eq minimo(n, m) = if esMenorIgual(n,m) == true then n else m fi .
endfm

***************** NOMBRE *******************
fmod VOCAL is

***************** CONJUNTOS ****************
   protecting BOOL .
   sort V .

***************** SINTAXIS *****************
   ops A E I O U : -> V .
   op esIgual : V V -> Bool .
   op esDistinta : V V -> Bool .
   op esMenor : V V -> Bool .

***************** SEMANTICA ****************
   var v w : V .

   eq esIgual(v, v) = true .
   eq esIgual(v, w) = false .
   eq esDistinta(v, w) = not esIgual(v, w) .
   eq esMenor(v, v) = false .
   eq esMenor(A, v) = true .
   eq esMenor(E, A) = false .
   eq esMenor(E, I) = true .
   eq esMenor(E, O) = true .
   eq esMenor(E, U) = true .
   eq esMenor(I, A) = false .
   eq esMenor(I, E) = false .
   eq esMenor(I, O) = true .
   eq esMenor(I, U) = true .
   eq esMenor(O, A) = false .
   eq esMenor(O, E) = false .
   eq esMenor(O, I) = false .
   eq esMenor(O, U) = true .
   eq esMenor(U, v) = false .
endfm

***************** NOMBRE *******************
fmod PILA is

***************** CONJUNTOS ****************
   protecting BOOL .
   protecting VOCAL .
   protecting NATURAL .
   sort MensajePilas .
   sort P .
   subsorts MensajePilas < V .

***************** SINTAXIS *****************
   op pilaVacia : -> P .
   op esVacia : P -> Bool .
   op push : V P -> P .
   op pop : P -> P .
   op tope : P -> V .
   op esIgual : P P -> Bool .
   op primero : P -> V .
   op tamano : P -> N .
   op cuentaVocal : V P -> N .
   op ERRORPILAVACIA : -> MensajePilas .

***************** SEMANTICA ****************
   var p q : P .
   var v w : V .

   eq esVacia(pilaVacia) = true .
   eq esVacia(push(v, p)) = false .
   eq pop(pilaVacia) = pilaVacia .
   eq pop(push(v, p)) = p .
   eq tope(pilaVacia) = ERRORPILAVACIA .
   eq tope(push(v, p)) = v .
   eq esIgual(pilaVacia, pilaVacia) = true .
   eq esIgual(p, pilaVacia) = esVacia(p) .
   eq esIgual(pilaVacia, p) = esVacia(p) .
   eq esIgual(push(v, p), push(v, q)) = esIgual(p, q) .
   eq esIgual(push(v, p), push (w, q)) = false .
   eq primero(pilaVacia) = ERRORPILAVACIA .
   eq primero(push(v, pilaVacia)) = v .
   eq primero(push(v, p)) = primero(p).
   eq tamano(pilaVacia) = cero .
   eq tamano(push(v, p)) = sucesor(tamano(p)) .
   eq cuentaVocal(v, pilaVacia) = cero .
   eq cuentaVocal(v, push(v, p)) = sucesor(cuentaVocal(v, p)) .
   eq cuentaVocal(v, push(w, p)) = cuentaVocal(v, p) .
endfm

***************** NOMBRE *******************
fmod COLA is

***************** CONJUNTOS ****************
   protecting BOOL .
   protecting VOCAL .
   protecting NATURAL .
   protecting PILA .
   sort MensajeColas .
   sort C .
   subsorts  MensajeColas < V .
***************** SINTAXIS *****************
   op colaVacia : -> C .
   op esVacia : C -> Bool .
   op meter : V C -> C . 
   op sacar : C -> C .
   op cabecera : C -> V .
   op ERRORCOLAVACIA : -> MensajeColas .

***************** SEMANTICA ****************
var c : C .
var v : V .
 
eq esVacia(colaVacia) = true .
eq esVacia(meter(v, c)) = false .
eq sacar(colaVacia) = colaVacia .
eq sacar(meter(v, colaVacia)) = colaVacia .
eq sacar(meter(v, c)) = meter(v, sacar(c)) .
eq cabecera(colaVacia) = ERRORCOLAVACIA .
eq cabecera(meter(v, colaVacia)) = v .
eq cabecera(meter(v, c)) = cabecera(c) .

endfm